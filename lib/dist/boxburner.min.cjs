"use strict";class t{}function e(t,e){if(e.length<=0)throw new Error(`${t}: Cannot have empty list of commands for closed path`);const r=e[e.length-1].to;if(0!==r[0]||0!==r[1])throw new Error(`${t}: Closed path must end on [0, 0]`)}function r(t){let e=0;for(let r=0;r<t.length;r++){const n=t[r].to,s=t[(r+1)%t.length].to;e+=(s[0]-n[0])*(s[1]+n[1])}return e<0}function n(t,e,r,n){const s=(s,o)=>t[s]*(1-o)*(1-o)*(1-o)+3*e[s]*o*(1-o)*(1-o)+3*r[s]*o*o*(1-o)+n[s]*o*o*o,o=o=>{const a=3*n[o]-9*r[o]+9*e[o]-3*t[o],i=6*t[o]-12*e[o]+6*r[o],d=3*e[o]-3*t[o];let c=Math.min(t[o],n[o]),l=Math.max(t[o],n[o]);if(Math.abs(a)<=1e-8){const t=-d/i;if(t>0&&t<1){const e=s(o,t);c=Math.min(c,e),l=Math.max(l,e)}}else{const t=i*i-4*a*d;if(t>=0){const e=Math.sqrt(t),r=(-i+e)/(2*a);if(r>0&&r<1){const t=s(o,r);c=Math.min(c,t),l=Math.max(l,t)}const n=(-i-e)/(2*a);if(n>0&&n<1){const t=s(o,n);c=Math.min(c,t),l=Math.max(l,t)}}}return[c,l]},a=o(0),i=o(1);return[[a[0],i[0]],[a[1],i[1]]]}class s{constructor(t,n,s=[],o=[],a=[],i=[]){if(e("Surface border",n),!r(n))throw new Error("Surface border: Points must be in counter-clockwise order for border");for(let t=0;t<s.length;t++){const n=`Surface hole ${t}`;if(e(n,s[t].commands),r(s[t].commands))throw new Error(`${n}: Points must be in clockwise order for holes`)}this.thickness=t,this.border=n,this.holes=s,this.cuts=o,this.scores=a,this.text=i}borderBoundingBox(){return function(t){let e=[0,0],r=[0,0],s=[0,0];for(const o of t){switch(o.kind){case"L":e[0]=Math.min(e[0],o.to[0]),e[1]=Math.min(e[1],o.to[1]),r[0]=Math.max(r[0],o.to[0]),r[1]=Math.max(r[1],o.to[1]);break;case"C":{const t=n(s,o.c1,o.c2,o.to);e[0]=Math.min(e[0],t[0][0]),e[1]=Math.min(e[1],t[0][1]),r[0]=Math.max(r[0],t[1][0]),r[1]=Math.max(r[1],t[1][1]);break}}s=o.to}return[e,r]}(this.border)}}function o(t){return[t[0],t[1]]}function a(t,e,r){return e=(e%360+360)%360,0!==r&&(0===e?t[0]+=r:90===e?t[1]+=r:180===e?t[0]-=r:270===e?t[1]-=r:(t[0]+=r*Math.cos(e*Math.PI/180),t[1]+=r*Math.sin(e*Math.PI/180))),t}const i=1e-7;class d{constructor(){this.commands=[],this.angle=0}cursor(){return this.commands.length<=0?[0,0]:this.commands[this.commands.length-1].to}lineTo(t){var e,r;const n=this.commands[this.commands.length-1];if(n&&"L"===n.kind){const s=null!==(r=null===(e=this.commands[this.commands.length-2])||void 0===e?void 0:e.to)&&void 0!==r?r:[0,0],o=n.to,a=t;if(Math.abs(s[0]-a[0])<i&&Math.abs(s[1]-a[1])<i)return this.commands.pop(),this;const d=s[0]-o[0],c=s[1]-o[1],l=o[0]-a[0],h=o[1]-a[1];if(Math.abs(d*h-l*c)<i)return n.to=t,this}return this.commands.push({kind:"L",to:t}),this}lineToRelative(t){const e=this.cursor();return this.lineTo([e[0]+t[0],e[1]+t[1]])}quadCurveTo(t,e){const r=this.cursor();return this.curveTo([r[0]+2*(t[0]-r[0])/3,r[1]+2*(t[1]-r[1])/3],[e[0]+2*(t[0]-e[0])/3,e[1]+2*(t[1]-e[1])/3],e)}curveTo(t,e,r){return this.commands.push({kind:"C",c1:t,c2:e,to:r}),this}turn(t){return this.angle=((this.angle+t)%360+360)%360,this}forward(t){return 0!==t&&this.lineToRelative(a([0,0],this.angle,t)),this}close(){var t,e;this.lineTo([0,0]);const r=this.commands[0],n=this.commands[this.commands.length-1];if("L"===(null==n?void 0:n.kind)&&"L"===(null==r?void 0:r.kind)){const s=null!==(e=null===(t=this.commands[this.commands.length-2])||void 0===t?void 0:t.to)&&void 0!==e?e:[0,0],o=n.to,a=r.to,d=s[0]-o[0],c=s[1]-o[1],l=o[0]-a[0],h=o[1]-a[1];if(Math.abs(s[0]-a[0])<i&&Math.abs(s[1]-a[1])<i)this.commands.shift();else if(Math.abs(d*h-l*c)>=i)return this;this.commands.pop();for(const t of this.commands)t.to[0]-=s[0],t.to[1]-=s[1],"C"===t.kind&&(t.c1[0]-=s[0],t.c1[1]-=s[1],t.c2[0]-=s[0],t.c2[1]-=s[1])}return this}build(){return this.commands}}class c{constructor(){this.border=new d,this.holes=[],this.cuts=[],this.scores=[],this.text=[]}hole(t,e=0){const r=new d;return r.turn(e),this.holes.push({offset:t,db:r}),r}cut(t,e=0){const r=new d;return r.turn(e),this.cuts.push({offset:t,db:r}),r}score(t,e=0){const r=new d;return r.turn(e),this.scores.push({offset:t,db:r}),r}build(t){return new s(t,this.border.close().build(),this.holes.map((({offset:t,db:e})=>({offset:t,commands:e.close().build()}))),this.cuts.map((({offset:t,db:e})=>({offset:t,commands:e.close().build()}))),this.scores.map((({offset:t,db:e})=>({offset:t,commands:e.close().build()}))),this.text)}}class l{}class h extends l{name(){return"PlainEdge"}schema(){return{properties:{},metadata:{order:[]}}}thickness(t,e,r,n){return 0}draw(t,e,r,n,s){t.border.forward(e)}}class f extends l{name(){return"BoxJointEdge"}schema(){return{properties:{invert:{type:"boolean",metadata:{default:!1,title:"Invert",description:"Swap settings for receiving side"}},width1:{type:"float64",metadata:{default:6,title:"Width 1",description:"Width of finger 1 (units)"}},length1:{type:"float64",metadata:{default:1,title:"Length 1",description:"Length of finger 1 (multiples of material thickness)"}},width2:{type:"float64",metadata:{default:6,title:"Width 2",description:"Width of finger 2 (units)"}},length2:{type:"float64",metadata:{default:1,title:"Length 2",description:"Length of finger 2 (multiples of material thickness)"}},play:{type:"float64",metadata:{default:0,title:"Play",description:"Extra space around fingers (units)"}},cornerDistance:{type:"float64",metadata:{default:12,title:"Corner Distance",description:"Reserved space near corners to exclude fingers (units)"}},centerDistance:{type:"float64",metadata:{default:0,title:"Center Distance",description:"Reserved space near center to exclude fingers (units)"}}},metadata:{order:["invert","width1","length1","width2","length2","play","cornerDistance","centerDistance"]}}}thickness(t,e,{thickness:r},{length1:n,length2:s,invert:o}){return(e!==o?-s:n)*r}draw(t,e,r,{thickness:n},{width1:s,length1:o,width2:a,length2:i,invert:d,play:c,cornerDistance:l,centerDistance:h}){const f=t.border,u=r!==d,m=(u?i:o)*n,p=u?s+c:s-c,g=u?a-c:a+c,w=u?-90:90,b=()=>f.turn(-w).forward(m).turn(w).forward(p).turn(w).forward(m).turn(-w),x=t=>{b();for(let e=0;e<t;e++)f.forward(g),b()},k=e-2*l;if(h>0){const t=(k-h)/2,e=Math.floor((t-s)/(s+a)),r=s+e*(s+a);f.forward(l+(t-r)/2),x(e),f.forward(h+t-r),x(e),f.forward(l+(t-r)/2)}else{const t=Math.floor((k-s)/(s+a)),e=s+t*(s+a);f.forward(l+(k-e)/2),x(t),f.forward(l+(k-e)/2)}}}class u extends l{name(){return"MortiseAndTenonEdge"}schema(){return{properties:{invert:{type:"boolean",metadata:{default:!1,title:"Invert",description:"Swap settings for receiving side"}},width1:{type:"float64",metadata:{default:6,title:"Width 1",description:"Width of tenon (units)"}},tenonLength:{type:"float64",metadata:{default:1,title:"Tenon Length",description:"Length of tenon (multiples of material thickness)"}},width2:{type:"float64",metadata:{default:6,title:"Width 2",description:"Width between tenons (units)"}},holeDistance:{type:"float64",metadata:{default:3,title:"Hole Distance",description:"Distance of mortises from edge (units)"}},play:{type:"float64",metadata:{default:0,title:"Play",description:"Extra space between mortise and tenons (units)"}},thicknessPlay:{type:"float64",metadata:{default:0,title:"Thickness Play",description:"Extra thickness added to mortise holes (units)"}},cornerDistance:{type:"float64",metadata:{default:12,title:"Corner Distance",description:"Reserved space near corners to exclude joints (units)"}},centerDistance:{type:"float64",metadata:{default:0,title:"Center Distance",description:"Reserved space near center to exclude joints (units)"}}},metadata:{order:["invert","width1","tenonLength","width2","holeDistance","play","thicknessPlay","cornerDistance","centerDistance"]}}}thickness(t,e,{thickness:r},{tenonLength:n,invert:s}){return e!==s?0:n*r}draw(t,e,r,{thickness:n},{width1:s,tenonLength:i,width2:d,holeDistance:c,invert:l,play:h,thicknessPlay:f,cornerDistance:u,centerDistance:m}){const p=r!==l,g=p?s+h:s-h,w=p?d-h:d+h;let b=t=>{},x=()=>{},k=()=>{};const v=t=>{x();for(let e=0;e<t;e++)k(),x()};if(p){const r=n+2*f,s=o(t.border.cursor()),i=t.border.angle;a(s,i+90,c+r-f),t.border.forward(e),b=t=>{a(s,i,t)},x=()=>{t.hole(o(s),i).forward(g).turn(-90).forward(r).turn(-90).forward(g).turn(-90).forward(r).turn(-90),b(g)},k=()=>b(w)}else{const e=i*n,r=90;b=e=>t.border.forward(e),x=()=>t.border.turn(-r).forward(e).turn(r).forward(g).turn(r).forward(e).turn(-r),k=()=>t.border.forward(w)}const y=e-2*u;if(m>0){const t=(y-m)/2,e=Math.floor((t-s)/(s+d)),r=s+e*(s+d);b(u+(t-r)/2),v(e),b(m+t-r),v(e),b(u+(t-r)/2)}else{const t=Math.floor((y-s)/(s+d)),e=s+t*(s+d);b(u+(y-e)/2),v(t),b(u+(y-e)/2)}}}const m=[new h,new f,new u];function p(t={}){return{discriminator:"kind",mapping:m.map((t=>({[t.name()]:{properties:{kind:{type:"string",metadata:{default:t.name(),title:t.name()}},params:t.schema()},metadata:{order:["params"],untabParams:!0}}}))).reduce(((t,e)=>({...t,...e})),{}),metadata:{default:m[0].name(),order:m.map((t=>t.name())),...t}}}class g extends t{name(){return"PlainRectangle"}schema(){return{properties:{width:{type:"float64",metadata:{default:100,title:"Outer Width (units)"}},height:{type:"float64",metadata:{default:100,title:"Outer Height (units)"}},edge1:p({title:"Top"}),edge2:p({title:"Right"}),edge3:p({title:"Bottom"}),edge4:p({title:"Left"})},metadata:{order:["width","height","edge1","edge2","edge3","edge4"]}}}generate(t,{width:e,height:r,edge1:n,edge2:s,edge3:o,edge4:a}){const{thickness:i}=t,d=new c,l=m.find((t=>t.name()===n.kind));if(!l)throw new Error("Bad top edge");const h=m.find((t=>t.name()===s.kind));if(!h)throw new Error("Bad right edge");const f=m.find((t=>t.name()===o.kind));if(!f)throw new Error("Bad bottom edge");const u=m.find((t=>t.name()===a.kind));if(!u)throw new Error("Bad left edge");const p=l.thickness(e,!1,t,n.params),g=h.thickness(r,!1,t,s.params),w=f.thickness(e,!1,t,o.params),b=u.thickness(r,!1,t,a.params);return e-=Math.abs(g)+Math.abs(b),r-=Math.abs(p)+Math.abs(w),b<0&&d.border.forward(-b),l.draw(d,e,!1,t,n.params),g<0&&d.border.forward(-g),d.border.turn(90),p<0&&d.border.forward(-p),h.draw(d,r,!1,t,s.params),w<0&&d.border.forward(-w),d.border.turn(90),g<0&&d.border.forward(-g),f.draw(d,e,!1,t,o.params),b<0&&d.border.forward(-b),d.border.turn(90),w<0&&d.border.forward(-w),u.draw(d,r,!1,t,a.params),p<0&&d.border.forward(-p),d.border.turn(90),[d.build(i)]}}const w=[new g];class b{constructor(t){}}class x extends b{constructor(t){super(t),this.surfaces=[],this.settings=t}addSurface(t,e,r,n,s){this.surfaces.push({offset:t,surface:e,cutColor:r,holeColor:n,scoreColor:s})}toFile(){const{kerf:t,units:e}=this.settings,r=[[0,0],[0,0]];for(const{offset:e,surface:n}of this.surfaces){const s=n.borderBoundingBox();r[0][0]=Math.min(r[0][0],e[0]+s[0][0]-t-10),r[0][1]=Math.min(r[0][1],e[1]+s[0][1]-t-10),r[1][0]=Math.max(r[1][0],e[0]+s[1][0]+t+10),r[1][1]=Math.max(r[1][1],e[1]+s[1][1]+t+10)}const n=[],s=t=>""+Math.round(1e3*t)/1e3;let o=0;const a=()=>{n.push(`<g id="p-${o++}" style="fill:none;stroke-linecap:round;stroke-linejoin:round;">`)},i=()=>{n.push("</g>")},d=(e,r,o,a)=>{const i=[`M${s(e[0])} ${s(e[1])}`];for(const t of r)switch(t.kind){case"L":i.push(`L${s(e[0]+t.to[0])} ${s(e[1]+t.to[1])}`);break;case"C":i.push(`C${s(e[0]+t.c1[0])} ${s(e[1]+t.c1[1])}`,` ${s(e[0]+t.c2[0])} ${s(e[1]+t.c2[1])}`,` ${s(e[0]+t.to[0])} ${s(e[1]+t.to[1])}`)}o&&i.push("Z"),n.push(`<path stroke="${a}" stroke-width="${t}" d="${i.join("")}" />`)};for(const{offset:t,surface:e,cutColor:r,holeColor:n,scoreColor:s}of this.surfaces){if((e.scores.length>0||e.holes.length>0)&&a(),e.scores.length>0){a();for(const r of e.scores)d([t[0]+r.offset[0],t[1]+r.offset[1]],r.commands,!1,s);i()}a(),d(t,e.border,!0,r);for(const n of e.cuts)d([t[0]+n.offset[0],t[1]+n.offset[1]],n.commands,!1,r);if(i(),e.holes.length>0){a();for(const r of e.holes)d([t[0]+r.offset[0],t[1]+r.offset[1]],r.commands,!0,n);i()}(e.scores.length>0||e.holes.length>0)&&i()}const c=r[1][0]-r[0][0],l=r[1][1]-r[0][1];return{mimeType:"image/svg+xml",extension:".svg",data:(new TextEncoder).encode(`<?xml version='1.0' encoding='utf-8'?>\n<svg\n  width="${s(c)}${e}"\n  height="${s(l)}${e}"\n  viewBox="${s(r[0][0])} ${s(r[0][1])} ${s(c)} ${s(l)}"\n  xmlns="http://www.w3.org/2000/svg">\n\x3c!--\nGenerated by boxburner\nby Sean Connelly (@velipso), https://sean.fun\nProject Home: https://github.com/velipso/boxburner\nSPDX-License-Identifier: 0BSD\n--\x3e\n${n.join("")}\n</svg>`)}}}exports.BoxJointEdge=f,exports.DocumentBase=b,exports.DocumentSVG=x,exports.DrawBuilder=d,exports.EdgeBase=l,exports.GeneratorBase=t,exports.MortiseAndTenonEdge=u,exports.PlainEdge=h,exports.PlainRectangle=g,exports.SettingsTypeDef={properties:{thickness:{type:"float64",metadata:{default:3,title:"Material Thickness (units)"}},kerf:{type:"float64",metadata:{default:.1,title:"Kerf",description:"Thickness of material removed by cutting tool (units)"}},units:{enum:["mm","in"],metadata:{default:"mm",title:"Units"}},fileFormat:{enum:["svg"],metadata:{default:"svg",title:"File Format"}},debug:{type:"boolean",metadata:{default:!1,title:"Debug"}}},metadata:{title:"Settings",order:["thickness","kerf","units","fileFormat","debug"],startHidden:!0}},exports.Surface=s,exports.SurfaceBuilder=c,exports.allEdges=m,exports.allEdgesTypeDef=p,exports.allGenerators=w,exports.copyVec2=o,exports.exportDocument=function(t){if("svg"===t.fileFormat)return new x(t);throw new Error(`Unknown export file format: ${t.fileFormat}`)},exports.forwardVec2=a;
