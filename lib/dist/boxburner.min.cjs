"use strict";class t{}function e(t,e){if(e.length<=0)throw new Error(`${t}: Cannot have empty list of commands for closed path`);const n=e[e.length-1].to;if(0!==n[0]||0!==n[1])throw new Error(`${t}: Closed path must end on [0, 0]`)}function n(t){let e=0;for(let n=0;n<t.length;n++){const a=t[n].to,i=t[(n+1)%t.length].to;e+=(i[0]-a[0])*(i[1]+a[1])}return e<0}function a(t,e,n,a){const i=(i,o)=>t[i]*(1-o)*(1-o)*(1-o)+3*e[i]*o*(1-o)*(1-o)+3*n[i]*o*o*(1-o)+a[i]*o*o*o,o=o=>{const s=3*a[o]-9*n[o]+9*e[o]-3*t[o],r=6*t[o]-12*e[o]+6*n[o],l=3*e[o]-3*t[o];let h=Math.min(t[o],a[o]),d=Math.max(t[o],a[o]);if(Math.abs(s)<=1e-8){const t=-l/r;if(t>0&&t<1){const e=i(o,t);h=Math.min(h,e),d=Math.max(d,e)}}else{const t=r*r-4*s*l;if(t>=0){const e=Math.sqrt(t),n=(-r+e)/(2*s);if(n>0&&n<1){const t=i(o,n);h=Math.min(h,t),d=Math.max(d,t)}const a=(-r-e)/(2*s);if(a>0&&a<1){const t=i(o,a);h=Math.min(h,t),d=Math.max(d,t)}}}return[h,d]},s=o(0),r=o(1);return[[s[0],r[0]],[s[1],r[1]]]}class i{constructor(t,a,i=[],o=[],s=[]){if(e("Surface border",a),!n(a))throw new Error("Surface border: Points must be in counter-clockwise order for border");for(let t=0;t<i.length;t++){const a=`Surface hole ${t}`;if(e(a,i[t]),n(i[t]))throw new Error(`${a}: Points must be in clockwise order for holes`)}this.thickness=t,this.border=a,this.holes=i,this.cuts=o,this.text=s}borderBoundingBox(){return function(t){let e=[0,0],n=[0,0],i=[0,0];for(const o of t){switch(o.kind){case"L":e[0]=Math.min(e[0],o.to[0]),e[1]=Math.min(e[1],o.to[1]),n[0]=Math.max(n[0],o.to[0]),n[1]=Math.max(n[1],o.to[1]);break;case"C":{const t=a(i,o.c1,o.c2,o.to);e[0]=Math.min(e[0],t[0][0]),e[1]=Math.min(e[1],t[0][1]),n[0]=Math.max(n[0],t[1][0]),n[1]=Math.max(n[1],t[1][1]);break}}i=o.to}return[e,n]}(this.border)}}class o{constructor(){this.commands=[],this.angle=0}cursor(){return this.commands.length<=0?[0,0]:this.commands[this.commands.length-1].to}lineTo(t){return this.commands.push({kind:"L",to:t}),this}lineToRelative(t){const e=this.cursor();return this.lineTo([e[0]+t[0],e[1]+t[1]])}quadCurveTo(t,e){const n=this.cursor();return this.curveTo([n[0]+2*(t[0]-n[0])/3,n[1]+2*(t[1]-n[1])/3],[e[0]+2*(t[0]-e[0])/3,e[1]+2*(t[1]-e[1])/3],e)}curveTo(t,e,n){return this.commands.push({kind:"C",c1:t,c2:e,to:n}),this}forward(t,e=0){this.angle+=t;const n=this.angle*Math.PI/180;return 0!==e&&this.lineToRelative([e*Math.sin(n),e*Math.cos(n)]),this}close(){const t=this.cursor();return 0===t[0]&&0===t[1]||this.lineTo([0,0]),this}build(){return this.commands}}class s extends t{name(){return"PlainBox"}defaultParams(){return{thickness:3,edges:[{kind:"boxJoint",length:100,angle:90,surroundingSpaces:2,edgeWidth:1,extraLength:0,finger:2,play:0,space:2,width:1},{kind:"plain",length:50},{kind:"boxJoint",length:100,angle:90,surroundingSpaces:2,edgeWidth:1,extraLength:0,finger:2,play:0,space:2,width:1},{kind:"plain",length:50}]}}schema(){return{properties:{thickness:{type:"float64",metadata:{default:3,title:"Thickness"}},edges:{elements:{discriminator:"kind",mapping:{plain:{properties:{kind:{type:"string",metadata:{default:"plain",title:"Plain"}},length:{type:"float64",metadata:{default:100,title:"Length"}}},metadata:{title:"Plain",order:["length"]}},boxJoint:{properties:{kind:{type:"string",metadata:{default:"boxJoint",title:"Box Joint"}},length:{type:"float64",metadata:{default:100,title:"Length"}},angle:{type:"float64",metadata:{default:90,title:"Angle"}},surroundingSpaces:{type:"float64",metadata:{default:2,title:"Surrounding Space",description:"Minimal space at the start and end in multiple of normal spaces"}},edgeWidth:{type:"float64",metadata:{default:1,title:"Edge Width",description:"Space below holes (multiples of thickness)"}},extraLength:{type:"float64",metadata:{default:0,title:"Extra Length",description:"Extra material on finger (multiples of thickness)"}},finger:{type:"float64",metadata:{default:2,title:"Finger",description:"Width of the fingers (multiples of thickness)"}},play:{type:"float64",metadata:{default:0,title:"Play",description:"Extra space to allow finger move in and out (multiples of thickness)"}},space:{type:"float64",metadata:{default:2,title:"Space",description:"Space between fingers (multiples of thickness)"}},width:{type:"float64",metadata:{default:1,title:"Width",description:"Width of finger holes (multiples of thickness)"}}},metadata:{title:"Box Joint",order:["length","angle","surroundingSpaces","edgeWidth","extraLength","finger","play","space","width"]}}},metadata:{default:"plain",order:["plain","boxJoint"]}},metadata:{default:4,title:"Edges",itemTitle:"Edge {}"}}},metadata:{order:["thickness","edges"]}}}generate({thickness:t,edges:e}){if(e.length<3)throw new Error("Need at least 3 edges");const n=new o,a=-360/e.length;for(const t of e){switch(t.kind){case"plain":case"boxJoint":n.forward(0,t.length)}n.forward(a,0)}return[new i(t,n.close().build())]}}exports.DrawBuilder=o,exports.GeneratorBase=t,exports.PlainBox=s,exports.Surface=i,exports.test=function(){const t=new s;console.log(t.schema()),console.log(t.generate({thickness:3,width:50,height:30}))};
