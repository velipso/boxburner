"use strict";class t{}function e(t,e){if(e.length<=0)throw new Error(`${t}: Cannot have empty list of commands for closed path`);const n=e[e.length-1].to;if(0!==n[0]||0!==n[1])throw new Error(`${t}: Closed path must end on [0, 0]`)}function n(t){let e=0;for(let n=0;n<t.length;n++){const a=t[n].to,r=t[(n+1)%t.length].to;e+=(r[0]-a[0])*(r[1]+a[1])}return e<0}function a(t,e,n,a){const r=(r,s)=>t[r]*(1-s)*(1-s)*(1-s)+3*e[r]*s*(1-s)*(1-s)+3*n[r]*s*s*(1-s)+a[r]*s*s*s,s=s=>{const o=3*a[s]-9*n[s]+9*e[s]-3*t[s],i=6*t[s]-12*e[s]+6*n[s],l=3*e[s]-3*t[s];let d=Math.min(t[s],a[s]),h=Math.max(t[s],a[s]);if(Math.abs(o)<=1e-8){const t=-l/i;if(t>0&&t<1){const e=r(s,t);d=Math.min(d,e),h=Math.max(h,e)}}else{const t=i*i-4*o*l;if(t>=0){const e=Math.sqrt(t),n=(-i+e)/(2*o);if(n>0&&n<1){const t=r(s,n);d=Math.min(d,t),h=Math.max(h,t)}const a=(-i-e)/(2*o);if(a>0&&a<1){const t=r(s,a);d=Math.min(d,t),h=Math.max(h,t)}}}return[d,h]},o=s(0),i=s(1);return[[o[0],i[0]],[o[1],i[1]]]}class r{constructor({defaultThickness:t,defaultKerf:a},r,s=[],o=[],i=[],l=[]){if(this.thicknessValue=null,this.kerfValue=null,e("Surface border",r),!n(r))throw new Error("Surface border: Points must be in counter-clockwise order for border");for(let t=0;t<s.length;t++){const a=`Surface hole ${t}`;if(e(a,s[t].commands),n(s[t].commands))throw new Error(`${a}: Points must be in clockwise order for holes`)}this.defaultThickness=t,this.defaultKerf=a,this.border=r,this.holes=s,this.cuts=o,this.scores=i,this.text=l}setThickness(t){this.thicknessValue=t}setKerf(t){this.kerfValue=t}thickness(){return"number"==typeof this.thicknessValue?this.thicknessValue:this.defaultThickness}kerf(){return"number"==typeof this.kerfValue?this.kerfValue:this.defaultKerf}borderBoundingBox(){return function(t){const e=[0,0],n=[0,0];let r=[0,0];for(const s of t){switch(s.kind){case"L":e[0]=Math.min(e[0],s.to[0]),e[1]=Math.min(e[1],s.to[1]),n[0]=Math.max(n[0],s.to[0]),n[1]=Math.max(n[1],s.to[1]);break;case"C":{const t=a(r,s.c1,s.c2,s.to);e[0]=Math.min(e[0],t[0][0]),e[1]=Math.min(e[1],t[0][1]),n[0]=Math.max(n[0],t[1][0]),n[1]=Math.max(n[1],t[1][1]);break}}r=s.to}return[e,n]}(this.border)}}var s;exports.AlongIntersection=void 0,(s=exports.AlongIntersection||(exports.AlongIntersection={}))[s.BeforeStart=0]="BeforeStart",s[s.EqualStart=1]="EqualStart",s[s.BetweenStartAndEnd=2]="BetweenStartAndEnd",s[s.EqualEnd=3]="EqualEnd",s[s.AfterEnd=4]="AfterEnd";const o=1e-7;function i(t){return[t[0],t[1]]}function l(t,e,n){return e=(e%360+360)%360,0!==n&&(0===e?t[0]+=n:90===e?t[1]+=n:180===e?t[0]-=n:270===e?t[1]-=n:(t[0]+=n*Math.cos(e*Math.PI/180),t[1]+=n*Math.sin(e*Math.PI/180))),t}function d(t,e,n,a){const r=e[0]-t[0],s=e[1]-t[1],i=a[0]-n[0],l=a[1]-n[1],d=r*l-s*i;if(Math.abs(d)<o)return null;const h=t[0]-n[0],c=t[1]-n[1],f=(i*c-l*h)/d,u=(r*c-s*h)/d,m=t=>t<=-o?exports.AlongIntersection.BeforeStart:t<o?exports.AlongIntersection.EqualStart:t-1<=-o?exports.AlongIntersection.BetweenStartAndEnd:t-1<o?exports.AlongIntersection.EqualEnd:exports.AlongIntersection.AfterEnd,g=[t[0]+f*r,t[1]+f*s];return{alongA:m(f),alongB:m(u),p:g}}function h(t,e,n){if(n<=0)return{offset:t,commands:e};const a=n/2,r=i(t),s=[],o=t=>{const n=e[t],r=e[0===t?e.length-1:t-1],s=Math.atan2(r.to[1]-n.to[1],r.to[0]-n.to[0]),o=s+Math.PI/2;return{angle:s,offset:[a*Math.cos(o),a*Math.sin(o)]}},l=[];for(let t=0;t<e.length;t++){const n=e[t],r=e[(t+e.length-1)%e.length],{angle:i,offset:[d,h]}=o(t);switch(n.kind){case"L":{const{angle:c,offset:[f,u]}=o((t+e.length-1)%e.length),m=Math.min(Math.abs(i-c),Math.abs(i+2*Math.PI-c),Math.abs(i-(c+2*Math.PI))),g=4*a*Math.tan(m/4)/3;l.push(s.length),s.push({kind:"C",c1:[r.to[0]+f-g*Math.cos(c),r.to[1]+u-g*Math.sin(c)],c2:[r.to[0]+d+g*Math.cos(i),r.to[1]+h+g*Math.sin(i)],to:[r.to[0]+d,r.to[1]+h]}),s.push({kind:"L",to:[n.to[0]+d,n.to[1]+h]});break}case"C":s.push({kind:"C",c1:[n.c1[0]+d,n.c1[1]+h],c2:[n.c2[0]+d,n.c2[1]+h],to:[n.to[0]+d,n.to[1]+h]})}}for(const t of l){const e=s[(t+s.length-2)%s.length],n=s[(t+s.length-1)%s.length],a=s[t],r=s[(t+1)%s.length];if("L"===n.kind&&"C"===a.kind&&"L"===r.kind){const t=d(e.to,n.to,a.to,r.to);t&&t.alongA===exports.AlongIntersection.BetweenStartAndEnd&&t.alongB===exports.AlongIntersection.BetweenStartAndEnd&&(a.c1=n.to,a.c2=a.to,n.to=i(t.p),a.to=i(t.p))}}const[h,c]=s[s.length-1].to;r[0]+=h,r[1]+=c;for(const t of s)switch(t.kind){case"L":t.to[0]-=h,t.to[1]-=c;break;case"C":t.c1[0]-=h,t.c1[1]-=c,t.c2[0]-=h,t.c2[1]-=c,t.to[0]-=h,t.to[1]-=c}return{offset:r,commands:s}}class c{constructor(){this.commands=[],this.angle=0}cursor(){return this.commands.length<=0?[0,0]:this.commands[this.commands.length-1].to}lineTo(t){var e,n;const a=this.commands[this.commands.length-1];if(a&&"L"===a.kind){const r=null!==(n=null===(e=this.commands[this.commands.length-2])||void 0===e?void 0:e.to)&&void 0!==n?n:[0,0],s=a.to,i=t;if(Math.abs(r[0]-i[0])<o&&Math.abs(r[1]-i[1])<o)return this.commands.pop(),this;const l=r[0]-s[0],d=r[1]-s[1],h=s[0]-i[0],c=s[1]-i[1];if(Math.abs(l*c-h*d)<o)return a.to=t,this}return this.commands.push({kind:"L",to:t}),this}lineToRelative(t){const e=this.cursor();return this.lineTo([e[0]+t[0],e[1]+t[1]])}quadCurveTo(t,e){const n=this.cursor();return this.curveTo([n[0]+2*(t[0]-n[0])/3,n[1]+2*(t[1]-n[1])/3],[e[0]+2*(t[0]-e[0])/3,e[1]+2*(t[1]-e[1])/3],e)}curveTo(t,e,n){return this.commands.push({kind:"C",c1:t,c2:e,to:n}),this}turn(t){return this.angle=((this.angle+t)%360+360)%360,this}forward(t){return 0!==t&&this.lineToRelative(l([0,0],this.angle,t)),this}close(){var t,e;this.lineTo([0,0]);const n=this.commands[0],a=this.commands[this.commands.length-1];if("L"===(null==a?void 0:a.kind)&&"L"===(null==n?void 0:n.kind)){const r=null!==(e=null===(t=this.commands[this.commands.length-2])||void 0===t?void 0:t.to)&&void 0!==e?e:[0,0],s=a.to,i=n.to,l=r[0]-s[0],d=r[1]-s[1],h=s[0]-i[0],c=s[1]-i[1];if(Math.abs(r[0]-i[0])<o&&Math.abs(r[1]-i[1])<o)this.commands.shift();else if(Math.abs(l*c-h*d)>=o)return this;this.commands.pop();for(const t of this.commands)t.to[0]-=r[0],t.to[1]-=r[1],"C"===t.kind&&(t.c1[0]-=r[0],t.c1[1]-=r[1],t.c2[0]-=r[0],t.c2[1]-=r[1])}return this}build(){return this.commands}}const f={" ":0,"!":74240,'"':516,"#":43580,$:43707,"%":61081,"&":37745,"'":512,"(":5120,")":16640,"*":65280,"+":43520,",":16384,"-":34816,".":65536,"/":17408,0:17663,1:1036,2:34935,3:2111,4:34956,5:35003,6:35067,7:15,8:35071,9:35007,":":8704,";":16896,"<":37888,"=":34864,">":18688,"?":75783,"@":2807,A:35023,B:10815,C:243,D:8767,E:33011,F:32963,G:2299,H:35020,I:8755,J:124,K:38080,L:240,M:1484,N:4556,O:255,P:35015,Q:4351,R:39111,S:35003,T:8707,U:252,V:17600,W:20684,X:21760,Y:35004,Z:17459,"[":8722,"\\":4352,"]":8737,"^":20480,_:48,"`":256,"{":41490,"|":8704,"}":10785,"~":52224};class u{constructor(){this.border=new c,this.holes=[],this.cuts=[],this.scores=[],this.text=[]}hole(t,e=0){const n=new c;return n.turn(e),this.holes.push({offset:t,db:n}),n}cut(t,e=0){const n=new c;return n.turn(e),this.cuts.push({offset:t,db:n}),n}score(t,e=0){const n=new c;return n.turn(e),this.scores.push({offset:t,db:n}),n}scoreChar(t,e,n,a){var r;const s=null!==(r=f[a.toUpperCase()])&&void 0!==r?r:f["?"],o=(a,r,s,o)=>{const l=i(t);l[0]+=a*e,l[1]+=r*n,this.score(l).lineToRelative([(s-a)*e,(o-r)*n])},l=.025;return 1&s&&o(l,0,.475,0),2&s&&o(.525,0,.975,0),4&s&&o(1,l,1,.475),8&s&&o(1,.525,1,.975),16&s&&o(.975,1,.525,1),32&s&&o(.475,1,l,1),64&s&&o(0,.975,0,.525),128&s&&o(0,.475,0,l),256&s&&o(l,l,.475,.475),512&s&&o(.5,l,.5,.475),1024&s&&o(.975,l,.525,.475),2048&s&&o(.525,.5,.975,.5),4096&s&&o(.525,.525,.975,.975),8192&s&&o(.5,.525,.5,65536&s?.775:.975),16384&s&&o(.475,.525,l,.975),32768&s&&o(.475,.5,l,.5),65536&s&&o(.5,.8+l,.5,.975),this}build(t){return new r(t,this.border.close().build(),this.holes.map((({offset:t,db:e})=>({offset:t,commands:e.close().build()}))),this.cuts.map((({offset:t,db:e})=>({offset:t,commands:e.build()}))),this.scores.map((({offset:t,db:e})=>({offset:t,commands:e.build()}))),this.text)}}class m{}class g extends m{name(){return"ButtJoint"}schema(){return{properties:{invert:{type:"boolean",metadata:{default:!1,title:"Invert",description:"Swap settings for receiving side"}},length1:{type:"float64",metadata:{default:0,title:"Length 1",description:"Length of butt 1 (multiples of material thickness)"}},length2:{type:"float64",metadata:{default:1,title:"Length 2",description:"Length of butt 2 (multiples of material thickness)"}}},metadata:{order:["invert","length1","length2"]}}}thickness(t,e,n,{length1:a,length2:r,invert:s}){return(e!==s?-r:a)*n}draw(t,e,n,a,{invert:r,length1:s,length2:o}){const i=n!==r,l=(i?o:s)*a,d=i?-90:90;t.border.turn(-d).forward(l).turn(d).forward(e).turn(d).forward(l).turn(-d)}}class p extends m{name(){return"BoxJoint"}schema(){return{properties:{invert:{type:"boolean",metadata:{default:!1,title:"Invert",description:"Swap settings for receiving side"}},width1:{type:"float64",metadata:{default:6,title:"Width 1",description:"Width of finger 1 (units)"}},length1:{type:"float64",metadata:{default:1,title:"Length 1",description:"Length of finger 1 (multiples of material thickness)"}},width2:{type:"float64",metadata:{default:6,title:"Width 2",description:"Width of finger 2 (units)"}},length2:{type:"float64",metadata:{default:1,title:"Length 2",description:"Length of finger 2 (multiples of material thickness)"}},play:{type:"float64",metadata:{default:0,title:"Play",description:"Extra space around fingers (units)"}},cornerDistance:{type:"float64",metadata:{default:12,title:"Corner Distance",description:"Reserved space near corners to exclude fingers (units)"}},centerDistance:{type:"float64",metadata:{default:0,title:"Center Distance",description:"Reserved space near center to exclude fingers (units)"}}},metadata:{order:["invert","width1","length1","width2","length2","play","cornerDistance","centerDistance"]}}}thickness(t,e,n,{length1:a,length2:r,invert:s}){return(e!==s?-r:a)*n}draw(t,e,n,a,{invert:r,width1:s,length1:o,width2:i,length2:l,play:d,cornerDistance:h,centerDistance:c}){const f=t.border,u=n!==r,m=(u?l:o)*a,g=u?-d:d,p=u?-90:90,w=()=>f.forward(g/2).turn(-p).forward(m).turn(p).forward(s-g).turn(p).forward(m).turn(-p).forward(g/2),b=t=>{w();for(let e=0;e<t;e++)f.forward(i),w()},k=e-2*h;if(c>0){const t=(k-c)/2,e=Math.floor((t-s)/(s+i)),n=s+e*(s+i);f.forward(h+(t-n)/2),b(e),f.forward(c+t-n),b(e),f.forward(h+(t-n)/2)}else{const t=Math.floor((k-s)/(s+i)),e=s+t*(s+i);f.forward(h+(k-e)/2),b(t),f.forward(h+(k-e)/2)}}}class w extends m{name(){return"MortiseAndTenonJoint"}schema(){return{properties:{invert:{type:"boolean",metadata:{default:!1,title:"Invert",description:"Swap settings for receiving side"}},width1:{type:"float64",metadata:{default:6,title:"Width 1",description:"Width of tenon (units)"}},tenonLength:{type:"float64",metadata:{default:1,title:"Tenon Length",description:"Length of tenon (multiples of material thickness)"}},width2:{type:"float64",metadata:{default:6,title:"Width 2",description:"Width between tenons (units)"}},holeDistance:{type:"float64",metadata:{default:3,title:"Hole Distance",description:"Distance of mortises from edge (units)"}},play:{type:"float64",metadata:{default:0,title:"Play",description:"Extra space between mortise and tenons (units)"}},thicknessPlay:{type:"float64",metadata:{default:0,title:"Thickness Play",description:"Extra thickness added to mortise holes (units)"}},cornerDistance:{type:"float64",metadata:{default:12,title:"Corner Distance",description:"Reserved space near corners to exclude joints (units)"}},centerDistance:{type:"float64",metadata:{default:0,title:"Center Distance",description:"Reserved space near center to exclude joints (units)"}}},metadata:{order:["invert","width1","tenonLength","width2","holeDistance","play","thicknessPlay","cornerDistance","centerDistance"]}}}thickness(t,e,n,{tenonLength:a,invert:r}){return e!==r?0:a*n}draw(t,e,n,a,{invert:r,width1:s,tenonLength:o,width2:d,holeDistance:h,play:c,thicknessPlay:f,cornerDistance:u,centerDistance:m}){const g=n!==r,p=g?-c:c;let w=t=>{},b=()=>{},k=()=>{};const y=t=>{b();for(let e=0;e<t;e++)k(),b()};if(g){const n=a+2*f,r=i(t.border.cursor()),o=t.border.angle;l(r,o+90,h+n-f),t.border.forward(e),w=t=>{l(r,o,t)},b=()=>{w(p/2),t.hole(i(r),o).forward(s-p).turn(-90).forward(n).turn(-90).forward(s-p).turn(-90).forward(n).turn(-90),w(-p/2),w(s)},k=()=>{w(d)}}else{const e=o*a,n=90;w=e=>t.border.forward(e),b=()=>t.border.forward(p/2).turn(-n).forward(e).turn(n).forward(s-p).turn(n).forward(e).turn(-n).forward(p/2),k=()=>t.border.forward(d)}const x=e-2*u;if(m>0){const t=(x-m)/2,e=Math.floor((t-s)/(s+d)),n=s+e*(s+d);w(u+(t-n)/2),y(e),w(m+t-n),y(e),w(u+(t-n)/2)}else{const t=Math.floor((x-s)/(s+d)),e=s+t*(s+d);w(u+(x-e)/2),y(t),w(u+(x-e)/2)}}}const b=[new g,new p,new w];function k(t={}){return{discriminator:"kind",mapping:b.map((t=>({[t.name()]:{properties:{kind:{type:"string",metadata:{default:t.name(),title:t.name()}},params:t.schema()},metadata:{order:["params"],untabParams:!0}}}))).reduce(((t,e)=>({...t,...e})),{}),metadata:{default:b[0].name(),order:b.map((t=>t.name())),...t}}}class y extends t{name(){return"Rectangle"}schema(){return{properties:{label:{type:"string",nullable:!0,metadata:{default:null,defaultNotNull:"",nullHint:"none",title:"Label"}},labelFontSize:{type:"float64",nullable:!0,metadata:{default:null,defaultNotNull:10,nullHint:"auto",title:"Label Font Size (units)"}},thickness:{type:"float64",nullable:!0,metadata:{default:null,defaultNotNull:3,nullHint:"default",title:"Material Thickness (units)"}},kerf:{type:"float64",nullable:!0,metadata:{default:null,defaultNotNull:.1,nullHint:"default",title:"Kerf (units)",description:"Thickness of material removed by cutting tool"}},width:{type:"float64",metadata:{default:100,title:"Outer Width (units)"}},height:{type:"float64",metadata:{default:100,title:"Outer Height (units)"}},edge1:k({title:"Top"}),edge2:k({title:"Right"}),edge3:k({title:"Bottom"}),edge4:k({title:"Left"})},metadata:{order:["label","labelFontSize","thickness","kerf","width","height","edge1","edge2","edge3","edge4"]}}}generate(t,{label:e,labelFontSize:n,thickness:a,kerf:r,width:s,height:o,edge1:i,edge2:l,edge3:d,edge4:h}){const c=new u,f=b.find((t=>t.name()===i.kind));if(!f)throw new Error("Bad top edge");const m=b.find((t=>t.name()===l.kind));if(!m)throw new Error("Bad right edge");const g=b.find((t=>t.name()===d.kind));if(!g)throw new Error("Bad bottom edge");const p=b.find((t=>t.name()===h.kind));if(!p)throw new Error("Bad left edge");const w="number"==typeof a?a:t.defaultThickness,k=f.thickness(s,!1,w,i.params),y=m.thickness(o,!1,w,l.params),x=g.thickness(s,!1,w,d.params),v=p.thickness(o,!1,w,h.params);if(s-=Math.abs(y)+Math.abs(v),o-=Math.abs(k)+Math.abs(x),v<0&&c.border.forward(-v),f.draw(c,s,!1,w,i.params),y<0&&c.border.forward(-y),c.border.turn(90),k<0&&c.border.forward(-k),m.draw(c,o,!1,w,l.params),x<0&&c.border.forward(-x),c.border.turn(90),y<0&&c.border.forward(-y),g.draw(c,s,!1,w,d.params),v<0&&c.border.forward(-v),c.border.turn(90),x<0&&c.border.forward(-x),p.draw(c,o,!1,w,h.params),k<0&&c.border.forward(-k),c.border.turn(90),e){const t=e.trim().split("\n"),a=t.reduce(((t,e)=>Math.max(t,e.length)),0);let r=0;r="number"==typeof n?n:Math.min((s-5-Math.abs(y)-Math.abs(v))/a*2,(o-5-Math.abs(k)-Math.abs(x))/t.length);const i=r/2,l=(s-i*a)/2,d=(o-r*t.length)/2;for(let e=0;e<t.length;e++){const n=t[e];for(let t=0;t<n.length;t++)c.scoreChar([l+i*t+.15*i,d+r*e+.15*r],.7*i,.7*r,n.charAt(t))}}const M=c.build(t);return"number"==typeof a&&M.setThickness(a),"number"==typeof r&&M.setKerf(r),[M]}}class x extends t{name(){return"PlainBox"}schema(){return{properties:{labels:{type:"boolean",metadata:{default:!1,title:"Labels"}},width:{type:"float64",metadata:{default:100,title:"Outer Width (units)"}},depth:{type:"float64",metadata:{default:100,title:"Outer Depth (units)"}},height:{type:"float64",metadata:{default:100,title:"Outer Height (units)"}},holeDistance:{type:"float64",metadata:{default:3,title:"Hole Distance",description:"Distance of mortises from edge (units)"}},play:{type:"float64",metadata:{default:0,title:"Play",description:"Extra space between fingers (units)"}},thicknessPlay:{type:"float64",metadata:{default:0,title:"Thickness Play",description:"Extra thickness added to mortise holes (units)"}}},metadata:{order:["labels","width","depth","height","holeDistance","play","thicknessPlay"]}}}generate(t,{labels:e,width:n,depth:a,height:r,holeDistance:s,play:o,thicknessPlay:i}){const{defaultThickness:l}=t,d=new y,h=t=>({kind:"MortiseAndTenonJoint",params:{invert:t,width1:2*l,tenonLength:1,width2:2*l,holeDistance:s,play:o,thicknessPlay:i,cornerDistance:2*l,centerDistance:0}}),c=t=>({kind:"BoxJoint",params:{invert:t,width1:2*l,length1:1,width2:2*l,length2:1,play:o,cornerDistance:2*l,centerDistance:0}});return[...d.generate(t,{width:n,height:a,edge1:h(!1),edge2:h(!1),edge3:h(!1),edge4:h(!1),...e?{label:"Bottom"}:{}}),...d.generate(t,{width:a,height:r,edge1:{kind:"ButtJoint",params:{invert:!1,length1:0,length2:1}},edge2:c(!1),edge3:h(!0),edge4:c(!1),...e?{label:"Left"}:{}}),...d.generate(t,{width:a,height:r,edge1:{kind:"ButtJoint",params:{invert:!1,length1:0,length2:1}},edge2:c(!1),edge3:h(!0),edge4:c(!1),...e?{label:"Right"}:{}}),...d.generate(t,{width:n,height:r,edge1:{kind:"ButtJoint",params:{invert:!1,length1:0,length2:1}},edge2:c(!0),edge3:h(!0),edge4:c(!0),...e?{label:"Front"}:{}}),...d.generate(t,{width:n,height:r,edge1:{kind:"ButtJoint",params:{invert:!1,length1:0,length2:1}},edge2:c(!0),edge3:h(!0),edge4:c(!0),...e?{label:"Back"}:{}})]}}class v extends t{name(){return"KerfTester"}schema(){return{properties:{width:{type:"float64",metadata:{default:30,title:"Outer Width (units)"}},height:{type:"float64",metadata:{default:15,title:"Outer Height (units)"}},play:{type:"float64",metadata:{default:0,title:"Play",description:"Extra space between fingers (units)"}},testCount:{type:"int32",metadata:{default:8,title:"Number of tests"}},kerfStart:{type:"float64",metadata:{default:.08,title:"Kerf start value (units)"}},kerfIncrement:{type:"float64",metadata:{default:.02,title:"Kerf increment value (per test)"}}},metadata:{order:["width","height","testCount","kerfStart","kerfIncrement"]}}}generate(t,{width:e,height:n,play:a,testCount:r,kerfStart:s,kerfIncrement:o}){const{defaultThickness:i}=t,l=new y,d=t=>({kind:"BoxJoint",params:{invert:t,width1:2*i,length1:1,width2:2*i,length2:1,play:a,cornerDistance:2*i,centerDistance:0}}),h=[];for(let a=0;a<r;a++){const r=s+a*o;h.push(...l.generate(t,{width:e,height:n,kerf:r,label:r.toFixed(3),edge1:d(!1),edge2:{kind:"ButtJoint",params:{invert:!1,length1:0,length2:1}},edge3:{kind:"ButtJoint",params:{invert:!1,length1:0,length2:1}},edge4:{kind:"ButtJoint",params:{invert:!1,length1:0,length2:1}}}),...l.generate(t,{width:e,height:n,kerf:r,label:r.toFixed(3),edge1:{kind:"ButtJoint",params:{invert:!1,length1:0,length2:1}},edge2:{kind:"ButtJoint",params:{invert:!1,length1:0,length2:1}},edge3:d(!0),edge4:{kind:"ButtJoint",params:{invert:!1,length1:0,length2:1}}}))}return h}}const M=[new v,new x,new y];class B{constructor(t){}}class D extends B{constructor(t){super(t),this.surfaces=[],this.settings=t}addSurface(t,e,n,a,r){this.surfaces.push({offset:t,surface:e,cutColor:n,holeColor:a,scoreColor:r})}toFile(){const{units:t}=this.settings,e=[[0,0],[0,0]];for(const{offset:t,surface:n}of this.surfaces){const a=n.borderBoundingBox(),r=n.kerf();e[0][0]=Math.min(e[0][0],t[0]+a[0][0]-r-10),e[0][1]=Math.min(e[0][1],t[1]+a[0][1]-r-10),e[1][0]=Math.max(e[1][0],t[0]+a[1][0]+r+10),e[1][1]=Math.max(e[1][1],t[1]+a[1][1]+r+10)}const n=[],a=t=>""+Math.round(1e3*t)/1e3;let r=0;const s=()=>{n.push(`<g id="p-${r++}" style="fill:none;stroke-linecap:round;stroke-linejoin:round;">`)},o=()=>{n.push("</g>")},i=(t,e,r,s,o)=>{s&&t>0&&({offset:e,commands:r}=h(e,r,t));const i=[`M${a(e[0])} ${a(e[1])}`];for(const t of r)switch(t.kind){case"L":i.push(`L${a(e[0]+t.to[0])} ${a(e[1]+t.to[1])}`);break;case"C":i.push(`C${a(e[0]+t.c1[0])} ${a(e[1]+t.c1[1])}`,` ${a(e[0]+t.c2[0])} ${a(e[1]+t.c2[1])}`,` ${a(e[0]+t.to[0])} ${a(e[1]+t.to[1])}`)}s&&i.push("Z"),n.push(`<path stroke="${o}" stroke-width="${t<=0?.1:t}" d="${i.join("")}" />`)};for(const{offset:t,surface:e,cutColor:n,holeColor:a,scoreColor:r}of this.surfaces){const l=e.kerf();if((e.scores.length>0||e.holes.length>0)&&s(),e.scores.length>0){s();for(const n of e.scores)i(l,[t[0]+n.offset[0],t[1]+n.offset[1]],n.commands,!1,r);o()}s(),i(l,t,e.border,!0,n);for(const a of e.cuts)i(l,[t[0]+a.offset[0],t[1]+a.offset[1]],a.commands,!1,n);if(o(),e.holes.length>0){s();for(const n of e.holes)i(l,[t[0]+n.offset[0],t[1]+n.offset[1]],n.commands,!0,a);o()}(e.scores.length>0||e.holes.length>0)&&o()}const l=e[1][0]-e[0][0],d=e[1][1]-e[0][1];return{mimeType:"image/svg+xml",extension:".svg",data:(new TextEncoder).encode(`<?xml version='1.0' encoding='utf-8'?>\n<svg\n  width="${a(l)}${t}"\n  height="${a(d)}${t}"\n  viewBox="${a(e[0][0])} ${a(e[0][1])} ${a(l)} ${a(d)}"\n  xmlns="http://www.w3.org/2000/svg">\n\x3c!--\nGenerated by boxburner\nby Sean Connelly (@velipso), https://sean.fun\nProject Home: https://github.com/velipso/boxburner\nSPDX-License-Identifier: 0BSD\n--\x3e\n${n.join("")}\n</svg>`)}}}exports.BoxJoint=p,exports.ButtJoint=g,exports.DocumentBase=B,exports.DocumentSVG=D,exports.DrawBuilder=c,exports.EdgeBase=m,exports.GeneratorBase=t,exports.KerfTester=v,exports.MortiseAndTenonJoint=w,exports.PlainBox=x,exports.Rectangle=y,exports.SettingsTypeDef={properties:{defaultThickness:{type:"float64",metadata:{default:3,title:"Default Material Thickness (units)"}},defaultKerf:{type:"float64",metadata:{default:.1,title:"Default Kerf (units)",description:"Thickness of material removed by cutting tool"}},units:{enum:["mm","in"],metadata:{default:"mm",title:"Units"}},fileFormat:{enum:["svg"],metadata:{default:"svg",title:"File Format"}},debug:{type:"boolean",metadata:{default:!1,title:"Debug"}}},metadata:{title:"Settings",order:["defaultThickness","defaultKerf","units","fileFormat","debug"],startHidden:!0}},exports.Surface=r,exports.SurfaceBuilder=u,exports.allEdges=b,exports.allEdgesTypeDef=k,exports.allGenerators=M,exports.copyVec2=i,exports.eps=o,exports.expandPathByKerf=h,exports.exportDocument=function(t){const{fileFormat:e}=t;if("svg"===e)return new D(t);throw new Error(`Unknown export file format: ${e}`)},exports.forwardVec2=l,exports.linesIntersect=d;
