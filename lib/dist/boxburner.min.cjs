"use strict";class t{}function e(t,e){if(e.length<=0)throw new Error(`${t}: Cannot have empty list of commands for closed path`);const r=e[e.length-1].to;if(0!==r[0]||0!==r[1])throw new Error(`${t}: Closed path must end on [0, 0]`)}function r(t){let e=0;for(let r=0;r<t.length;r++){const s=t[r].to,o=t[(r+1)%t.length].to;e+=(o[0]-s[0])*(o[1]+s[1])}return e<0}class s{constructor(t,s,o=[],n=[],i=[]){if(e("Surface border",s),!r(s))throw new Error("Surface border: Points must be in counter-clockwise order for border");for(let t=0;t<o.length;t++){const s=`Surface hole ${t}`;if(e(s,o[t]),r(o[t]))throw new Error(`${s}: Points must be in clockwise order for holes`)}this.thickness=t,this.border=s,this.holes=o,this.cuts=n,this.text=i}}class o{constructor(){this.commands=[]}cursor(){return this.commands.length<=0?[0,0]:this.commands[this.commands.length-1].to}lineTo(t){return this.commands.push({kind:"L",to:t}),this}quadCurveTo(t,e){const r=this.cursor();return this.curveTo([r[0]+2*(t[0]-r[0])/3,r[1]+2*(t[1]-r[1])/3],[e[0]+2*(t[0]-e[0])/3,e[1]+2*(t[1]-e[1])/3],e)}curveTo(t,e,r){return this.commands.push({kind:"C",c1:t,c2:e,to:r}),this}build(){return this.commands}}class n extends t{name(){return"PlainBox"}defaultParams(){return{thickness:3,width:100,height:100}}schema(){return{properties:{thickness:{type:"float64"},width:{type:"float64"},height:{type:"float64"}},metadata:{keyOrder:["thickness","width","height"],titles:{thickness:"Material Thickness (mm)",width:"Outer Width (mm)",height:"Outer Height (mm)"}}}}generate({thickness:t,width:e,height:r}){return new s(t,(new o).lineTo([e,0]).lineTo([e,r]).lineTo([0,r]).lineTo([0,0]).build())}}exports.DrawBuilder=o,exports.GeneratorBase=t,exports.PlainBox=n,exports.Surface=s,exports.test=function(){const t=new n;console.log(t.schema()),console.log(t.generate({thickness:3,width:50,height:30}))};
