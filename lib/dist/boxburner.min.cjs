"use strict";function e(e,t,n){return e+(t-e)*n}function t(t,n,s){return[e(t[0],n[0],s),e(t[1],n[1],s)]}class n{}class s extends n{constructor(e=1e-10){super(),this.epsilon=e}snap0(e){return Math.abs(e)<this.epsilon?0:e}snap01(e){return Math.abs(e)<this.epsilon?0:Math.abs(1-e)<this.epsilon?1:e}isCollinear(e,t,n){const s=e[0]-t[0],i=e[1]-t[1],a=t[0]-n[0],r=t[1]-n[1];return Math.abs(s*r-a*i)<this.epsilon}solveCubicNormalized(e,t,n){const s=e/3,i=t/3,a=s*s-i,r=s*(s*s-t/2)+n/2;if(Math.abs(r)<this.epsilon&&Math.abs(a)<this.epsilon)return[-s];const o=s*(s*(4*s*n-i*t)-2*t*n)+4*i*i*i+n*n;if(Math.abs(o)<this.epsilon){const t=Math.sqrt(a);return r>0?[-2*t-e/3,t-e/3]:[-t-e/3,2*t-e/3]}const l=a*a*a,h=r*r;if(h<l){const e=(r<0?-1:1)*Math.sqrt(h/l),t=Math.acos(e),n=-2*Math.sqrt(a);return[n*Math.cos(t/3)-s,n*Math.cos((t+2*Math.PI)/3)-s,n*Math.cos((t-2*Math.PI)/3)-s].sort(((e,t)=>e-t))}{const e=(r<0?1:-1)*Math.pow(Math.abs(r)+Math.sqrt(h-l),1/3);return[e+(Math.abs(e)>=this.epsilon?a/e:0)-s]}}solveCubic(e,t,n,s){if(Math.abs(e)<this.epsilon){if(Math.abs(t)<this.epsilon)return Math.abs(n)<this.epsilon?Math.abs(s)<this.epsilon?[0]:[]:[-s/n];const e=2*t;let i=n*n-4*t*s;return Math.abs(i)<this.epsilon?[-n/e]:i>0?(i=Math.sqrt(i),[(-n+i)/e,(-n-i)/e].sort(((e,t)=>e-t))):[]}return this.solveCubicNormalized(t/e,n/e,s/e)}isEqualVec2(e,t){return Math.abs(e[0]-t[0])<this.epsilon&&Math.abs(e[1]-t[1])<this.epsilon}compareVec2(e,t){return Math.abs(t[0]-e[0])<this.epsilon?Math.abs(t[1]-e[1])<this.epsilon?0:e[1]<t[1]?-1:1:e[0]<t[0]?-1:1}}class i{constructor(e){this.tValues=[],this.geo=e}addArray(e){for(const t of e)this.tValues.push(t);return this}add(e){if((e=this.geo.snap01(e))<0||e>1)return this;for(const t of this.tValues)if(0===this.geo.snap0(e-t))return this;return this.tValues.push(e),this}list(){return this.tValues.sort(((e,t)=>e-t)),this.tValues}}class a{constructor(e,t){this.tValuePairs=[],this.allowOutOfRange=e,this.geo=t}add(e,t){if(e=this.geo.snap01(e),t=this.geo.snap01(t),!this.allowOutOfRange&&(e<0||e>1||t<0||t>1))return this;for(const n of this.tValuePairs)if(0===this.geo.snap0(e-n[0])||0===this.geo.snap0(t-n[1]))return this;return this.tValuePairs.push([e,t]),this}list(){return this.tValuePairs.sort(((e,t)=>e[0]-t[0])),this.tValuePairs}done(){return this.tValuePairs.length<=0?null:{kind:"tValuePairs",tValuePairs:this.list()}}}class r{}class o extends r{constructor(e,t,n){super(),this.p0=e,this.p1=t,this.geo=n}copy(){return new o(this.p0,this.p1,this.geo)}isEqual(e){return this.geo.isEqualVec2(this.p0,e.p0)&&this.geo.isEqualVec2(this.p1,e.p1)}start(){return this.p0}start2(){return this.p1}end2(){return this.p0}end(){return this.p1}setStart(e){this.p0=e}setEnd(e){this.p1=e}point(e){const t=this.p0,n=this.p1;return 0===e?t:1===e?n:[t[0]+(n[0]-t[0])*e,t[1]+(n[1]-t[1])*e]}split(e){if(e.length<=0)return[this];const t=e.map((e=>this.point(e)));t.push(this.p1);const n=[];let s=this.p0;for(const e of t)n.push(new o(s,e,this.geo)),s=e;return n}reverse(){return new o(this.p1,this.p0,this.geo)}boundingBox(){const e=this.p0,t=this.p1;return[[Math.min(e[0],t[0]),Math.min(e[1],t[1])],[Math.max(e[0],t[0]),Math.max(e[1],t[1])]]}pointOn(e){return this.geo.isCollinear(e,this.p0,this.p1)}draw(e){const t=this.p0,n=this.p1;return e.moveTo(t[0],t[1]),e.lineTo(n[0],n[1]),e}}class l extends r{constructor(e,t,n,s,i){super(),this.p0=e,this.p1=t,this.p2=n,this.p3=s,this.geo=i}copy(){return new l(this.p0,this.p1,this.p2,this.p3,this.geo)}isEqual(e){return this.geo.isEqualVec2(this.p0,e.p0)&&this.geo.isEqualVec2(this.p1,e.p1)&&this.geo.isEqualVec2(this.p2,e.p2)&&this.geo.isEqualVec2(this.p3,e.p3)}start(){return this.p0}start2(){return this.p1}end2(){return this.p2}end(){return this.p3}setStart(e){this.p0=e}setEnd(e){this.p3=e}point(e){const t=this.p0,n=this.p1,s=this.p2,i=this.p3;if(0===e)return t;if(1===e)return i;const a=(1-e)*(1-e),r=e*e,o=a*(1-e),l=3*a*e,h=3*r*(1-e),c=r*e;return[t[0]*o+n[0]*l+s[0]*h+i[0]*c,t[1]*o+n[1]*l+s[1]*h+i[1]*c]}split(e){if(e.length<=0)return[this];const n=[],s=(e,s)=>{const[i,a,r,o]=e,h=t(i,a,s),c=t(a,r,s),d=t(r,o,s),u=t(h,c,s),p=t(c,d,s),g=t(u,p,s);return n.push(new l(i,h,u,g,this.geo)),[g,p,d,o]};let i=[this.p0,this.p1,this.p2,this.p3],a=0;for(const t of e)i=s(i,(t-a)/(1-a)),a=t;return n.push(new l(i[0],i[1],i[2],i[3],this.geo)),n}reverse(){return new l(this.p3,this.p2,this.p1,this.p0,this.geo)}getCubicCoefficients(e){const t=this.p0[e],n=this.p1[e],s=this.p2[e];return[this.p3[e]-3*s+3*n-t,3*s-6*n+3*t,3*n-3*t,t]}boundingTValues(){const e=new i(this.geo),t=(t,n,s,i)=>{const a=3*i-9*s+9*n-3*t,r=6*t-12*n+6*s,o=3*n-3*t;if(0===this.geo.snap0(a))e.add(-o/r);else{const t=r*r-4*a*o;if(t>=0){const n=Math.sqrt(t);e.add((-r+n)/(2*a)),e.add((-r-n)/(2*a))}}return e},n=this.p0,s=this.p1,a=this.p2,r=this.p3;return t(n[0],s[0],a[0],r[0]),t(n[1],s[1],a[1],r[1]),e.list()}inflectionTValues(){const e=new i(this.geo);e.addArray(this.boundingTValues());const t=this.p0,n=this.p1,s=this.p2,a=this.p3,r=3*(n[0]-t[0]),o=3*(n[1]-t[1]),l=6*(s[0]-n[0]),h=6*(s[1]-n[1]),c=3*(a[0]-s[0]),d=3*(a[1]-s[1]),u=6*(s[0]-2*n[0]+t[0]),p=6*(s[1]-2*n[1]+t[1]),g=r-l+c,f=o-h+d,m=l-2*r,v=h-2*o,b=6*(a[0]-2*s[0]+n[0])-u,w=6*(a[1]-2*s[1]+n[1])-p,y=g*w-f*b,T=g*p+m*w-f*u-v*b,k=m*p+r*w-v*u-o*b,x=r*p-o*u;for(const t of this.geo.solveCubic(y,T,k,x))e.add(t);return e.list()}boundingBox(){const e=this.p0,t=this.p3,n=[Math.min(e[0],t[0]),Math.min(e[1],t[1])],s=[Math.max(e[0],t[0]),Math.max(e[1],t[1])];for(const e of this.boundingTValues()){const t=this.point(e);n[0]=Math.min(n[0],t[0]),n[1]=Math.min(n[1],t[1]),s[0]=Math.max(s[0],t[0]),s[1]=Math.max(s[1],t[1])}return[n,s]}mapXtoT(e,t=!1){if(0===this.geo.snap0(this.p0[0]-e))return 0;if(0===this.geo.snap0(this.p3[0]-e))return 1;const n=this.p0[0]-e,s=this.p1[0]-e,i=this.p2[0]-e,a=[this.p3[0]-e-3*i+3*s-n,3*i-6*s+3*n,3*s-3*n,n];for(const e of this.geo.solveCubic(a[0],a[1],a[2],a[3])){const t=this.geo.snap01(e);if(t>=0&&t<=1)return e}if(t||e>=Math.min(this.p0[0],this.p3[0])&&e<=Math.max(this.p0[0],this.p3[0]))for(let e=0;e<4;e++){let e=-1;for(let t=0;t<4;t++)0!==a[t]&&(e<0||Math.abs(a[t])<Math.abs(a[e]))&&(e=t);if(e<0)return 0;a[e]=0;for(const e of this.geo.solveCubic(a[0],a[1],a[2],a[3])){const t=this.geo.snap01(e);if(t>=0&&t<=1)return e}}return!1}mapXtoY(e,t=!1){const n=this.mapXtoT(e,t);return!1!==n&&this.point(n)[1]}pointOn(e){if(this.geo.isEqualVec2(this.p0,e)||this.geo.isEqualVec2(this.p3,e))return!0;const t=this.mapXtoY(e[0]);return!1!==t&&0===this.geo.snap0(t-e[1])}toLine(){const e=this.p0,t=this.p1,n=this.p2,s=this.p3;return 0===this.geo.snap0(e[0]-t[0])&&0===this.geo.snap0(e[0]-n[0])&&0===this.geo.snap0(e[0]-s[0])||0===this.geo.snap0(e[1]-t[1])&&0===this.geo.snap0(e[1]-n[1])&&0===this.geo.snap0(e[1]-s[1])?new o(e,s,this.geo):null}draw(e){const t=this.p0,n=this.p1,s=this.p2,i=this.p3;return e.moveTo(t[0],t[1]),e.bezierCurveTo(n[0],n[1],s[0],s[1],i[0],i[1]),e}}function h(e,t){const n=t.p1[0]-t.p0[0],s=t.p1[1]-t.p0[1];return((e[0]-t.p0[0])*n+(e[1]-t.p0[1])*s)/(n*n+s*s)}function c(e,t,n,s){const i=e.geo,r=e.p0,o=e.p1,l=o[1]-r[1],h=r[0]-o[0];if(0===i.snap0(h)){const e=t.mapXtoT(r[0],!1);if(!1===e)return null;const o=(t.point(e)[1]-r[1])/l,h=new a(n,i);return s?h.add(e,o):h.add(o,e),h.done()}const c=l*r[0]+h*r[1],d=t.getCubicCoefficients(0),u=t.getCubicCoefficients(1),p=l*d[0]+h*u[0],g=l*d[1]+h*u[1],f=l*d[2]+h*u[2],m=l*d[3]+h*u[3]-c,v=i.solveCubic(p,g,f,m),b=new a(n,i);if(0===i.snap0(l))for(const e of v){const t=d[0]*e*e*e+d[1]*e*e+d[2]*e+d[3],n=(r[0]-t)/h;s?b.add(e,n):b.add(n,e)}else for(const e of v){const t=(u[0]*e*e*e+u[1]*e*e+u[2]*e+u[3]-r[1])/l;s?b.add(e,t):b.add(t,e)}return b.done()}function d(e,t,n){if(e instanceof o){if(t instanceof o)return function(e,t,n){const s=e.geo,i=e.p0,r=e.p1,o=t.p0,l=t.p1,c=r[0]-i[0],d=r[1]-i[1],u=l[0]-o[0],p=l[1]-o[1],g=c*p-d*u;if(0===s.snap0(g)){if(!s.isCollinear(i,r,o))return null;const n=h(t.p0,e),a=h(t.p1,e),l=s.snap01(Math.min(n,a)),c=s.snap01(Math.max(n,a));if(c<0||l>1)return null;const d=h(e.p0,t),u=h(e.p1,t),p=s.snap01(Math.min(d,u)),g=s.snap01(Math.max(d,u));return g<0||p>1?null:{kind:"tRangePairs",tStart:[Math.max(0,l),Math.max(0,p)],tEnd:[Math.min(1,c),Math.min(1,g)]}}const f=i[0]-o[0],m=i[1]-o[1];return new a(n,s).add((u*m-p*f)/g,(c*m-d*f)/g).done()}(e,t,n);if(t instanceof l)return c(e,t,n,!1)}else if(e instanceof l){if(t instanceof o)return c(t,e,n,!0);if(t instanceof l)return function(e,t,n){const s=e.geo;if(s.isEqualVec2(e.p0,t.p0))return s.isEqualVec2(e.p3,t.p3)?s.isEqualVec2(e.p1,t.p1)&&s.isEqualVec2(e.p2,t.p2)?{kind:"tRangePairs",tStart:[0,0],tEnd:[1,1]}:{kind:"tValuePairs",tValuePairs:[[0,0],[1,1]]}:{kind:"tValuePairs",tValuePairs:[[0,0]]};if(s.isEqualVec2(e.p0,t.p3))return{kind:"tValuePairs",tValuePairs:[[0,1]]};if(s.isEqualVec2(e.p3,t.p0))return{kind:"tValuePairs",tValuePairs:[[1,0]]};if(s.isEqualVec2(e.p3,t.p3))return{kind:"tValuePairs",tValuePairs:[[1,1]]};const i=new a(n,s),r=(e,t,n,a,o,l)=>{if(!function(e,t){const[n,s]=e,[i,a]=t;return!(n[0]>a[0]||s[0]<i[0]||n[1]>a[1]||s[1]<i[1])}(e.boundingBox(),a.boundingBox()))return;const h=(t+n)/2,c=(o+l)/2;if(0===s.snap0(n-t)&&0===s.snap0(l-o))return void i.add(h,c);const[d,u]=e.split([.5]),[p,g]=a.split([.5]);r(d,t,h,p,o,c),r(u,h,n,p,o,c),r(d,t,h,g,c,l),r(u,h,n,g,c,l)};return r(e,0,1,t,0,1),i.done()}(e,t,n)}throw new Error("PolyBool: Unknown segment instance in segmentsIntersect")}class u{constructor(e,t=null,n=!1,s=null){var i,a,r;this.otherFill=null,this.id=null!==(i=null==s?void 0:s.segmentId())&&void 0!==i?i:-1,this.data=e,this.myFill={above:null!==(a=null==t?void 0:t.above)&&void 0!==a?a:null,below:null!==(r=null==t?void 0:t.below)&&void 0!==r?r:null},this.closed=n}}class p extends u{}class g extends u{}function f(e,t){if(e instanceof p)return new p(e.data,e.myFill,e.closed,t);if(e instanceof g)return new g(e.data,e.myFill,e.closed,t);throw new Error("PolyBool: Unknown SegmentBool in copySegmentBool")}class m{constructor(e,t,n,s){this.status=null,this.isStart=e,this.p=t,this.seg=n,this.primary=s}}class v{constructor(){this.nodes=[]}remove(e){const t=this.nodes.indexOf(e);t>=0&&this.nodes.splice(t,1)}getIndex(e){return this.nodes.indexOf(e)}isEmpty(){return this.nodes.length<=0}getHead(){return this.nodes[0]}removeHead(){this.nodes.shift()}insertBefore(e,t){this.findTransition(e,t).insert(e)}findTransition(e,t){var n,s;let i=0,a=this.nodes.length;for(;i<a;){const n=i+a>>1;r=this.nodes[n],t(e)-t(r)>0?a=n:i=n+1}var r;return{before:i<=0?null:null!==(n=this.nodes[i-1])&&void 0!==n?n:null,after:null!==(s=this.nodes[i])&&void 0!==s?s:null,insert:e=>(this.nodes.splice(i,0,e),e)}}}class b{constructor(e,t,n=null){this.events=new v,this.status=new v,this.currentPath=[],this.selfIntersection=e,this.geo=t,this.log=n}compareEvents(e,t,n,s,i,a,r,l){const h=this.geo.compareVec2(t,a);return 0!==h?h:s instanceof o&&l instanceof o&&this.geo.isEqualVec2(n,r)?0:e!==i?e?1:-1:this.compareSegments(l,s)}addEvent(e){this.events.insertBefore(e,(t=>t===e?0:this.compareEvents(e.isStart,e.p,e.other.p,e.seg.data,t.isStart,t.p,t.other.p,t.seg.data)))}divideEvent(e,t,n){var s,i;null===(s=this.log)||void 0===s||s.segmentDivide(e.seg,n);const[a,r]=e.seg.data.split([t]);a.setEnd(n),r.setStart(n);const h=r instanceof o?new p(r,e.seg.myFill,e.seg.closed,this.log):r instanceof l?new g(r,e.seg.myFill,e.seg.closed,this.log):null;if(!h)throw new Error("PolyBool: Unknown segment data in divideEvent");return this.events.remove(e.other),e.seg.data=a,null===(i=this.log)||void 0===i||i.segmentChop(e.seg),e.other.p=n,this.addEvent(e.other),this.addSegment(h,e.primary)}beginPath(){this.currentPath=[]}closePath(){for(const e of this.currentPath)e.closed=!0}addSegment(e,t){const n=new m(!0,e.data.start(),e,t),s=new m(!1,e.data.end(),e,t);return n.other=s,s.other=n,this.addEvent(n),this.addEvent(s),n}addLine(e,t,n=!0){const s=this.geo.compareVec2(e,t);if(0===s)return;const i=new p(new o(s<0?e:t,s<0?t:e,this.geo),null,!1,this.log);this.currentPath.push(i),this.addSegment(i,n)}addCurve(e,t,n,s,i=!0){const a=new l(e,t,n,s,this.geo),r=a.split(a.inflectionTValues());for(const e of r){const t=this.geo.compareVec2(e.start(),e.end());if(0===t)continue;const n=e.toLine();if(n)this.addLine(n.p0,n.p1,i);else{const n=new g(t<0?e:e.reverse(),null,!1,this.log);this.currentPath.push(n),this.addSegment(n,i)}}}compareSegments(e,t){let n=e.start(),s=t.start2();const i=t.start();if(t.pointOn(n)){if(n=e.start2(),t.pointOn(n)){if(e instanceof o){if(t instanceof o)return 0;t instanceof l&&(n=e.point(.5))}e instanceof l&&(n=e.end())}if(t instanceof l&&0===this.geo.snap0(n[0]-i[0])&&0===this.geo.snap0(s[0]-i[0]))return Math.sign(i[1]-n[1])}else{if(t instanceof l){const e=t.mapXtoY(n[0],!0);if(!1!==e)return Math.sign(e-n[1])}if(e instanceof l){const n=d(e,t,!0);if(n&&"tValuePairs"===n.kind)for(const t of n.tValuePairs){const n=this.geo.snap01(t[0]);if(n>0&&n<1){s=e.point(n);break}}}}const[a,r]=n,[h,c]=s,[u,p]=i;return Math.sign((h-a)*(p-r)-(c-r)*(u-a))}statusFindSurrounding(e){return this.status.findTransition(e,(t=>{if(e===t)return 0;const n=this.compareSegments(e.seg.data,t.seg.data);return 0===n?-1:n}))}checkIntersection(e,t){var n;const s=e.seg,i=t.seg;null===(n=this.log)||void 0===n||n.checkIntersection(s,i);const a=d(s.data,i.data,!1);if(null===a)return null;if("tRangePairs"===a.kind){const{tStart:[n,r],tEnd:[o,l]}=a;if(1===n&&1===o&&0===r&&0===l||0===n&&0===o&&1===r&&1===l)return null;if(0===n&&1===o&&0===r&&1===l)return t;const h=s.data.start(),c=s.data.end(),d=i.data.end();return 0===n&&0===r?(1===o?this.divideEvent(t,l,c):this.divideEvent(e,o,d),t):(r>0&&r<1&&(1===o&&1===l||(1===o?this.divideEvent(t,l,c):this.divideEvent(e,o,d)),this.divideEvent(t,r,h)),null)}if("tValuePairs"===a.kind){if(a.tValuePairs.length<=0)return null;let n=a.tValuePairs[0];for(let e=1;e<a.tValuePairs.length&&(0===n[0]&&0===n[1]||0===n[0]&&1===n[1]||1===n[0]&&0===n[1]||1===n[0]&&1===n[1]);e++)n=a.tValuePairs[e];const[r,o]=n,l=0===o?i.data.start():1===o?i.data.end():0===r?s.data.start():1===r?s.data.end():s.data.point(r);return r>0&&r<1&&this.divideEvent(e,r,l),o>0&&o<1&&this.divideEvent(t,o,l),null}throw new Error("PolyBool: Unknown intersection type")}calculate(){var e,t,n,s,i,a,r,o;const l=[];for(;!this.events.isEmpty();){const o=this.events.getHead();if(null===(e=this.log)||void 0===e||e.vert(o.p[0]),o.isStart){null===(t=this.log)||void 0===t||t.segmentNew(o.seg,o.primary);const e=this.statusFindSurrounding(o),r=e.before,l=e.after;null===(n=this.log)||void 0===n||n.tempStatus(o.seg,!!r&&r.seg,!!l&&l.seg);const h=()=>{if(r){const e=this.checkIntersection(o,r);if(e)return e}return l?this.checkIntersection(o,l):null},c=h();if(c){if(this.selfIntersection){let e;e=null===o.seg.myFill.below?o.seg.closed:o.seg.myFill.above!==o.seg.myFill.below,e&&(c.seg.myFill.above=!c.seg.myFill.above)}else c.seg.otherFill=o.seg.myFill;null===(s=this.log)||void 0===s||s.segmentUpdate(c.seg),this.events.remove(o.other),this.events.remove(o)}if(this.events.getHead()!==o){null===(i=this.log)||void 0===i||i.rewind(o.seg);continue}if(this.selfIntersection){let e;e=null===o.seg.myFill.below?o.seg.closed:o.seg.myFill.above!==o.seg.myFill.below,o.seg.myFill.below=!!l&&l.seg.myFill.above,o.seg.myFill.above=e?!o.seg.myFill.below:o.seg.myFill.below}else if(null===o.seg.otherFill){let e;if(l)if(o.primary===l.primary){if(null===l.seg.otherFill)throw new Error("PolyBool: Unexpected state of otherFill (null)");e=l.seg.otherFill.above}else e=l.seg.myFill.above;else e=!1;o.seg.otherFill={above:e,below:e}}null===(a=this.log)||void 0===a||a.status(o.seg,!!r&&r.seg,!!l&&l.seg),o.other.status=e.insert(o)}else{const e=o.status;if(null===e)throw new Error("PolyBool: Zero-length segment detected; your epsilon is probably too small or too large");const t=this.status.getIndex(e);if(t>0&&t<this.status.nodes.length-1){const e=this.status.nodes[t-1],n=this.status.nodes[t+1];this.checkIntersection(e,n)}if(null===(r=this.log)||void 0===r||r.statusRemove(e.seg),this.status.remove(e),!o.primary){if(!o.seg.otherFill)throw new Error("PolyBool: Unexpected state of otherFill (null)");const e=o.seg.myFill;o.seg.myFill=o.seg.otherFill,o.seg.otherFill=e}l.push(o.seg)}this.events.removeHead()}return null===(o=this.log)||void 0===o||o.done(),l}}function w(e,t,n){const s=[];for(const i of e){const e=t[(i.myFill.above?8:0)+(i.myFill.below?4:0)+(i.otherFill&&i.otherFill.above?2:0)+(i.otherFill&&i.otherFill.below?1:0)],a=!!(1&e),r=!!(2&e);if(!i.closed&&0!==e||i.closed&&a!==r){const e={above:a,below:r};if(i instanceof p)s.push(new p(i.data,e,i.closed,n));else{if(!(i instanceof g))throw new Error("PolyBool: Unknown SegmentBool type in SegmentSelector");s.push(new g(i.data,e,i.closed,n))}}}return null==n||n.selected(s),s}class y{static union(e,t){return w(e,[4,2,1,0,2,2,0,0,1,0,1,0,0,0,0,0],t)}static intersect(e,t){return w(e,[0,0,0,4,0,2,0,2,0,0,1,1,4,2,1,0],t)}static difference(e,t){return w(e,[4,0,0,0,2,0,2,0,1,1,0,0,0,1,2,0],t)}static differenceRev(e,t){return w(e,[4,2,1,0,0,0,1,1,0,2,0,2,0,0,0,0],t)}static xor(e,t){return w(e,[4,2,1,0,2,0,0,1,1,0,0,2,0,1,2,0],t)}}function T(e,t,n){return e!==t&&(e instanceof o&&t instanceof o?function(e,t,n){return!!n.isCollinear(e.p0,e.p1,t.p1)&&new o(e.p0,t.p1,n)}(e,t,n):e instanceof l&&t instanceof l&&function(e,t,n){if(n.isCollinear(e.p2,e.p3,t.p1)){const s=t.p1[0]-e.p2[0],i=t.p1[1]-e.p2[1],a=Math.abs(s)>Math.abs(i)?(e.p3[0]-e.p2[0])/s:(e.p3[1]-e.p2[1])/i,r=n.snap01(a);if(0!==r&&1!==r){const s=new l(e.p0,[e.p0[0]+(e.p1[0]-e.p0[0])/a,e.p0[1]+(e.p1[1]-e.p0[1])/a],[t.p2[0]-a*(t.p3[0]-t.p2[0])/(1-a),t.p2[1]-a*(t.p3[1]-t.p2[1])/(1-a)],t.p3,n),[i,r]=s.split([a]);if(i.isEqual(e)&&r.isEqual(t))return s}}return!1}(e,t,n))}function k(e,t,n){const s=[],i=[],a=[];for(const r of e){let l=r.data;const h=r.closed,c=h?s:i,d=l.start(),u=l.end(),p=e=>{null==n||n.chainReverse(e,h);const t=[];for(const n of c[e].segs)t.unshift(n.reverse());return c[e]={segs:t,fill:!c[e].fill},t};if(l instanceof o&&t.isEqualVec2(d,u)){console.warn("PolyBool: Warning: Zero-length segment detected; your epsilon is probably too small or too large");continue}null==n||n.chainStart({seg:l,fill:!!r.myFill.above},h);const g={index:0,matchesHead:!1,matchesPt1:!1},f={index:0,matchesHead:!1,matchesPt1:!1};let m=g;function v(e,t,n){return m&&(m.index=e,m.matchesHead=t,m.matchesPt1=n),m===g?(m=f,!1):(m=null,!0)}for(let b=0;b<c.length;b++){const w=c[b].segs,y=w[0].start(),k=w[w.length-1].end();if(t.isEqualVec2(y,d)){if(v(b,!0,!0))break}else if(t.isEqualVec2(y,u)){if(v(b,!0,!1))break}else if(t.isEqualVec2(k,d)){if(v(b,!1,!0))break}else if(t.isEqualVec2(k,u)&&v(b,!1,!1))break}if(m===g){const x=!!r.myFill.above;c.push({segs:[l],fill:x}),null==n||n.chainNew({seg:l,fill:x},h)}else if(m===f){const P=g.index;null==n||n.chainMatch(P,h);const{segs:M,fill:D}=c[P];if(g.matchesHead?g.matchesPt1?(l=l.reverse(),null==n||n.chainAddHead(P,{seg:l,fill:D},h),M.unshift(l)):(null==n||n.chainAddHead(P,{seg:l,fill:D},h),M.unshift(l)):g.matchesPt1?(null==n||n.chainAddTail(P,{seg:l,fill:D},h),M.push(l)):(l=l.reverse(),null==n||n.chainAddTail(P,{seg:l,fill:D},h),M.push(l)),g.matchesHead){const S=M[1],E=T(l,S,t);E&&(M.shift(),M[0]=E,null==n||n.chainSimplifyHead(P,{seg:E,fill:D},h))}else{const C=T(M[M.length-2],l,t);C&&(M.pop(),M[M.length-1]=C,null==n||n.chainSimplifyTail(P,{seg:C,fill:D},h))}if(h){let B=M,V=B[0],I=B[B.length-1];if(B.length>0&&t.isEqualVec2(V.start(),I.end())){let F=0,H=B[0].start();for(const W of B){const R=W.end();F+=R[1]*H[0]-R[0]*H[1],H=R}F<0===D&&(B=p(P),V=B[0],I=B[B.length-1]);const q=T(I,V,t);q&&(B.pop(),B[0]=q,null==n||n.chainSimplifyClose(P,{seg:q,fill:D},h)),null==n||n.chainClose(P,h),c.splice(P,1),a.push(B)}}}else{const L=(e,s)=>{const{segs:i,fill:a}=c[e],{segs:r}=c[s];null==n||n.chainAddTail(e,{seg:l,fill:a},h),i.push(l);const o=T(i[i.length-2],l,t);o&&(i.pop(),i[i.length-1]=o,null==n||n.chainSimplifyTail(e,{seg:o,fill:a},h));const d=T(i[i.length-1],r[0],t);d&&(r.shift(),i[i.length-1]=d,null==n||n.chainSimplifyJoin(e,s,{seg:d,fill:a},h)),null==n||n.chainJoin(e,s,h),c[e].segs=i.concat(r),c.splice(s,1)},$=g.index,J=f.index;null==n||n.chainConnect($,J,h);const N=c[$].segs.length<c[J].segs.length;g.matchesHead?f.matchesHead?N?(g.matchesPt1||(l=l.reverse()),p($),L($,J)):(g.matchesPt1&&(l=l.reverse()),p(J),L(J,$)):(g.matchesPt1&&(l=l.reverse()),L(J,$)):f.matchesHead?(g.matchesPt1||(l=l.reverse()),L($,J)):N?(g.matchesPt1&&(l=l.reverse()),p($),L(J,$)):(g.matchesPt1||(l=l.reverse()),p(J),L($,J))}}for(const{segs:_}of i)a.push(_);return a}class x{constructor(e,t=null,n=null){this.pathState={kind:"beginPath"},this.saveStack=[],this.matrix=[1,0,0,1,0,0],this.geo=e,this.log=n,this.resultState=t?{state:"seg",segments:t}:{state:"new",selfIntersect:new b(!0,this.geo,this.log)}}setTransform(e,t,n,s,i,a){if("new"!==this.resultState.state)throw new Error("PolyBool: Cannot change shape after using it in an operation");return this.matrix=[e,t,n,s,i,a],this}resetTransform(){return this.matrix=[1,0,0,1,0,0],this}getTransform(){if("new"!==this.resultState.state)throw new Error("PolyBool: Cannot change shape after using it in an operation");const[e,t,n,s,i,a]=this.matrix;return{a:e,b:t,c:n,d:s,e:i,f:a}}transform(e,t,n,s,i,a){const[r,o,l,h,c,d]=this.matrix;return this.matrix=[r*e+l*t,o*e+h*t,r*n+l*s,o*n+h*s,r*i+l*a+c,o*i+h*a+d],this}rotate(e){const t=Math.cos(e),n=Math.sin(e),[s,i,a,r,o,l]=this.matrix;return this.matrix=[s*t+a*n,i*t+r*n,a*t-s*n,r*t-i*n,o,l],this}rotateDeg(e){const t=(e%360+360)%360;if(0===t)return this;let n=0,s=0;if(90===t)s=1;else if(180===t)n=-1;else if(270===t)s=-1;else if(45===t)n=s=Math.SQRT1_2;else if(135===t)s=Math.SQRT1_2,n=-Math.SQRT1_2;else if(225===t)n=s=-Math.SQRT1_2;else if(315===t)n=Math.SQRT1_2,s=-Math.SQRT1_2;else if(30===t)n=Math.sqrt(3)/2,s=.5;else if(60===t)n=.5,s=Math.sqrt(3)/2;else if(120===t)n=-.5,s=Math.sqrt(3)/2;else if(150===t)n=-Math.sqrt(3)/2,s=.5;else if(210===t)n=-Math.sqrt(3)/2,s=-.5;else if(240===t)n=-.5,s=-Math.sqrt(3)/2;else if(300===t)n=.5,s=-Math.sqrt(3)/2;else if(330===t)n=Math.sqrt(3)/2,s=-.5;else{const e=Math.PI*t/180;n=Math.cos(e),s=Math.sin(e)}const[i,a,r,o,l,h]=this.matrix;return this.matrix=[i*n+r*s,a*n+o*s,r*n-i*s,o*n-a*s,l,h],this}scale(e,t){const[n,s,i,a,r,o]=this.matrix;return this.matrix=[n*e,s*e,i*t,a*t,r,o],this}translate(e,t){const[n,s,i,a,r,o]=this.matrix;return this.matrix=[n,s,i,a,n*e+i*t+r,s*e+a*t+o],this}save(){if("new"!==this.resultState.state)throw new Error("PolyBool: Cannot change shape after using it in an operation");return this.saveStack.push({matrix:this.matrix}),this}restore(){if("new"!==this.resultState.state)throw new Error("PolyBool: Cannot change shape after using it in an operation");const e=this.saveStack.pop();return e&&(this.matrix=e.matrix),this}transformPoint(e,t){const[n,s,i,a,r,o]=this.matrix;return[n*e+i*t+r,s*e+a*t+o]}beginPath(){if("new"!==this.resultState.state)throw new Error("PolyBool: Cannot change shape after using it in an operation");return this.resultState.selfIntersect.beginPath(),this.endPath()}moveTo(e,t){if("new"!==this.resultState.state)throw new Error("PolyBool: Cannot change shape after using it in an operation");"beginPath"!==this.pathState.kind&&this.beginPath();const n=this.transformPoint(e,t);return this.pathState={kind:"moveTo",start:n,current:n},this}lineTo(e,t){if("new"!==this.resultState.state)throw new Error("PolyBool: Cannot change shape after using it in an operation");if("moveTo"!==this.pathState.kind)throw new Error("PolyBool: Must call moveTo prior to calling lineTo");const n=this.transformPoint(e,t);return this.resultState.selfIntersect.addLine(this.pathState.current,n),this.pathState.current=n,this}rect(e,t,n,s){return this.moveTo(e,t).lineTo(e+n,t).lineTo(e+n,t+s).lineTo(e,t+s).closePath().moveTo(e,t)}bezierCurveTo(e,t,n,s,i,a){if("new"!==this.resultState.state)throw new Error("PolyBool: Cannot change shape after using it in an operation");if("moveTo"!==this.pathState.kind)throw new Error("PolyBool: Must call moveTo prior to calling bezierCurveTo");const r=this.transformPoint(i,a);return this.resultState.selfIntersect.addCurve(this.pathState.current,this.transformPoint(e,t),this.transformPoint(n,s),r),this.pathState.current=r,this}closePath(){if("new"!==this.resultState.state)throw new Error("PolyBool: Cannot change shape after using it in an operation");return"moveTo"!==this.pathState.kind||this.geo.isEqualVec2(this.pathState.start,this.pathState.current)||(this.resultState.selfIntersect.addLine(this.pathState.current,this.pathState.start),this.pathState.current=this.pathState.start),this.resultState.selfIntersect.closePath(),this.endPath()}endPath(){if("new"!==this.resultState.state)throw new Error("PolyBool: Cannot change shape after using it in an operation");return this.pathState={kind:"beginPath"},this}selfIntersect(){return"new"===this.resultState.state&&(this.resultState={state:"seg",segments:this.resultState.selfIntersect.calculate()}),this.resultState.segments}segments(){if("reg"!==this.resultState.state){const e=this.selfIntersect();this.resultState={state:"reg",segments:e,regions:k(e,this.geo,this.log)}}return this.resultState.regions}output(e,t=[1,0,0,1,0,0]){return function(e,t,n,s){const[i,a,r,h,c,d]=s;n.beginPath();for(const s of e){if(s.length<=0)continue;for(let e=0;e<s.length;e++){const t=s[e];if(0===e){const[e,s]=t.start();n.moveTo(i*e+r*s+c,a*e+h*s+d)}if(t instanceof o){const[e,s]=t.p1;n.lineTo(i*e+r*s+c,a*e+h*s+d)}else{if(!(t instanceof l))throw new Error("PolyBool: Unknown segment instance");{const[e,s]=t.p1,[o,l]=t.p2,[u,p]=t.p3;n.bezierCurveTo(i*e+r*s+c,a*e+h*s+d,i*o+r*l+c,a*o+h*l+d,i*u+r*p+c,a*u+h*p+d)}}}const e=s[0],u=s[s.length-1];t.isEqualVec2(e.start(),u.end())&&n.closePath()}return n}(this.segments(),this.geo,e,t)}combine(e){const t=new b(!1,this.geo,this.log);for(const e of this.selfIntersect())t.addSegment(f(e,this.log),!0);for(const n of e.selfIntersect())t.addSegment(f(n,this.log),!1);return new P(t.calculate(),this.geo,this.log)}}class P{constructor(e,t,n=null){this.geo=t,this.segments=e,this.log=n}union(){return new x(this.geo,y.union(this.segments,this.log),this.log)}intersect(){return new x(this.geo,y.intersect(this.segments,this.log),this.log)}difference(){return new x(this.geo,y.difference(this.segments,this.log),this.log)}differenceRev(){return new x(this.geo,y.differenceRev(this.segments,this.log),this.log)}xor(){return new x(this.geo,y.xor(this.segments,this.log),this.log)}}class M{constructor(){this.list=[],this.nextSegmentId=0,this.curVert=NaN}push(e,t){this.list.push({type:e,data:JSON.parse(JSON.stringify(t))})}info(e,t){this.push("info",{msg:e,data:t})}segmentId(){return this.nextSegmentId++}checkIntersection(e,t){this.push("check",{seg1:e,seg2:t})}segmentDivide(e,t){this.push("div_seg",{seg:e,p:t})}segmentChop(e){this.push("chop",{seg:e})}statusRemove(e){this.push("pop_seg",{seg:e})}segmentUpdate(e){this.push("seg_update",{seg:e})}segmentNew(e,t){this.push("new_seg",{seg:e,primary:t})}tempStatus(e,t,n){this.push("temp_status",{seg:e,above:t,below:n})}rewind(e){this.push("rewind",{seg:e})}status(e,t,n){this.push("status",{seg:e,above:t,below:n})}vert(e){e!==this.curVert&&(this.push("vert",{x:e}),this.curVert=e)}selected(e){this.push("selected",{segs:e})}chainStart(e,t){this.push("chain_start",{sf:e,closed:t})}chainNew(e,t){this.push("chain_new",{sf:e,closed:t})}chainMatch(e,t){this.push("chain_match",{index:e,closed:t})}chainClose(e,t){this.push("chain_close",{index:e,closed:t})}chainAddHead(e,t,n){this.push("chain_add_head",{index:e,sf:t,closed:n})}chainAddTail(e,t,n){this.push("chain_add_tail",{index:e,sf:t,closed:n})}chainSimplifyHead(e,t,n){this.push("chain_simp_head",{index:e,sf:t,closed:n})}chainSimplifyTail(e,t,n){this.push("chain_simp_tail",{index:e,sf:t,closed:n})}chainSimplifyClose(e,t,n){this.push("chain_simp_close",{index:e,sf:t,closed:n})}chainSimplifyJoin(e,t,n,s){this.push("chain_simp_join",{index1:e,index2:t,sf:n,closed:s})}chainConnect(e,t,n){this.push("chain_con",{index1:e,index2:t,closed:n})}chainReverse(e,t){this.push("chain_rev",{index:e,closed:t})}chainJoin(e,t,n){this.push("chain_join",{index1:e,index2:t,closed:n})}done(){this.push("done",null)}}class D{constructor(e=new s,t=null){this.geo=e,this.log=t}shape(){return new x(this.geo,null,this.log)}buildLog(e){var t;return this.log=e?new M:null,null===(t=this.log)||void 0===t?void 0:t.list}segments(e){const t=this.shape();t.beginPath();for(const n of e.regions){const e=n[n.length-1];t.moveTo(e[e.length-2],e[e.length-1]);for(const e of n)if(2===e.length)t.lineTo(e[0],e[1]);else{if(6!==e.length)throw new Error("PolyBool: Invalid point in region");t.bezierCurveTo(e[0],e[1],e[2],e[3],e[4],e[5])}t.closePath()}return{shape:t,inverted:e.inverted}}combine(e,t){return{shape:e.shape.combine(t.shape),inverted1:e.inverted,inverted2:t.inverted}}selectUnion(e){return{shape:e.inverted1?e.inverted2?e.shape.intersect():e.shape.difference():e.inverted2?e.shape.differenceRev():e.shape.union(),inverted:e.inverted1||e.inverted2}}selectIntersect(e){return{shape:e.inverted1?e.inverted2?e.shape.union():e.shape.differenceRev():e.inverted2?e.shape.difference():e.shape.intersect(),inverted:e.inverted1&&e.inverted2}}selectDifference(e){return{shape:e.inverted1?e.inverted2?e.shape.differenceRev():e.shape.union():e.inverted2?e.shape.intersect():e.shape.difference(),inverted:e.inverted1&&!e.inverted2}}selectDifferenceRev(e){return{shape:e.inverted1?e.inverted2?e.shape.difference():e.shape.intersect():e.inverted2?e.shape.union():e.shape.differenceRev(),inverted:!e.inverted1&&e.inverted2}}selectXor(e){return{shape:e.shape.xor(),inverted:e.inverted1!==e.inverted2}}polygon(e){const t=[],n={beginPath:()=>{},moveTo:()=>{t.push([])},lineTo:(e,n)=>{t[t.length-1].push([e,n])},bezierCurveTo:(e,n,s,i,a,r)=>{t[t.length-1].push([e,n,s,i,a,r])},closePath:()=>{}};return e.shape.output(n),{regions:t,inverted:e.inverted}}union(e,t){const n=this.segments(e),s=this.segments(t),i=this.combine(n,s),a=this.selectUnion(i);return this.polygon(a)}intersect(e,t){const n=this.segments(e),s=this.segments(t),i=this.combine(n,s),a=this.selectIntersect(i);return this.polygon(a)}difference(e,t){const n=this.segments(e),s=this.segments(t),i=this.combine(n,s),a=this.selectDifference(i);return this.polygon(a)}differenceRev(e,t){const n=this.segments(e),s=this.segments(t),i=this.combine(n,s),a=this.selectDifferenceRev(i);return this.polygon(a)}xor(e,t){const n=this.segments(e),s=this.segments(t),i=this.combine(n,s),a=this.selectXor(i);return this.polygon(a)}}new D;const S=new class extends s{atan2Deg(e,t){return Math.abs(e)<this.epsilon?t>0||Math.abs(t)<this.epsilon?0:180:Math.abs(t)<this.epsilon?e<0?270:90:Math.abs(t-e)<this.epsilon?t<0?225:45:Math.abs(t+e)<this.epsilon?t<0?135:315:(180*Math.atan2(e,t)/Math.PI+360)%360}sinDeg(e){const t=(e%360+360)%360;switch(t){case 0:case 180:return 0;case 30:case 150:return.5;case 45:case 135:return Math.SQRT1_2;case 60:case 120:return Math.sqrt(3)/2;case 90:return 1;case 210:case 330:return-.5;case 225:case 315:return-Math.SQRT1_2;case 240:case 300:return-Math.sqrt(3)/2;case 270:return-1;default:return Math.sin(t*Math.PI/180)}}cosDeg(e){const t=(e%360+360)%360;switch(t){case 0:return 1;case 30:case 330:return Math.sqrt(3)/2;case 45:case 315:return Math.SQRT1_2;case 60:case 300:return.5;case 90:case 270:return 0;case 120:case 240:return-.5;case 135:case 225:return-Math.SQRT1_2;case 150:case 210:return-Math.sqrt(3)/2;case 180:return-1;default:return Math.cos(t*Math.PI/180)}}linesIntersect(e,t,n,s,i,a,r,o){const l=n-e,h=s-t,c=r-i,d=o-a,u=l*d-h*c;if(0===this.snap0(u))return null;const p=e-i,g=t-a,f=this.snap01((c*g-d*p)/u);return{p:[e+f*l,t+f*h],alongA:f,alongB:this.snap01((l*g-h*p)/u)}}},E=new D(S);function C(e,t){if(0===S.snap0(t))return e;const n=[];e.output({beginPath:()=>{},moveTo:(e,t)=>{n.push({path:[],closed:!1})},lineTo:(e,t)=>{n[n.length-1].path.push([e,t])},bezierCurveTo:(e,t,s,i,a,r)=>{n[n.length-1].path.push([e,t,s,i,a,r])},closePath:()=>{n[n.length-1].closed=!0}});const s=Math.abs(t)/2,i=90*Math.sign(t),a=E.shape().beginPath();for(const{path:e,closed:t}of n){let n=e;if(t){n=[];const t=(t,n)=>{const s=e[t],i=e[(t+e.length-1)%e.length],a=i[i.length-2],r=i[i.length-1];return 2===s.length||n?S.atan2Deg(r-s[1],a-s[0]):S.atan2Deg(s[3]-s[5],s[2]-s[4])},a=(e,t,n)=>[e[0]+n*S.cosDeg(t),e[1]+n*S.sinDeg(t)],r=(e,t,n)=>a(e,t-i,n),o=[];for(let i=0;i<e.length;i++){const l=(i+e.length-1)%e.length,h=e[i],c=t(l,!1),d=t(i,!0),u=t(i,!1),p=Math.min(Math.abs(c-d),Math.abs(c+360-d),Math.abs(c-(d+360)));if(S.snap0(p)>0){const t=4*s*Math.tan(p/4*Math.PI/180)/3,i=e[l],h=[i[i.length-2],i[i.length-1]];o.push(n.length);const u=a(r(h,c,s),c,-t),g=a(r(h,d,s),d,t),f=r(h,d,s);n.push([u[0],u[1],g[0],g[1],f[0],f[1]])}if(2===h.length)n.push(r(h,u,s));else{const e=r([h[0],h[1]],d,s),t=r([h[2],h[3]],u,s),i=r([h[4],h[5]],u,s);n.push([e[0],e[1],t[0],t[1],i[0],i[1]])}}for(const e of o){const t=(e+n.length-1)%n.length,s=(e+n.length-2)%n.length,i=(e+1)%n.length,a=n[s],r=n[t],o=n[e],l=n[i];if(6===o.length){const e=S.linesIntersect(2===r.length?a[a.length-2]:r[2],2===r.length?a[a.length-1]:r[3],r[r.length-2],r[r.length-1],o[o.length-2],o[o.length-1],l[0],l[1]);e&&e.alongA>0&&e.alongA<1&&e.alongB>0&&e.alongB<1&&(o[0]=r[r.length-2],o[1]=r[r.length-1],o[2]=o[4],o[3]=o[5],r[r.length-2]=e.p[0],r[r.length-1]=e.p[1],o[4]=e.p[0],o[5]=e.p[1])}}}if(n.length>0){const e=n[n.length-1];a.moveTo(e[e.length-2],e[e.length-1]);for(const e of n)2===e.length?a.lineTo(e[0],e[1]):a.bezierCurveTo(e[0],e[1],e[2],e[3],e[4],e[5])}}return a}class B{constructor(e,t,n=E.shape(),s=E.shape(),i=E.shape()){this.home={origin:[0,0],angle:0},this.thickness=e,this.kerf=t,this.border=n,this.cuts=s,this.scores=i}replace(e){var t,n,s,i,a;const r=new B(null!==(t=e.thickness)&&void 0!==t?t:this.thickness,null!==(n=e.kerf)&&void 0!==n?n:this.kerf,null!==(s=e.border)&&void 0!==s?s:this.border,null!==(i=e.cuts)&&void 0!==i?i:this.cuts,null!==(a=e.scores)&&void 0!==a?a:this.scores);return r.setHome(this.home.origin,this.home.angle),r}copy(){return this.replace({})}static combine(e,t,n){const s=t.cuts.combine(n.cuts).union().combine(e).intersect(),i=t.scores.combine(n.scores).union().combine(e).intersect();return t.replace({border:e,cuts:s,scores:i})}static union(e,t){return B.combine(e.border.combine(t.border).union(),e,t)}static intersect(e,t){return B.combine(e.border.combine(t.border).intersect(),e,t)}static subtract(e,t){return B.combine(e.border.combine(t.border).difference(),e,t)}static xor(e,t){return B.combine(e.border.combine(t.border).xor(),e,t)}unionBorder(e){return B.union(this,this.replace({border:e,cuts:E.shape(),scores:E.shape()}))}subtractBorder(e){return B.subtract(this,this.replace({border:e,cuts:E.shape(),scores:E.shape()}))}setHome(e,t){return this.home={origin:e,angle:t},this}newShape(){return E.shape().translate(this.home.origin[0],this.home.origin[1]).rotateDeg(this.home.angle)}boundingBox(){const e=[1/0,1/0],t=[-1/0,-1/0];let n=!0;const s=s=>{for(const i of s.segments())for(const s of i){const i=s.boundingBox();e[0]=Math.min(e[0],i[0][0]),e[1]=Math.min(e[1],i[0][1]),t[0]=Math.max(t[0],i[1][0]),t[1]=Math.max(t[1],i[1][1]),n=!1}};return s(this.border),s(this.cuts),s(this.scores),n&&(e[0]=e[1]=t[0]=t[1]=0),[e,t]}applyKerf(){return 0===S.snap0(this.kerf)?this:this.replace({kerf:0,border:C(this.border,this.kerf)})}}class V{constructor(e){}}function I(e,t=0){switch(typeof e){case"string":return JSON.stringify(e).replace(/--/g,"\\u002d-");case"boolean":case"number":return JSON.stringify(e);case"object":if(null===e)return"null";if(Array.isArray(e)){if(e.every((e=>"object"==typeof e&&null!==e))){const n=[];for(let s=0;s<e.length;s++){const i=I(e[s],t);i&&n.push(i)}return`[${n.join(", ")}]`}{let n=[];for(let t=0;t<e.length;t++){const s=I(e[t]);s&&n.push(s)}const s=`[${n.join(",")}]`;if(s.length<60&&!s.includes("\n"))return s;n=[];for(let s=0;s<e.length;s++){const i=I(e[s],t+1);i&&n.push(i)}return`[\n${"  ".repeat(t+1)}${n.join(",\n")}\n${"  ".repeat(t)}]`}}{const n=[];for(const[s,i]of Object.entries(e)){const e=I(s),a=I(i,t+1);a&&n.push(`${"  ".repeat(t+1)}${e}: ${a}`)}return`{\n${n.join(",\n")}\n${"  ".repeat(t)}}`}}return""}class F extends V{constructor(e){super(e),this.surfaces=[],this.comments=[],this.settings=e}addSurface(e,t,n,s){this.surfaces.push({offset:e,surface:t.applyKerf(),cutColor:n,scoreColor:s})}addComment(e){this.comments.push(e)}toFile(){const e=e=>""+Math.round(1e3*e)/1e3,t=[];let n=0,s=0,i=100,a=100;if(this.surfaces.length>0){const r=[[1/0,1/0],[-1/0,-1/0]];for(const{offset:e,surface:t}of this.surfaces){const n=t.boundingBox();r[0][0]=Math.min(r[0][0],e[0]+n[0][0]-10),r[0][1]=Math.min(r[0][1],e[1]+n[0][1]-10),r[1][0]=Math.max(r[1][0],e[0]+n[1][0]+10),r[1][1]=Math.max(r[1][1],e[1]+n[1][1]+10)}n=r[0][0],s=r[0][1],i=r[1][0]-r[0][0],a=r[1][1]-r[0][1];let o=0;const l=()=>{t.push(`<g id="p-${o++}" style="fill:none;stroke-linecap:round;stroke-linejoin:round;">`)},h=()=>{t.push("</g>")},c=(n,s,i)=>{const a=[];s.output({beginPath:()=>{},moveTo:(t,n)=>{a.push(`M${e(t)} ${e(n)}`)},lineTo:(t,n)=>{a.push(`L${e(t)} ${e(n)}`)},bezierCurveTo:(t,n,s,i,r,o)=>{a.push(`C${e(t)} ${e(n)} ${e(s)} ${e(i)} ${e(r)} ${e(o)}`)},closePath:()=>{a.push("Z")}},[1,0,0,1,n[0],n[1]]),t.push(`<path stroke="${i}" stroke-width="1" d="${a.join("")}" />`)};for(const{offset:e,surface:t,cutColor:n,scoreColor:s}of this.surfaces)l(),l(),c(e,t.scores,s),h(),l(),c(e,t.border,n),c(e,t.cuts,n),h(),h()}const{units:r}=this.settings;return{mimeType:"image/svg+xml",extension:".svg",data:(new TextEncoder).encode(`<?xml version='1.0' encoding='utf-8'?>\n<svg\n  width="${e(i)}${r}"\n  height="${e(a)}${r}"\n  viewBox="${e(n)} ${e(s)} ${e(i)} ${e(a)}"\n  xmlns="http://www.w3.org/2000/svg">\n\x3c!--\nGenerated by boxburner\nby Sean Connelly (@velipso), https://sean.fun\nProject Home: https://github.com/velipso/boxburner\nSPDX-License-Identifier: 0BSD\n\nExported on: ${(new Date).toString()}\n--\x3e\n${this.comments.map((e=>`\x3c!--\n${I(e)}\n--\x3e`)).join("\n")}\n${t.join("\n")}\n</svg>`)}}}class H{}class q{}class W extends q{thickness(e,t){return this.jointThickness(!1,e,t)}draw(e,t,n,s){return this.jointDraw(e,t,!1,n,s)}}class R extends W{name(){return"ButtJoint"}schema(){return{properties:{invert:{type:"boolean",metadata:{default:!1,title:"Invert",description:"Swap settings for receiving side"}},length1:{type:"float64",metadata:{default:0,title:"Length 1",description:"Length of butt 1 (multiples of material thickness)"}},length2:{type:"float64",metadata:{default:1,title:"Length 2",description:"Length of butt 2 (multiples of material thickness)"}}},metadata:{order:["invert","length1","length2"]}}}jointThickness(e,t,{length1:n,length2:s,invert:i}){return(e!==i?s:n)*t}jointDraw(e,t,n,s,i){return e}}function L({length:e,width1:t,width2:n,cornerDistance1:s,cornerDistance2:i,centerDistance:a},r){let o=0;const l=(e,t)=>{r(o,e,t),o+=e},h=e=>{if(e>1e4)throw new Error("Too many fingers");l(t,!0);for(let s=0;s<e;s++)l(n,!1),l(t,!0)},c=e-s-i;if(a>0){const e=(c-a)/2,r=Math.floor((e-t)/(t+n)),o=t+r*(t+n);l(s+(e-o)/2,!1),h(r),l(a+e-o,!1),h(r),l(i+(e-o)/2,!1)}else{const e=Math.floor((c-t)/(t+n)),a=t+e*(t+n);l(s+(c-a)/2,!1),h(e),l(i+(c-a)/2,!1)}}class $ extends W{name(){return"BoxJoint"}schema(){return{properties:{invert:{type:"boolean",metadata:{default:!1,title:"Invert",description:"Swap settings for receiving side"}},width1:{type:"float64",metadata:{default:6,title:"Width 1",description:"Width of finger 1 (units)"}},length1:{type:"float64",metadata:{default:1,title:"Length 1",description:"Length of finger 1 (multiples of material thickness)"}},width2:{type:"float64",metadata:{default:6,title:"Width 2",description:"Width of finger 2 (units)"}},length2:{type:"float64",metadata:{default:1,title:"Length 2",description:"Length of finger 2 (multiples of material thickness)"}},play:{type:"float64",metadata:{default:0,title:"Play",description:"Extra space around fingers (units)"}},cornerDistance:{type:"float64",metadata:{default:12,title:"Corner Distance",description:"Reserved space near corners to exclude fingers (units)"}},cornerDistance1Delta:{type:"float64",nullable:!0,metadata:{default:null,defaultNotNull:0,title:"Corner Distance 1 Delta",description:"Additional corner distance"}},cornerDistance2Delta:{type:"float64",nullable:!0,metadata:{default:null,defaultNotNull:0,title:"Corner Distance 2 Delta",description:"Additional corner distance"}},centerDistance:{type:"float64",metadata:{default:0,title:"Center Distance",description:"Reserved space near center to exclude fingers (units)"}}},metadata:{order:["invert","width1","length1","width2","length2","play","cornerDistance","centerDistance"]}}}jointThickness(e,t,{length1:n,length2:s,invert:i}){return(e!==i?s:n)*t}jointDraw(e,t,n,s,{invert:i,width1:a,length1:r,width2:o,length2:l,play:h,cornerDistance:c,cornerDistance1Delta:d,cornerDistance2Delta:u,centerDistance:p}){const g=n!==i,f=(g?l:r)*s;return L({length:t,width1:a,width2:o,cornerDistance1:c+(null!=d?d:0),cornerDistance2:c+(null!=u?u:0),centerDistance:p},((t,n,s)=>{s===g&&(e=e.subtractBorder(e.newShape().beginPath().rect(t-h/2,0,n+h,f).closePath()))})),e}}class J extends q{name(){return"LegEdge"}schema(){return{properties:{flatWidth:{type:"float64",metadata:{default:.1,title:"Flat Width",description:"Flat part of leg (fraction of overall length)"}},curveWidth:{type:"float64",metadata:{default:.15,title:"Curve Width",description:"Curve part of leg (fraction of overall length)"}},curveAmount:{type:"float64",metadata:{default:.05,title:"Curve Amount",description:"How extreme to curve (fraction of overall length)"}},height:{type:"float64",metadata:{default:10,title:"Height (units)"}}},metadata:{order:["flatWidth","curveWidth","curveAmount","height"]}}}thickness(e,{height:t}){return Math.max(0,t)}draw(e,t,n,{flatWidth:s,curveWidth:i,curveAmount:a,height:r}){return r<=0?e:e.subtractBorder(e.newShape().beginPath().moveTo(s*t,0).bezierCurveTo((s+a)*t,0,(s+i-a)*t,r,(s+i)*t,r).lineTo((1-s-i)*t,r).bezierCurveTo((1-s-i+a)*t,r,(1-s-a)*t,0,(1-s)*t,0).closePath())}}function N(e,t={},n){return{discriminator:"kind",mapping:e.map((e=>({[e.name()]:{properties:{kind:{type:"string",metadata:{default:e.name(),title:e.name()}},params:e.schema()},metadata:{order:["params"],untabParams:!0}}}))).reduce(((e,t)=>({...e,...t})),{}),nullable:n,metadata:{default:e[0].name(),order:e.map((e=>e.name())),...t}}}const _=[new $,new R,new J];class A extends W{name(){return"MortiseAndTenonJoint"}schema(){return{properties:{invert:{type:"boolean",metadata:{default:!1,title:"Invert",description:"Swap settings for receiving side"}},width1:{type:"float64",metadata:{default:6,title:"Width 1",description:"Width of tenon (units)"}},tenonLength:{type:"float64",metadata:{default:1,title:"Tenon Length",description:"Length of tenon (multiples of material thickness)"}},width2:{type:"float64",metadata:{default:6,title:"Width 2",description:"Width between tenons (units)"}},holeDistance:{type:"float64",metadata:{default:3,title:"Hole Distance",description:"Distance of mortises from edge (units)"}},play:{type:"float64",metadata:{default:0,title:"Play",description:"Extra space between mortise and tenons (units)"}},thicknessPlay:{type:"float64",metadata:{default:0,title:"Thickness Play",description:"Extra thickness added to mortise holes (units)"}},cornerDistance:{type:"float64",metadata:{default:12,title:"Corner Distance",description:"Reserved space near corners to exclude joints (units)"}},cornerDistance1Delta:{type:"float64",nullable:!0,metadata:{default:null,defaultNotNull:0,title:"Corner Distance 1 Delta",description:"Additional corner distance"}},cornerDistance2Delta:{type:"float64",nullable:!0,metadata:{default:null,defaultNotNull:0,title:"Corner Distance 2 Delta",description:"Additional corner distance"}},centerDistance:{type:"float64",metadata:{default:0,title:"Center Distance",description:"Reserved space near center to exclude joints (units)"}},mortiseEdge:N(_,{default:null,defaultNotNull:"LegEdge",title:"Mortise Edge"},!0)},metadata:{order:["invert","width1","tenonLength","width2","holeDistance","play","thicknessPlay","cornerDistance","centerDistance","mortiseEdge"]}}}jointThickness(e,t,{tenonLength:n,invert:s,mortiseEdge:i}){if(e!==s){if(i){const e=_.find((e=>e.name()===i.kind));if(!e)throw new Error("Invalid mortise edge");return e.thickness(t,i.params)}return 0}return n*t}jointDraw(e,t,n,s,{invert:i,width1:a,tenonLength:r,width2:o,holeDistance:l,play:h,thicknessPlay:c,cornerDistance:d,cornerDistance1Delta:u,cornerDistance2Delta:p,centerDistance:g,mortiseEdge:f}){const m=n!==i;let v=0;if(m&&f){const n=_.find((e=>e.name()===f.kind));if(!n)throw new Error("Invalid mortise edge");v=n.thickness(s,f.params),e=n.draw(e,t,s,f.params)}return L({length:t,width1:a,width2:o,cornerDistance1:d+(null!=u?u:0),cornerDistance2:d+(null!=p?p:0),centerDistance:g},((t,n,i)=>{if(m&&i){const i=s,a=l+v;e=e.subtractBorder(e.newShape().beginPath().rect(t-h/2,a-c,n+h,i+2*c).closePath())}else if(!m&&!i){const i=r*s;e=e.subtractBorder(e.newShape().beginPath().rect(t-h/2,0,n+h,i).closePath())}})),e}}const z=[new R,new $,new J,new A],j=[new R,new $,new A];function U(e={},t){return N(z,e,t)}const O={" ":0,"!":74240,'"':516,"#":43580,$:43707,"%":61081,"&":37745,"'":512,"(":5120,")":16640,"*":65280,"+":43520,",":16384,"-":34816,".":65536,"/":17408,0:17663,1:1036,2:34935,3:2111,4:34956,5:35003,6:35067,7:15,8:35071,9:35007,":":8704,";":16896,"<":37888,"=":34864,">":18688,"?":75783,"@":2807,A:35023,B:10815,C:243,D:8767,E:33011,F:32963,G:2299,H:35020,I:8755,J:124,K:38080,L:240,M:1484,N:4556,O:255,P:35015,Q:4351,R:39111,S:35003,T:8707,U:252,V:17600,W:20684,X:21760,Y:35004,Z:17459,"[":8722,"\\":4352,"]":8737,"^":20480,_:48,"`":256,"{":41490,"|":8704,"}":10785,"~":52224},K=(e,t,n,s,i)=>{var a;const r=null!==(a=O[i.toUpperCase()])&&void 0!==a?a:O["?"],o=(i,a,r,o)=>{e.moveTo(t[0]+i*n,t[1]+a*s).lineTo(t[0]+r*n,t[1]+o*s)},l=.025;1&r&&o(l,0,.475,0),2&r&&o(.525,0,.975,0),4&r&&o(1,l,1,.475),8&r&&o(1,.525,1,.975),16&r&&o(.975,1,.525,1),32&r&&o(.475,1,l,1),64&r&&o(0,.975,0,.525),128&r&&o(0,.475,0,l),256&r&&o(l,l,.475,.475),512&r&&o(.5,l,.5,.475),1024&r&&o(.975,l,.525,.475),2048&r&&o(.525,.5,.975,.5),4096&r&&o(.525,.525,.975,.975),8192&r&&o(.5,.525,.5,65536&r?.775:.975),16384&r&&o(.475,.525,l,.975),32768&r&&o(.475,.5,l,.5),65536&r&&o(.5,.8+l,.5,.975)};class Q extends H{name(){return"Rectangle"}schema(){return{properties:{label:{type:"string",nullable:!0,metadata:{default:null,defaultNotNull:"",nullHint:"none",title:"Label"}},labelFontSize:{type:"float64",nullable:!0,metadata:{default:null,defaultNotNull:10,nullHint:"auto",title:"Label Font Size (units)"}},thickness:{type:"float64",nullable:!0,metadata:{default:null,defaultNotNull:3,nullHint:"default",title:"Material Thickness (units)"}},kerf:{type:"float64",nullable:!0,metadata:{default:null,defaultNotNull:.1,nullHint:"default",title:"Kerf (units)",description:"Thickness of material removed by cutting tool"}},width:{type:"float64",metadata:{default:100,title:"Inner Width (units)"}},height:{type:"float64",metadata:{default:100,title:"Inner Height (units)"}},edge1:U({title:"Top"}),edge2:U({title:"Right"}),edge3:U({title:"Bottom"}),edge4:U({title:"Left"})},metadata:{order:["label","labelFontSize","thickness","kerf","width","height","edge1","edge2","edge3","edge4"]}}}generate(e,{label:t,labelFontSize:n,thickness:s,kerf:i,width:a,height:r,edge1:o,edge2:l,edge3:h,edge4:c}){const d="number"==typeof s?s:e.defaultThickness,u="number"==typeof i?i:e.defaultKerf,p=z.find((e=>e.name()===o.kind));if(!p)throw new Error("Bad top edge");const g=z.find((e=>e.name()===l.kind));if(!g)throw new Error("Bad right edge");const f=z.find((e=>e.name()===h.kind));if(!f)throw new Error("Bad bottom edge");const m=z.find((e=>e.name()===c.kind));if(!m)throw new Error("Bad left edge");const v=p.thickness(d,o.params),b=g.thickness(d,l.params),w=f.thickness(d,h.params),y=m.thickness(d,c.params),T=a+b+y,k=r+v+w,x=E.shape().beginPath().moveTo(0,0).lineTo(T,0).lineTo(T,k).lineTo(0,k).closePath(),P=E.shape(),M=t?function(e,t,n,s,i,a){const r=e.split("\n"),o=r.reduce(((e,t)=>Math.max(e,t.length)),0),l="number"==typeof a?a:Math.min((s-5)/o*2,(i-5)/r.length),h=l/2,c=t+(s-h*o)/2,d=n+(i-l*r.length)/2,u=E.shape();for(let e=0;e<r.length;e++){const t=r[e];for(let n=0;n<t.length;n++)K(u,[c+h*n+.15*h,d+l*e+.15*l],.7*h,.7*l,t.charAt(n))}return u}(t,y,v,a,r,n):E.shape();let D=new B(d,u,x,P,M);return D=p.draw(D.setHome([0,0],0),T,d,{...o.params,cornerDistance1Delta:y,cornerDistance2Delta:b}),D=g.draw(D.setHome([T,0],90),k,d,{...l.params,cornerDistance1Delta:v,cornerDistance2Delta:w}),D=f.draw(D.setHome([T,k],180),T,d,{...h.params,cornerDistance1Delta:b,cornerDistance2Delta:y}),D=m.draw(D.setHome([0,k],270),k,d,{...c.params,cornerDistance1Delta:w,cornerDistance2Delta:v}),[D]}}class X extends H{name(){return"BoxPlain"}schema(){return{properties:{labels:{type:"boolean",metadata:{default:!1,title:"Labels"}},width:{type:"float64",metadata:{default:100,title:"Inner Width (units)"}},depth:{type:"float64",metadata:{default:100,title:"Inner Depth (units)"}},height:{type:"float64",metadata:{default:100,title:"Inner Height (units)"}},holeDistance:{type:"float64",metadata:{default:3,title:"Hole Distance",description:"Distance of mortises from edge (units)"}},play:{type:"float64",metadata:{default:0,title:"Play",description:"Extra space between fingers (units)"}},thicknessPlay:{type:"float64",metadata:{default:0,title:"Thickness Play",description:"Extra thickness added to mortise holes (units)"}}},metadata:{order:["labels","width","depth","height","holeDistance","play","thicknessPlay"]}}}generate(e,{labels:t,width:n,depth:s,height:i,holeDistance:a,play:r,thicknessPlay:o}){const{defaultThickness:l}=e,h=new Q,c=e=>({kind:"MortiseAndTenonJoint",params:{invert:e,width1:2*l,tenonLength:1,width2:2*l,holeDistance:a,play:r,thicknessPlay:o,cornerDistance:2*l,centerDistance:0}}),d=e=>({kind:"BoxJoint",params:{invert:e,width1:2*l,length1:1,width2:2*l,length2:1,play:r,cornerDistance:2*l,centerDistance:0}});return[...h.generate(e,{width:n,height:s,edge1:c(!1),edge2:c(!1),edge3:c(!1),edge4:c(!1),...t?{label:"Bottom"}:{}}),...h.generate(e,{width:s,height:i,edge1:{kind:"ButtJoint",params:{invert:!1,length1:0,length2:1}},edge2:d(!1),edge3:c(!0),edge4:d(!1),...t?{label:"Left"}:{}}),...h.generate(e,{width:s,height:i,edge1:{kind:"ButtJoint",params:{invert:!1,length1:0,length2:1}},edge2:d(!1),edge3:c(!0),edge4:d(!1),...t?{label:"Right"}:{}}),...h.generate(e,{width:n,height:i,edge1:{kind:"ButtJoint",params:{invert:!1,length1:0,length2:1}},edge2:d(!0),edge3:c(!0),edge4:d(!0),...t?{label:"Front"}:{}}),...h.generate(e,{width:n,height:i,edge1:{kind:"ButtJoint",params:{invert:!1,length1:0,length2:1}},edge2:d(!0),edge3:c(!0),edge4:d(!0),...t?{label:"Back"}:{}})]}}class G extends H{name(){return"BoxNested"}schema(){return{properties:{labels:{type:"boolean",metadata:{default:!1,title:"Labels"}},width:{type:"float64",metadata:{default:100,title:"Inner Width (units)"}},depth:{type:"float64",metadata:{default:100,title:"Inner Depth (units)"}},height:{type:"float64",metadata:{default:100,title:"Inner Height (units)"}},holeDistance:{type:"float64",metadata:{default:3,title:"Hole Distance",description:"Distance of mortises from edge (units)"}},play:{type:"float64",metadata:{default:0,title:"Play",description:"Extra space between fingers (units)"}},thicknessPlay:{type:"float64",metadata:{default:0,title:"Thickness Play",description:"Extra thickness added to mortise holes (units)"}}},metadata:{order:["labels","width","depth","height","holeDistance","play","thicknessPlay"]}}}generate(e,{labels:t,width:n,depth:s,height:i,holeDistance:a,play:r,thicknessPlay:o}){const{defaultThickness:l}=e,h=new Q,c=(e,t,n)=>({kind:"MortiseAndTenonJoint",params:{invert:e,width1:2*l,tenonLength:t,width2:2*l,holeDistance:a,play:r,thicknessPlay:o,cornerDistance:2*l,centerDistance:0,mortiseEdge:n}}),d=(e,t)=>({kind:"BoxJoint",params:{invert:e,width1:2*l,length1:t,width2:2*l,length2:t,play:r,cornerDistance:2*l,centerDistance:0}});return[...h.generate(e,{width:n,height:s,edge1:c(!1,2),edge2:c(!1,1),edge3:c(!1,2),edge4:c(!1,1),...t?{label:"Bottom"}:{}}),...h.generate(e,{width:s,height:i,edge1:{kind:"ButtJoint",params:{invert:!1,length1:0,length2:1}},edge2:d(!1,2),edge3:c(!0,1),edge4:d(!1,2),...t?{label:"Left"}:{}}),...h.generate(e,{width:s,height:i,edge1:{kind:"ButtJoint",params:{invert:!1,length1:0,length2:1}},edge2:d(!1,2),edge3:c(!0,1),edge4:d(!1,2),...t?{label:"Right"}:{}}),...h.generate(e,{width:n,height:i,edge1:{kind:"ButtJoint",params:{invert:!1,length1:0,length2:1}},edge2:d(!0,1),edge3:c(!0,1),edge4:d(!0,1),...t?{label:"Front"}:{}}),...h.generate(e,{width:n,height:i,edge1:{kind:"ButtJoint",params:{invert:!1,length1:0,length2:1}},edge2:d(!0,1),edge3:c(!0,1,{kind:"LegEdge",params:{flatWidth:.1,curveWidth:.15,curveAmount:.05,height:10}}),edge4:d(!0,1),...t?{label:"Inner Front"}:{}}),...h.generate(e,{width:n,height:i,edge1:{kind:"ButtJoint",params:{invert:!1,length1:0,length2:1}},edge2:d(!0,1),edge3:c(!0,1),edge4:d(!0,1),...t?{label:"Back"}:{}}),...h.generate(e,{width:n,height:i,edge1:{kind:"ButtJoint",params:{invert:!1,length1:0,length2:1}},edge2:d(!0,1),edge3:c(!0,1,{kind:"LegEdge",params:{flatWidth:.1,curveWidth:.15,curveAmount:.05,height:10}}),edge4:d(!0,1),...t?{label:"Inner Back"}:{}})]}}class Y extends H{name(){return"BoxCardstock"}schema(){const e=(e={})=>({discriminator:"kind",mapping:{none:{properties:{kind:{type:"string",metadata:{default:"none",title:"none"}},params:{properties:{},metadata:{order:[]}}},metadata:{order:["params"],untabParams:!0}},tuck:{properties:{kind:{type:"string",metadata:{default:"tuck",title:"tuck"}},params:{properties:{notchWidth:{type:"float64",metadata:{default:7,title:"Notch Width (units)"}},notchHeight:{type:"float64",metadata:{default:2,title:"Notch Height (units)"}}},metadata:{order:["notchWidth","notchHeight"]}}},metadata:{order:["params"],untabParams:!0}}},metadata:{default:"tuck",order:["none","tuck"],...e}});return{properties:{thickness:{type:"float64",nullable:!0,metadata:{default:.3,nullHint:"default",title:"Material Thickness (units)"}},kerf:{type:"float64",nullable:!0,metadata:{default:null,defaultNotNull:.1,nullHint:"default",title:"Kerf (units)",description:"Thickness of material removed by cutting tool"}},width:{type:"float64",metadata:{default:100,title:"Inner Width (units)"}},depth:{type:"float64",metadata:{default:20,title:"Inner Depth (units)"}},height:{type:"float64",metadata:{default:100,title:"Inner Height (units)"}},scorePadding:{type:"float64",metadata:{default:1,title:"Score Padding (units)"}},wrapConnection:{discriminator:"kind",mapping:{none:{properties:{kind:{type:"string",metadata:{default:"none",title:"none"}},params:{properties:{receiverWidth:{type:"float64",metadata:{default:20,title:"Receiver Width (units)"}}},metadata:{order:["receiverWidth"]}}},metadata:{order:["params"],untabParams:!0}},tabs:{properties:{kind:{type:"string",metadata:{default:"tabs",title:"tabs"}},params:{properties:{receiverWidth:{type:"float64",metadata:{default:10,title:"Receiver Width (units)"}},tabWidth:{type:"float64",metadata:{default:10,title:"Tab Width (units)"}},tabHeight:{type:"float64",metadata:{default:20,title:"Tab Height (units)"}},tabInnerCut:{type:"float64",metadata:{default:1,title:"Tab Inner Cut (units)"}},tabCount:{type:"float64",metadata:{default:2,title:"Tab Count"}}},metadata:{order:["receiverWidth","tabWidth","tabHeight","tabInnerCut","tabCount"]}}},metadata:{order:["params"],untabParams:!0}}},metadata:{default:"none",order:["none","tabs"],title:"Wrap Connection"}},topCover:e({title:"Top Cover"}),bottomCover:e({title:"Bottom Cover"})},metadata:{order:["thickness","kerf","width","depth","height","scorePadding","wrapConnection","topCover","bottomCover"]}}}generate(e,{thickness:t,kerf:n,width:s,depth:i,height:a,scorePadding:r,wrapConnection:o,topCover:l,bottomCover:h}){const c="number"==typeof t?t:e.defaultThickness,d="number"==typeof n?n:e.defaultKerf,u=s,p=a,g=0+u,f=i+c,m=a,v=g+f,b=s+c,w=a,y=v+b,T=i+c,k=a,x=i+c,P=r;let M=E.shape().rect(0,0,u,p).rect(g,0,f,m).rect(v,0,b,w).rect(y,0,T,k),D=E.shape(),S=E.shape().moveTo(0+u,0+P).lineTo(0+u,0+p-P).moveTo(g+f,0+P).lineTo(g+f,0+m-P).moveTo(y,0+P).lineTo(y,0+k-P);const C=(e,{notchWidth:t,notchHeight:n})=>{const s=()=>e?E.shape():E.shape().translate(0,p).scale(1,-1);M=M.combine(s().rect(0,0,u,-x)).union(),M=M.combine(s().moveTo(0,0-x).bezierCurveTo(0,0-x-.9*i,0,0-x-.9*i,0+.9*i,0-x-.9*i).lineTo(0+u-.9*i,0-x-.9*i).bezierCurveTo(0+u,0-x-.9*i,0+u,0-x-.9*i,0+u,0-x).closePath()).union(),M=M.combine(s().rect(g,0,f-c,-i).combine(s().moveTo(g,0).lineTo(g+.05*f,0-i).lineTo(g,0-i).closePath()).difference().combine(s().moveTo(g+f-c,0).lineTo(g+f-c-.1*t,0-t).lineTo(g+f-c-.2*t,0-t).lineTo(g+f-c-.2*t-.1*(i-t),0-i).lineTo(g+f-c,0-i).closePath()).difference()).union(),M=M.combine(s().rect(y+c,0,T-c,-i).combine(s().moveTo(y+c,0).lineTo(y+c+.1*t,0-t).lineTo(y+c+.2*t,0-t).lineTo(y+c+.2*t+.1*(i-t),0-i).lineTo(y+c,0-i).closePath()).difference().combine(s().moveTo(y+T,0).lineTo(y+T-.05*i,0-i).lineTo(y+T,0-i).closePath()).difference()).union(),D=D.combine(s().moveTo(0,0-x).lineTo(0+t-1,0-x).bezierCurveTo(0+t,0-x,0+t,0-x,0+t,0-x+1).lineTo(0+t,0-x+n).moveTo(0+u,0-x).lineTo(0+u-t+1,0-x).bezierCurveTo(0+u-t,0-x,0+u-t,0-x,0+u-t,0-x+1).lineTo(0+u-t,0-x+n)).union(),S=S.combine(s().moveTo(0+P,0-c).lineTo(0+u-P,0-c).moveTo(0+P+t,0-x).lineTo(0+u-P-t,0-x).moveTo(g+P,0).lineTo(g+f-c-P,0).moveTo(y+c+P,0).lineTo(y+T-P,0)).union()};switch(l.kind){case"none":break;case"tuck":C(!0,l.params);break;default:throw new Error(`Unknown top cover: ${l.kind}`)}switch(h.kind){case"none":break;case"tuck":C(!1,h.params);break;default:throw new Error(`Unknown bottom cover: ${h.kind}`)}const V=e=>{M=M.combine(E.shape().moveTo(0,0).bezierCurveTo(-e,0,-e,0,-e,Math.min(e,a/2-.5)).lineTo(-e,Math.max(a-e,a/2+.5)).bezierCurveTo(-e,a,-e,a,0,a).closePath()).union()};switch(o.kind){case"none":{const{receiverWidth:e}=o.params;e>0&&(V(e),S=S.combine(E.shape().moveTo(0,0+P).lineTo(0,0+p-P)).union());break}case"tabs":{const{receiverWidth:e,tabWidth:t,tabHeight:n,tabInnerCut:s,tabCount:i}=o.params;e>0&&V(e);for(let r=0;r<i;r++){const o=a*r/i,l=a*(r+1)/i,h=Math.min(l-o,n),d=(o+l-h)/2,u=h/5,p=.1*t,g=.1*u;M=M.combine(E.shape().moveTo(y+T,d+s).lineTo(y+T+c,d+s).lineTo(y+T+c,d).lineTo(y+T+c+t,d).lineTo(y+T+c+t,d+h).lineTo(y+T+c,d+h).lineTo(y+T+c,d+h-s).lineTo(y+T,d+h-s).closePath().combine(E.shape().moveTo(y+T+c,d).lineTo(y+T+c+t-p,d+u-g).bezierCurveTo(y+T+c+t,d+u,y+T+c+t,d+u,y+T+c+t,d+u+g).lineTo(y+T+c+t,d).closePath()).difference().combine(E.shape().moveTo(y+T+c,d+h).lineTo(y+T+c+t-p,d+h-u+g).bezierCurveTo(y+T+c+t,d+h-u,y+T+c+t,d+h-u,y+T+c+t,d+h-u-g).lineTo(y+T+c+t,d+h).closePath()).difference()).union(),e>0&&(S=S.combine(E.shape().moveTo(0,0===o?P:o).lineTo(0,d-P).moveTo(0,d+h+P).lineTo(0,l===a?l-P:l).moveTo(y+T,d+s+P).lineTo(y+T,d+h-s-P)).union(),D=D.combine(E.shape().moveTo(0,d).bezierCurveTo(0-c,d,0-c,d,0-c,d+c).lineTo(0-c,d+h-c).bezierCurveTo(0-c,d+h,0-c,d+h,0,d+h)).union())}break}default:throw new Error(`Unknown wrap connection: ${o.kind}`)}const I=new B(c,d,M,D,S);return[B.union(I,I)]}}class Z extends H{name(){return"KerfTester"}schema(){return{properties:{labels:{type:"boolean",metadata:{default:!0,title:"Labels"}},width:{type:"float64",metadata:{default:30,title:"Outer Width (units)"}},height:{type:"float64",metadata:{default:15,title:"Outer Height (units)"}},play:{type:"float64",metadata:{default:0,title:"Play",description:"Extra space between fingers (units)"}},testCount:{type:"int32",metadata:{default:8,title:"Number of tests"}},kerfStart:{type:"float64",metadata:{default:.08,title:"Kerf start value (units)"}},kerfIncrement:{type:"float64",metadata:{default:.02,title:"Kerf increment value (per test)"}}},metadata:{order:["labels","width","height","play","testCount","kerfStart","kerfIncrement"]}}}generate(e,{labels:t,width:n,height:s,play:i,testCount:a,kerfStart:r,kerfIncrement:o}){const{defaultThickness:l}=e,h=new Q,c=e=>({kind:"BoxJoint",params:{invert:e,width1:2*l,length1:1,width2:2*l,length2:1,play:i,cornerDistance:2*l,centerDistance:0}}),d=[];for(let i=0;i<a;i++){const a=r+i*o;d.push(...h.generate(e,{width:n,height:s,kerf:a,edge1:c(!1),edge2:{kind:"ButtJoint",params:{invert:!1,length1:0,length2:1}},edge3:{kind:"ButtJoint",params:{invert:!1,length1:0,length2:1}},edge4:{kind:"ButtJoint",params:{invert:!1,length1:0,length2:1}},...t?{label:a.toFixed(3)}:{}}),...h.generate(e,{width:n,height:s,kerf:a,edge1:{kind:"ButtJoint",params:{invert:!1,length1:0,length2:1}},edge2:{kind:"ButtJoint",params:{invert:!1,length1:0,length2:1}},edge3:c(!0),edge4:{kind:"ButtJoint",params:{invert:!1,length1:0,length2:1}},...t?{label:a.toFixed(3)}:{}}))}return d}}const ee=[new G,new X,new Y,new Z,new Q];exports.ApplyKerf=C,exports.BoxCardstock=Y,exports.BoxJoint=$,exports.BoxNested=G,exports.BoxPlain=X,exports.ButtJoint=R,exports.DocumentBase=V,exports.DocumentSVG=F,exports.EdgeBase=q,exports.GeneratorBase=H,exports.JointBase=W,exports.KerfTester=Z,exports.LegEdge=J,exports.MortiseAndTenonJoint=A,exports.Rectangle=Q,exports.SettingsTypeDef={properties:{defaultThickness:{type:"float64",metadata:{default:3,title:"Default Material Thickness (units)"}},defaultKerf:{type:"float64",metadata:{default:.1,title:"Default Kerf (units)",description:"Thickness of material removed by cutting tool"}},units:{enum:["mm","in"],metadata:{default:"mm",title:"Units"}},fileFormat:{enum:["svg"],metadata:{default:"svg",title:"File Format"}},debug:{type:"boolean",metadata:{default:!1,title:"Debug"}}},metadata:{title:"Settings",order:["defaultThickness","defaultKerf","units","fileFormat","debug"],startHidden:!0}},exports.Shape=x,exports.Surface=B,exports.allEdges=z,exports.allEdgesTypeDef=U,exports.allGenerators=ee,exports.allJoints=j,exports.boxJointFingerSpacer=L,exports.edgeListTypeDef=N,exports.exportDocument=function(e){const{fileFormat:t}=e;if("svg"===t)return new F(e);throw new Error(`Unknown export file format: ${t}`)},exports.geo=S,exports.polybool=E;
