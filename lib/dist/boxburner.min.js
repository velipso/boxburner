function e(e,t,n){return e+(t-e)*n}function t(t,n,s){return[e(t[0],n[0],s),e(t[1],n[1],s)]}class n{}class s extends n{constructor(e=1e-10){super(),this.epsilon=e}snap0(e){return Math.abs(e)<this.epsilon?0:e}snap01(e){return Math.abs(e)<this.epsilon?0:Math.abs(1-e)<this.epsilon?1:e}isCollinear(e,t,n){const s=e[0]-t[0],i=e[1]-t[1],a=t[0]-n[0],o=t[1]-n[1];return Math.abs(s*o-a*i)<this.epsilon}solveCubicNormalized(e,t,n){const s=e/3,i=t/3,a=s*s-i,o=s*(s*s-t/2)+n/2;if(Math.abs(o)<this.epsilon&&Math.abs(a)<this.epsilon)return[-s];const r=s*(s*(4*s*n-i*t)-2*t*n)+4*i*i*i+n*n;if(Math.abs(r)<this.epsilon){const t=Math.sqrt(a);return o>0?[-2*t-e/3,t-e/3]:[-t-e/3,2*t-e/3]}const l=a*a*a,h=o*o;if(h<l){const e=(o<0?-1:1)*Math.sqrt(h/l),t=Math.acos(e),n=-2*Math.sqrt(a);return[n*Math.cos(t/3)-s,n*Math.cos((t+2*Math.PI)/3)-s,n*Math.cos((t-2*Math.PI)/3)-s].sort(((e,t)=>e-t))}{const e=(o<0?1:-1)*Math.pow(Math.abs(o)+Math.sqrt(h-l),1/3);return[e+(Math.abs(e)>=this.epsilon?a/e:0)-s]}}solveCubic(e,t,n,s){if(Math.abs(e)<this.epsilon){if(Math.abs(t)<this.epsilon)return Math.abs(n)<this.epsilon?Math.abs(s)<this.epsilon?[0]:[]:[-s/n];const e=2*t;let i=n*n-4*t*s;return Math.abs(i)<this.epsilon?[-n/e]:i>0?(i=Math.sqrt(i),[(-n+i)/e,(-n-i)/e].sort(((e,t)=>e-t))):[]}return this.solveCubicNormalized(t/e,n/e,s/e)}isEqualVec2(e,t){return Math.abs(e[0]-t[0])<this.epsilon&&Math.abs(e[1]-t[1])<this.epsilon}compareVec2(e,t){return Math.abs(t[0]-e[0])<this.epsilon?Math.abs(t[1]-e[1])<this.epsilon?0:e[1]<t[1]?-1:1:e[0]<t[0]?-1:1}}class i{constructor(e){this.tValues=[],this.geo=e}addArray(e){for(const t of e)this.tValues.push(t);return this}add(e){if((e=this.geo.snap01(e))<0||e>1)return this;for(const t of this.tValues)if(0===this.geo.snap0(e-t))return this;return this.tValues.push(e),this}list(){return this.tValues.sort(((e,t)=>e-t)),this.tValues}}class a{constructor(e,t){this.tValuePairs=[],this.allowOutOfRange=e,this.geo=t}add(e,t){if(e=this.geo.snap01(e),t=this.geo.snap01(t),!this.allowOutOfRange&&(e<0||e>1||t<0||t>1))return this;for(const n of this.tValuePairs)if(0===this.geo.snap0(e-n[0])||0===this.geo.snap0(t-n[1]))return this;return this.tValuePairs.push([e,t]),this}list(){return this.tValuePairs.sort(((e,t)=>e[0]-t[0])),this.tValuePairs}done(){return this.tValuePairs.length<=0?null:{kind:"tValuePairs",tValuePairs:this.list()}}}class o{}class r extends o{constructor(e,t,n){super(),this.p0=e,this.p1=t,this.geo=n}copy(){return new r(this.p0,this.p1,this.geo)}isEqual(e){return this.geo.isEqualVec2(this.p0,e.p0)&&this.geo.isEqualVec2(this.p1,e.p1)}start(){return this.p0}start2(){return this.p1}end2(){return this.p0}end(){return this.p1}setStart(e){this.p0=e}setEnd(e){this.p1=e}point(e){const t=this.p0,n=this.p1;return 0===e?t:1===e?n:[t[0]+(n[0]-t[0])*e,t[1]+(n[1]-t[1])*e]}split(e){if(e.length<=0)return[this];const t=e.map((e=>this.point(e)));t.push(this.p1);const n=[];let s=this.p0;for(const e of t)n.push(new r(s,e,this.geo)),s=e;return n}reverse(){return new r(this.p1,this.p0,this.geo)}boundingBox(){const e=this.p0,t=this.p1;return[[Math.min(e[0],t[0]),Math.min(e[1],t[1])],[Math.max(e[0],t[0]),Math.max(e[1],t[1])]]}pointOn(e){return this.geo.isCollinear(e,this.p0,this.p1)}draw(e){const t=this.p0,n=this.p1;return e.moveTo(t[0],t[1]),e.lineTo(n[0],n[1]),e}}class l extends o{constructor(e,t,n,s,i){super(),this.p0=e,this.p1=t,this.p2=n,this.p3=s,this.geo=i}copy(){return new l(this.p0,this.p1,this.p2,this.p3,this.geo)}isEqual(e){return this.geo.isEqualVec2(this.p0,e.p0)&&this.geo.isEqualVec2(this.p1,e.p1)&&this.geo.isEqualVec2(this.p2,e.p2)&&this.geo.isEqualVec2(this.p3,e.p3)}start(){return this.p0}start2(){return this.p1}end2(){return this.p2}end(){return this.p3}setStart(e){this.p0=e}setEnd(e){this.p3=e}point(e){const t=this.p0,n=this.p1,s=this.p2,i=this.p3;if(0===e)return t;if(1===e)return i;const a=(1-e)*(1-e),o=e*e,r=a*(1-e),l=3*a*e,h=3*o*(1-e),c=o*e;return[t[0]*r+n[0]*l+s[0]*h+i[0]*c,t[1]*r+n[1]*l+s[1]*h+i[1]*c]}split(e){if(e.length<=0)return[this];const n=[],s=(e,s)=>{const[i,a,o,r]=e,h=t(i,a,s),c=t(a,o,s),u=t(o,r,s),d=t(h,c,s),p=t(c,u,s),f=t(d,p,s);return n.push(new l(i,h,d,f,this.geo)),[f,p,u,r]};let i=[this.p0,this.p1,this.p2,this.p3],a=0;for(const t of e)i=s(i,(t-a)/(1-a)),a=t;return n.push(new l(i[0],i[1],i[2],i[3],this.geo)),n}reverse(){return new l(this.p3,this.p2,this.p1,this.p0,this.geo)}getCubicCoefficients(e){const t=this.p0[e],n=this.p1[e],s=this.p2[e];return[this.p3[e]-3*s+3*n-t,3*s-6*n+3*t,3*n-3*t,t]}boundingTValues(){const e=new i(this.geo),t=(t,n,s,i)=>{const a=3*i-9*s+9*n-3*t,o=6*t-12*n+6*s,r=3*n-3*t;if(0===this.geo.snap0(a))e.add(-r/o);else{const t=o*o-4*a*r;if(t>=0){const n=Math.sqrt(t);e.add((-o+n)/(2*a)),e.add((-o-n)/(2*a))}}return e},n=this.p0,s=this.p1,a=this.p2,o=this.p3;return t(n[0],s[0],a[0],o[0]),t(n[1],s[1],a[1],o[1]),e.list()}inflectionTValues(){const e=new i(this.geo);e.addArray(this.boundingTValues());const t=this.p0,n=this.p1,s=this.p2,a=this.p3,o=3*(n[0]-t[0]),r=3*(n[1]-t[1]),l=6*(s[0]-n[0]),h=6*(s[1]-n[1]),c=3*(a[0]-s[0]),u=3*(a[1]-s[1]),d=6*(s[0]-2*n[0]+t[0]),p=6*(s[1]-2*n[1]+t[1]),f=o-l+c,g=r-h+u,m=l-2*o,v=h-2*r,b=6*(a[0]-2*s[0]+n[0])-d,w=6*(a[1]-2*s[1]+n[1])-p,T=f*w-g*b,y=f*p+m*w-g*d-v*b,k=m*p+o*w-v*d-r*b,P=o*p-r*d;for(const t of this.geo.solveCubic(T,y,k,P))e.add(t);return e.list()}boundingBox(){const e=this.p0,t=this.p3,n=[Math.min(e[0],t[0]),Math.min(e[1],t[1])],s=[Math.max(e[0],t[0]),Math.max(e[1],t[1])];for(const e of this.boundingTValues()){const t=this.point(e);n[0]=Math.min(n[0],t[0]),n[1]=Math.min(n[1],t[1]),s[0]=Math.max(s[0],t[0]),s[1]=Math.max(s[1],t[1])}return[n,s]}mapXtoT(e,t=!1){if(0===this.geo.snap0(this.p0[0]-e))return 0;if(0===this.geo.snap0(this.p3[0]-e))return 1;const n=this.p0[0]-e,s=this.p1[0]-e,i=this.p2[0]-e,a=[this.p3[0]-e-3*i+3*s-n,3*i-6*s+3*n,3*s-3*n,n];for(const e of this.geo.solveCubic(a[0],a[1],a[2],a[3])){const t=this.geo.snap01(e);if(t>=0&&t<=1)return e}if(t||e>=Math.min(this.p0[0],this.p3[0])&&e<=Math.max(this.p0[0],this.p3[0]))for(let e=0;e<4;e++){let e=-1;for(let t=0;t<4;t++)0!==a[t]&&(e<0||Math.abs(a[t])<Math.abs(a[e]))&&(e=t);if(e<0)return 0;a[e]=0;for(const e of this.geo.solveCubic(a[0],a[1],a[2],a[3])){const t=this.geo.snap01(e);if(t>=0&&t<=1)return e}}return!1}mapXtoY(e,t=!1){const n=this.mapXtoT(e,t);return!1!==n&&this.point(n)[1]}pointOn(e){if(this.geo.isEqualVec2(this.p0,e)||this.geo.isEqualVec2(this.p3,e))return!0;const t=this.mapXtoY(e[0]);return!1!==t&&0===this.geo.snap0(t-e[1])}toLine(){const e=this.p0,t=this.p1,n=this.p2,s=this.p3;return 0===this.geo.snap0(e[0]-t[0])&&0===this.geo.snap0(e[0]-n[0])&&0===this.geo.snap0(e[0]-s[0])||0===this.geo.snap0(e[1]-t[1])&&0===this.geo.snap0(e[1]-n[1])&&0===this.geo.snap0(e[1]-s[1])?new r(e,s,this.geo):null}draw(e){const t=this.p0,n=this.p1,s=this.p2,i=this.p3;return e.moveTo(t[0],t[1]),e.bezierCurveTo(n[0],n[1],s[0],s[1],i[0],i[1]),e}}function h(e,t){const n=t.p1[0]-t.p0[0],s=t.p1[1]-t.p0[1];return((e[0]-t.p0[0])*n+(e[1]-t.p0[1])*s)/(n*n+s*s)}function c(e,t,n,s){const i=e.geo,o=e.p0,r=e.p1,l=r[1]-o[1],h=o[0]-r[0];if(0===i.snap0(h)){const e=t.mapXtoT(o[0],!1);if(!1===e)return null;const r=(t.point(e)[1]-o[1])/l,h=new a(n,i);return s?h.add(e,r):h.add(r,e),h.done()}const c=l*o[0]+h*o[1],u=t.getCubicCoefficients(0),d=t.getCubicCoefficients(1),p=l*u[0]+h*d[0],f=l*u[1]+h*d[1],g=l*u[2]+h*d[2],m=l*u[3]+h*d[3]-c,v=i.solveCubic(p,f,g,m),b=new a(n,i);if(0===i.snap0(l))for(const e of v){const t=u[0]*e*e*e+u[1]*e*e+u[2]*e+u[3],n=(o[0]-t)/h;s?b.add(e,n):b.add(n,e)}else for(const e of v){const t=(d[0]*e*e*e+d[1]*e*e+d[2]*e+d[3]-o[1])/l;s?b.add(e,t):b.add(t,e)}return b.done()}function u(e,t,n){if(e instanceof r){if(t instanceof r)return function(e,t,n){const s=e.geo,i=e.p0,o=e.p1,r=t.p0,l=t.p1,c=o[0]-i[0],u=o[1]-i[1],d=l[0]-r[0],p=l[1]-r[1],f=c*p-u*d;if(0===s.snap0(f)){if(!s.isCollinear(i,o,r))return null;const n=h(t.p0,e),a=h(t.p1,e),l=s.snap01(Math.min(n,a)),c=s.snap01(Math.max(n,a));if(c<0||l>1)return null;const u=h(e.p0,t),d=h(e.p1,t),p=s.snap01(Math.min(u,d)),f=s.snap01(Math.max(u,d));return f<0||p>1?null:{kind:"tRangePairs",tStart:[Math.max(0,l),Math.max(0,p)],tEnd:[Math.min(1,c),Math.min(1,f)]}}const g=i[0]-r[0],m=i[1]-r[1];return new a(n,s).add((d*m-p*g)/f,(c*m-u*g)/f).done()}(e,t,n);if(t instanceof l)return c(e,t,n,!1)}else if(e instanceof l){if(t instanceof r)return c(t,e,n,!0);if(t instanceof l)return function(e,t,n){const s=e.geo;if(s.isEqualVec2(e.p0,t.p0))return s.isEqualVec2(e.p3,t.p3)?s.isEqualVec2(e.p1,t.p1)&&s.isEqualVec2(e.p2,t.p2)?{kind:"tRangePairs",tStart:[0,0],tEnd:[1,1]}:{kind:"tValuePairs",tValuePairs:[[0,0],[1,1]]}:{kind:"tValuePairs",tValuePairs:[[0,0]]};if(s.isEqualVec2(e.p0,t.p3))return{kind:"tValuePairs",tValuePairs:[[0,1]]};if(s.isEqualVec2(e.p3,t.p0))return{kind:"tValuePairs",tValuePairs:[[1,0]]};if(s.isEqualVec2(e.p3,t.p3))return{kind:"tValuePairs",tValuePairs:[[1,1]]};const i=new a(n,s),o=(e,t,n,a,r,l)=>{if(!function(e,t){const[n,s]=e,[i,a]=t;return!(n[0]>a[0]||s[0]<i[0]||n[1]>a[1]||s[1]<i[1])}(e.boundingBox(),a.boundingBox()))return;const h=(t+n)/2,c=(r+l)/2;if(0===s.snap0(n-t)&&0===s.snap0(l-r))return void i.add(h,c);const[u,d]=e.split([.5]),[p,f]=a.split([.5]);o(u,t,h,p,r,c),o(d,h,n,p,r,c),o(u,t,h,f,c,l),o(d,h,n,f,c,l)};return o(e,0,1,t,0,1),i.done()}(e,t,n)}throw new Error("PolyBool: Unknown segment instance in segmentsIntersect")}class d{constructor(e,t=null,n=!1,s=null){var i,a,o;this.otherFill=null,this.id=null!==(i=null==s?void 0:s.segmentId())&&void 0!==i?i:-1,this.data=e,this.myFill={above:null!==(a=null==t?void 0:t.above)&&void 0!==a?a:null,below:null!==(o=null==t?void 0:t.below)&&void 0!==o?o:null},this.closed=n}}class p extends d{}class f extends d{}function g(e,t){if(e instanceof p)return new p(e.data,e.myFill,e.closed,t);if(e instanceof f)return new f(e.data,e.myFill,e.closed,t);throw new Error("PolyBool: Unknown SegmentBool in copySegmentBool")}class m{constructor(e,t,n,s){this.status=null,this.isStart=e,this.p=t,this.seg=n,this.primary=s}}class v{constructor(){this.nodes=[]}remove(e){const t=this.nodes.indexOf(e);t>=0&&this.nodes.splice(t,1)}getIndex(e){return this.nodes.indexOf(e)}isEmpty(){return this.nodes.length<=0}getHead(){return this.nodes[0]}removeHead(){this.nodes.shift()}insertBefore(e,t){this.findTransition(e,t).insert(e)}findTransition(e,t){var n,s;let i=0,a=this.nodes.length;for(;i<a;){const n=i+a>>1;o=this.nodes[n],t(e)-t(o)>0?a=n:i=n+1}var o;return{before:i<=0?null:null!==(n=this.nodes[i-1])&&void 0!==n?n:null,after:null!==(s=this.nodes[i])&&void 0!==s?s:null,insert:e=>(this.nodes.splice(i,0,e),e)}}}class b{constructor(e,t,n=null){this.events=new v,this.status=new v,this.currentPath=[],this.selfIntersection=e,this.geo=t,this.log=n}compareEvents(e,t,n,s,i,a,o,l){const h=this.geo.compareVec2(t,a);return 0!==h?h:s instanceof r&&l instanceof r&&this.geo.isEqualVec2(n,o)?0:e!==i?e?1:-1:this.compareSegments(l,s)}addEvent(e){this.events.insertBefore(e,(t=>t===e?0:this.compareEvents(e.isStart,e.p,e.other.p,e.seg.data,t.isStart,t.p,t.other.p,t.seg.data)))}divideEvent(e,t,n){var s,i;null===(s=this.log)||void 0===s||s.segmentDivide(e.seg,n);const[a,o]=e.seg.data.split([t]);a.setEnd(n),o.setStart(n);const h=o instanceof r?new p(o,e.seg.myFill,e.seg.closed,this.log):o instanceof l?new f(o,e.seg.myFill,e.seg.closed,this.log):null;if(!h)throw new Error("PolyBool: Unknown segment data in divideEvent");return this.events.remove(e.other),e.seg.data=a,null===(i=this.log)||void 0===i||i.segmentChop(e.seg),e.other.p=n,this.addEvent(e.other),this.addSegment(h,e.primary)}beginPath(){this.currentPath=[]}closePath(){for(const e of this.currentPath)e.closed=!0}addSegment(e,t){const n=new m(!0,e.data.start(),e,t),s=new m(!1,e.data.end(),e,t);return n.other=s,s.other=n,this.addEvent(n),this.addEvent(s),n}addLine(e,t,n=!0){const s=this.geo.compareVec2(e,t);if(0===s)return;const i=new p(new r(s<0?e:t,s<0?t:e,this.geo),null,!1,this.log);this.currentPath.push(i),this.addSegment(i,n)}addCurve(e,t,n,s,i=!0){const a=new l(e,t,n,s,this.geo),o=a.split(a.inflectionTValues());for(const e of o){const t=this.geo.compareVec2(e.start(),e.end());if(0===t)continue;const n=e.toLine();if(n)this.addLine(n.p0,n.p1,i);else{const n=new f(t<0?e:e.reverse(),null,!1,this.log);this.currentPath.push(n),this.addSegment(n,i)}}}compareSegments(e,t){let n=e.start(),s=t.start2();const i=t.start();if(t.pointOn(n)){if(n=e.start2(),t.pointOn(n)){if(e instanceof r){if(t instanceof r)return 0;t instanceof l&&(n=e.point(.5))}e instanceof l&&(n=e.end())}if(t instanceof l&&0===this.geo.snap0(n[0]-i[0])&&0===this.geo.snap0(s[0]-i[0]))return Math.sign(i[1]-n[1])}else{if(t instanceof l){const e=t.mapXtoY(n[0],!0);if(!1!==e)return Math.sign(e-n[1])}if(e instanceof l){const n=u(e,t,!0);if(n&&"tValuePairs"===n.kind)for(const t of n.tValuePairs){const n=this.geo.snap01(t[0]);if(n>0&&n<1){s=e.point(n);break}}}}const[a,o]=n,[h,c]=s,[d,p]=i;return Math.sign((h-a)*(p-o)-(c-o)*(d-a))}statusFindSurrounding(e){return this.status.findTransition(e,(t=>{if(e===t)return 0;const n=this.compareSegments(e.seg.data,t.seg.data);return 0===n?-1:n}))}checkIntersection(e,t){var n;const s=e.seg,i=t.seg;null===(n=this.log)||void 0===n||n.checkIntersection(s,i);const a=u(s.data,i.data,!1);if(null===a)return null;if("tRangePairs"===a.kind){const{tStart:[n,o],tEnd:[r,l]}=a;if(1===n&&1===r&&0===o&&0===l||0===n&&0===r&&1===o&&1===l)return null;if(0===n&&1===r&&0===o&&1===l)return t;const h=s.data.start(),c=s.data.end(),u=i.data.end();return 0===n&&0===o?(1===r?this.divideEvent(t,l,c):this.divideEvent(e,r,u),t):(o>0&&o<1&&(1===r&&1===l||(1===r?this.divideEvent(t,l,c):this.divideEvent(e,r,u)),this.divideEvent(t,o,h)),null)}if("tValuePairs"===a.kind){if(a.tValuePairs.length<=0)return null;let n=a.tValuePairs[0];for(let e=1;e<a.tValuePairs.length&&(0===n[0]&&0===n[1]||0===n[0]&&1===n[1]||1===n[0]&&0===n[1]||1===n[0]&&1===n[1]);e++)n=a.tValuePairs[e];const[o,r]=n,l=0===r?i.data.start():1===r?i.data.end():0===o?s.data.start():1===o?s.data.end():s.data.point(o);return o>0&&o<1&&this.divideEvent(e,o,l),r>0&&r<1&&this.divideEvent(t,r,l),null}throw new Error("PolyBool: Unknown intersection type")}calculate(){var e,t,n,s,i,a,o,r;const l=[];for(;!this.events.isEmpty();){const r=this.events.getHead();if(null===(e=this.log)||void 0===e||e.vert(r.p[0]),r.isStart){null===(t=this.log)||void 0===t||t.segmentNew(r.seg,r.primary);const e=this.statusFindSurrounding(r),o=e.before,l=e.after;null===(n=this.log)||void 0===n||n.tempStatus(r.seg,!!o&&o.seg,!!l&&l.seg);const h=()=>{if(o){const e=this.checkIntersection(r,o);if(e)return e}return l?this.checkIntersection(r,l):null},c=h();if(c){if(this.selfIntersection){let e;e=null===r.seg.myFill.below?r.seg.closed:r.seg.myFill.above!==r.seg.myFill.below,e&&(c.seg.myFill.above=!c.seg.myFill.above)}else c.seg.otherFill=r.seg.myFill;null===(s=this.log)||void 0===s||s.segmentUpdate(c.seg),this.events.remove(r.other),this.events.remove(r)}if(this.events.getHead()!==r){null===(i=this.log)||void 0===i||i.rewind(r.seg);continue}if(this.selfIntersection){let e;e=null===r.seg.myFill.below?r.seg.closed:r.seg.myFill.above!==r.seg.myFill.below,r.seg.myFill.below=!!l&&l.seg.myFill.above,r.seg.myFill.above=e?!r.seg.myFill.below:r.seg.myFill.below}else if(null===r.seg.otherFill){let e;if(l)if(r.primary===l.primary){if(null===l.seg.otherFill)throw new Error("PolyBool: Unexpected state of otherFill (null)");e=l.seg.otherFill.above}else e=l.seg.myFill.above;else e=!1;r.seg.otherFill={above:e,below:e}}null===(a=this.log)||void 0===a||a.status(r.seg,!!o&&o.seg,!!l&&l.seg),r.other.status=e.insert(r)}else{const e=r.status;if(null===e)throw new Error("PolyBool: Zero-length segment detected; your epsilon is probably too small or too large");const t=this.status.getIndex(e);if(t>0&&t<this.status.nodes.length-1){const e=this.status.nodes[t-1],n=this.status.nodes[t+1];this.checkIntersection(e,n)}if(null===(o=this.log)||void 0===o||o.statusRemove(e.seg),this.status.remove(e),!r.primary){if(!r.seg.otherFill)throw new Error("PolyBool: Unexpected state of otherFill (null)");const e=r.seg.myFill;r.seg.myFill=r.seg.otherFill,r.seg.otherFill=e}l.push(r.seg)}this.events.removeHead()}return null===(r=this.log)||void 0===r||r.done(),l}}function w(e,t,n){const s=[];for(const i of e){const e=t[(i.myFill.above?8:0)+(i.myFill.below?4:0)+(i.otherFill&&i.otherFill.above?2:0)+(i.otherFill&&i.otherFill.below?1:0)],a=!!(1&e),o=!!(2&e);if(!i.closed&&0!==e||i.closed&&a!==o){const e={above:a,below:o};if(i instanceof p)s.push(new p(i.data,e,i.closed,n));else{if(!(i instanceof f))throw new Error("PolyBool: Unknown SegmentBool type in SegmentSelector");s.push(new f(i.data,e,i.closed,n))}}}return null==n||n.selected(s),s}class T{static union(e,t){return w(e,[4,2,1,0,2,2,0,0,1,0,1,0,0,0,0,0],t)}static intersect(e,t){return w(e,[0,0,0,4,0,2,0,2,0,0,1,1,4,2,1,0],t)}static difference(e,t){return w(e,[4,0,0,0,2,0,2,0,1,1,0,0,0,1,2,0],t)}static differenceRev(e,t){return w(e,[4,2,1,0,0,0,1,1,0,2,0,2,0,0,0,0],t)}static xor(e,t){return w(e,[4,2,1,0,2,0,0,1,1,0,0,2,0,1,2,0],t)}}function y(e,t,n){return e!==t&&(e instanceof r&&t instanceof r?function(e,t,n){return!!n.isCollinear(e.p0,e.p1,t.p1)&&new r(e.p0,t.p1,n)}(e,t,n):e instanceof l&&t instanceof l&&function(e,t,n){if(n.isCollinear(e.p2,e.p3,t.p1)){const s=t.p1[0]-e.p2[0],i=t.p1[1]-e.p2[1],a=Math.abs(s)>Math.abs(i)?(e.p3[0]-e.p2[0])/s:(e.p3[1]-e.p2[1])/i,o=n.snap01(a);if(0!==o&&1!==o){const s=new l(e.p0,[e.p0[0]+(e.p1[0]-e.p0[0])/a,e.p0[1]+(e.p1[1]-e.p0[1])/a],[t.p2[0]-a*(t.p3[0]-t.p2[0])/(1-a),t.p2[1]-a*(t.p3[1]-t.p2[1])/(1-a)],t.p3,n),[i,o]=s.split([a]);if(i.isEqual(e)&&o.isEqual(t))return s}}return!1}(e,t,n))}function k(e,t,n){const s=[],i=[],a=[];for(const o of e){let l=o.data;const h=o.closed,c=h?s:i,u=l.start(),d=l.end(),p=e=>{null==n||n.chainReverse(e,h);const t=[];for(const n of c[e].segs)t.unshift(n.reverse());return c[e]={segs:t,fill:!c[e].fill},t};if(l instanceof r&&t.isEqualVec2(u,d)){console.warn("PolyBool: Warning: Zero-length segment detected; your epsilon is probably too small or too large");continue}null==n||n.chainStart({seg:l,fill:!!o.myFill.above},h);const f={index:0,matchesHead:!1,matchesPt1:!1},g={index:0,matchesHead:!1,matchesPt1:!1};let m=f;function v(e,t,n){return m&&(m.index=e,m.matchesHead=t,m.matchesPt1=n),m===f?(m=g,!1):(m=null,!0)}for(let b=0;b<c.length;b++){const w=c[b].segs,T=w[0].start(),k=w[w.length-1].end();if(t.isEqualVec2(T,u)){if(v(b,!0,!0))break}else if(t.isEqualVec2(T,d)){if(v(b,!0,!1))break}else if(t.isEqualVec2(k,u)){if(v(b,!1,!0))break}else if(t.isEqualVec2(k,d)&&v(b,!1,!1))break}if(m===f){const P=!!o.myFill.above;c.push({segs:[l],fill:P}),null==n||n.chainNew({seg:l,fill:P},h)}else if(m===g){const M=f.index;null==n||n.chainMatch(M,h);const{segs:x,fill:D}=c[M];if(f.matchesHead?f.matchesPt1?(l=l.reverse(),null==n||n.chainAddHead(M,{seg:l,fill:D},h),x.unshift(l)):(null==n||n.chainAddHead(M,{seg:l,fill:D},h),x.unshift(l)):f.matchesPt1?(null==n||n.chainAddTail(M,{seg:l,fill:D},h),x.push(l)):(l=l.reverse(),null==n||n.chainAddTail(M,{seg:l,fill:D},h),x.push(l)),f.matchesHead){const S=x[1],E=y(l,S,t);E&&(x.shift(),x[0]=E,null==n||n.chainSimplifyHead(M,{seg:E,fill:D},h))}else{const C=y(x[x.length-2],l,t);C&&(x.pop(),x[x.length-1]=C,null==n||n.chainSimplifyTail(M,{seg:C,fill:D},h))}if(h){let B=x,I=B[0],V=B[B.length-1];if(B.length>0&&t.isEqualVec2(I.start(),V.end())){let F=0,H=B[0].start();for(const W of B){const N=W.end();F+=N[1]*H[0]-N[0]*H[1],H=N}F<0===D&&(B=p(M),I=B[0],V=B[B.length-1]);const q=y(V,I,t);q&&(B.pop(),B[0]=q,null==n||n.chainSimplifyClose(M,{seg:q,fill:D},h)),null==n||n.chainClose(M,h),c.splice(M,1),a.push(B)}}}else{const R=(e,s)=>{const{segs:i,fill:a}=c[e],{segs:o}=c[s];null==n||n.chainAddTail(e,{seg:l,fill:a},h),i.push(l);const r=y(i[i.length-2],l,t);r&&(i.pop(),i[i.length-1]=r,null==n||n.chainSimplifyTail(e,{seg:r,fill:a},h));const u=y(i[i.length-1],o[0],t);u&&(o.shift(),i[i.length-1]=u,null==n||n.chainSimplifyJoin(e,s,{seg:u,fill:a},h)),null==n||n.chainJoin(e,s,h),c[e].segs=i.concat(o),c.splice(s,1)},L=f.index,$=g.index;null==n||n.chainConnect(L,$,h);const _=c[L].segs.length<c[$].segs.length;f.matchesHead?g.matchesHead?_?(f.matchesPt1||(l=l.reverse()),p(L),R(L,$)):(f.matchesPt1&&(l=l.reverse()),p($),R($,L)):(f.matchesPt1&&(l=l.reverse()),R($,L)):g.matchesHead?(f.matchesPt1||(l=l.reverse()),R(L,$)):_?(f.matchesPt1&&(l=l.reverse()),p(L),R($,L)):(f.matchesPt1||(l=l.reverse()),p($),R(L,$))}}for(const{segs:J}of i)a.push(J);return a}class P{constructor(e,t=null,n=null){this.pathState={kind:"beginPath"},this.saveStack=[],this.matrix=[1,0,0,1,0,0],this.geo=e,this.log=n,this.resultState=t?{state:"seg",segments:t}:{state:"new",selfIntersect:new b(!0,this.geo,this.log)}}setTransform(e,t,n,s,i,a){if("new"!==this.resultState.state)throw new Error("PolyBool: Cannot change shape after using it in an operation");return this.matrix=[e,t,n,s,i,a],this}resetTransform(){return this.matrix=[1,0,0,1,0,0],this}getTransform(){if("new"!==this.resultState.state)throw new Error("PolyBool: Cannot change shape after using it in an operation");const[e,t,n,s,i,a]=this.matrix;return{a:e,b:t,c:n,d:s,e:i,f:a}}transform(e,t,n,s,i,a){const[o,r,l,h,c,u]=this.matrix;return this.matrix=[o*e+l*t,r*e+h*t,o*n+l*s,r*n+h*s,o*i+l*a+c,r*i+h*a+u],this}rotate(e){const t=Math.cos(e),n=Math.sin(e),[s,i,a,o,r,l]=this.matrix;return this.matrix=[s*t+a*n,i*t+o*n,a*t-s*n,o*t-i*n,r,l],this}rotateDeg(e){const t=(e%360+360)%360;if(0===t)return this;let n=0,s=0;if(90===t)s=1;else if(180===t)n=-1;else if(270===t)s=-1;else if(45===t)n=s=Math.SQRT1_2;else if(135===t)s=Math.SQRT1_2,n=-Math.SQRT1_2;else if(225===t)n=s=-Math.SQRT1_2;else if(315===t)n=Math.SQRT1_2,s=-Math.SQRT1_2;else if(30===t)n=Math.sqrt(3)/2,s=.5;else if(60===t)n=.5,s=Math.sqrt(3)/2;else if(120===t)n=-.5,s=Math.sqrt(3)/2;else if(150===t)n=-Math.sqrt(3)/2,s=.5;else if(210===t)n=-Math.sqrt(3)/2,s=-.5;else if(240===t)n=-.5,s=-Math.sqrt(3)/2;else if(300===t)n=.5,s=-Math.sqrt(3)/2;else if(330===t)n=Math.sqrt(3)/2,s=-.5;else{const e=Math.PI*t/180;n=Math.cos(e),s=Math.sin(e)}const[i,a,o,r,l,h]=this.matrix;return this.matrix=[i*n+o*s,a*n+r*s,o*n-i*s,r*n-a*s,l,h],this}scale(e,t){const[n,s,i,a,o,r]=this.matrix;return this.matrix=[n*e,s*e,i*t,a*t,o,r],this}translate(e,t){const[n,s,i,a,o,r]=this.matrix;return this.matrix=[n,s,i,a,n*e+i*t+o,s*e+a*t+r],this}save(){if("new"!==this.resultState.state)throw new Error("PolyBool: Cannot change shape after using it in an operation");return this.saveStack.push({matrix:this.matrix}),this}restore(){if("new"!==this.resultState.state)throw new Error("PolyBool: Cannot change shape after using it in an operation");const e=this.saveStack.pop();return e&&(this.matrix=e.matrix),this}transformPoint(e,t){const[n,s,i,a,o,r]=this.matrix;return[n*e+i*t+o,s*e+a*t+r]}beginPath(){if("new"!==this.resultState.state)throw new Error("PolyBool: Cannot change shape after using it in an operation");return this.resultState.selfIntersect.beginPath(),this.endPath()}moveTo(e,t){if("new"!==this.resultState.state)throw new Error("PolyBool: Cannot change shape after using it in an operation");"beginPath"!==this.pathState.kind&&this.beginPath();const n=this.transformPoint(e,t);return this.pathState={kind:"moveTo",start:n,current:n},this}lineTo(e,t){if("new"!==this.resultState.state)throw new Error("PolyBool: Cannot change shape after using it in an operation");if("moveTo"!==this.pathState.kind)throw new Error("PolyBool: Must call moveTo prior to calling lineTo");const n=this.transformPoint(e,t);return this.resultState.selfIntersect.addLine(this.pathState.current,n),this.pathState.current=n,this}rect(e,t,n,s){return this.moveTo(e,t).lineTo(e+n,t).lineTo(e+n,t+s).lineTo(e,t+s).closePath().moveTo(e,t)}bezierCurveTo(e,t,n,s,i,a){if("new"!==this.resultState.state)throw new Error("PolyBool: Cannot change shape after using it in an operation");if("moveTo"!==this.pathState.kind)throw new Error("PolyBool: Must call moveTo prior to calling bezierCurveTo");const o=this.transformPoint(i,a);return this.resultState.selfIntersect.addCurve(this.pathState.current,this.transformPoint(e,t),this.transformPoint(n,s),o),this.pathState.current=o,this}closePath(){if("new"!==this.resultState.state)throw new Error("PolyBool: Cannot change shape after using it in an operation");return"moveTo"!==this.pathState.kind||this.geo.isEqualVec2(this.pathState.start,this.pathState.current)||(this.resultState.selfIntersect.addLine(this.pathState.current,this.pathState.start),this.pathState.current=this.pathState.start),this.resultState.selfIntersect.closePath(),this.endPath()}endPath(){if("new"!==this.resultState.state)throw new Error("PolyBool: Cannot change shape after using it in an operation");return this.pathState={kind:"beginPath"},this}selfIntersect(){return"new"===this.resultState.state&&(this.resultState={state:"seg",segments:this.resultState.selfIntersect.calculate()}),this.resultState.segments}segments(){if("reg"!==this.resultState.state){const e=this.selfIntersect();this.resultState={state:"reg",segments:e,regions:k(e,this.geo,this.log)}}return this.resultState.regions}output(e,t=[1,0,0,1,0,0]){return function(e,t,n,s){const[i,a,o,h,c,u]=s;n.beginPath();for(const s of e){if(s.length<=0)continue;for(let e=0;e<s.length;e++){const t=s[e];if(0===e){const[e,s]=t.start();n.moveTo(i*e+o*s+c,a*e+h*s+u)}if(t instanceof r){const[e,s]=t.p1;n.lineTo(i*e+o*s+c,a*e+h*s+u)}else{if(!(t instanceof l))throw new Error("PolyBool: Unknown segment instance");{const[e,s]=t.p1,[r,l]=t.p2,[d,p]=t.p3;n.bezierCurveTo(i*e+o*s+c,a*e+h*s+u,i*r+o*l+c,a*r+h*l+u,i*d+o*p+c,a*d+h*p+u)}}}const e=s[0],d=s[s.length-1];t.isEqualVec2(e.start(),d.end())&&n.closePath()}return n}(this.segments(),this.geo,e,t)}combine(e){const t=new b(!1,this.geo,this.log);for(const e of this.selfIntersect())t.addSegment(g(e,this.log),!0);for(const n of e.selfIntersect())t.addSegment(g(n,this.log),!1);return new M(t.calculate(),this.geo,this.log)}}class M{constructor(e,t,n=null){this.geo=t,this.segments=e,this.log=n}union(){return new P(this.geo,T.union(this.segments,this.log),this.log)}intersect(){return new P(this.geo,T.intersect(this.segments,this.log),this.log)}difference(){return new P(this.geo,T.difference(this.segments,this.log),this.log)}differenceRev(){return new P(this.geo,T.differenceRev(this.segments,this.log),this.log)}xor(){return new P(this.geo,T.xor(this.segments,this.log),this.log)}}class x{constructor(){this.list=[],this.nextSegmentId=0,this.curVert=NaN}push(e,t){this.list.push({type:e,data:JSON.parse(JSON.stringify(t))})}info(e,t){this.push("info",{msg:e,data:t})}segmentId(){return this.nextSegmentId++}checkIntersection(e,t){this.push("check",{seg1:e,seg2:t})}segmentDivide(e,t){this.push("div_seg",{seg:e,p:t})}segmentChop(e){this.push("chop",{seg:e})}statusRemove(e){this.push("pop_seg",{seg:e})}segmentUpdate(e){this.push("seg_update",{seg:e})}segmentNew(e,t){this.push("new_seg",{seg:e,primary:t})}tempStatus(e,t,n){this.push("temp_status",{seg:e,above:t,below:n})}rewind(e){this.push("rewind",{seg:e})}status(e,t,n){this.push("status",{seg:e,above:t,below:n})}vert(e){e!==this.curVert&&(this.push("vert",{x:e}),this.curVert=e)}selected(e){this.push("selected",{segs:e})}chainStart(e,t){this.push("chain_start",{sf:e,closed:t})}chainNew(e,t){this.push("chain_new",{sf:e,closed:t})}chainMatch(e,t){this.push("chain_match",{index:e,closed:t})}chainClose(e,t){this.push("chain_close",{index:e,closed:t})}chainAddHead(e,t,n){this.push("chain_add_head",{index:e,sf:t,closed:n})}chainAddTail(e,t,n){this.push("chain_add_tail",{index:e,sf:t,closed:n})}chainSimplifyHead(e,t,n){this.push("chain_simp_head",{index:e,sf:t,closed:n})}chainSimplifyTail(e,t,n){this.push("chain_simp_tail",{index:e,sf:t,closed:n})}chainSimplifyClose(e,t,n){this.push("chain_simp_close",{index:e,sf:t,closed:n})}chainSimplifyJoin(e,t,n,s){this.push("chain_simp_join",{index1:e,index2:t,sf:n,closed:s})}chainConnect(e,t,n){this.push("chain_con",{index1:e,index2:t,closed:n})}chainReverse(e,t){this.push("chain_rev",{index:e,closed:t})}chainJoin(e,t,n){this.push("chain_join",{index1:e,index2:t,closed:n})}done(){this.push("done",null)}}class D{constructor(e=new s,t=null){this.geo=e,this.log=t}shape(){return new P(this.geo,null,this.log)}buildLog(e){var t;return this.log=e?new x:null,null===(t=this.log)||void 0===t?void 0:t.list}segments(e){const t=this.shape();t.beginPath();for(const n of e.regions){const e=n[n.length-1];t.moveTo(e[e.length-2],e[e.length-1]);for(const e of n)if(2===e.length)t.lineTo(e[0],e[1]);else{if(6!==e.length)throw new Error("PolyBool: Invalid point in region");t.bezierCurveTo(e[0],e[1],e[2],e[3],e[4],e[5])}t.closePath()}return{shape:t,inverted:e.inverted}}combine(e,t){return{shape:e.shape.combine(t.shape),inverted1:e.inverted,inverted2:t.inverted}}selectUnion(e){return{shape:e.inverted1?e.inverted2?e.shape.intersect():e.shape.difference():e.inverted2?e.shape.differenceRev():e.shape.union(),inverted:e.inverted1||e.inverted2}}selectIntersect(e){return{shape:e.inverted1?e.inverted2?e.shape.union():e.shape.differenceRev():e.inverted2?e.shape.difference():e.shape.intersect(),inverted:e.inverted1&&e.inverted2}}selectDifference(e){return{shape:e.inverted1?e.inverted2?e.shape.differenceRev():e.shape.union():e.inverted2?e.shape.intersect():e.shape.difference(),inverted:e.inverted1&&!e.inverted2}}selectDifferenceRev(e){return{shape:e.inverted1?e.inverted2?e.shape.difference():e.shape.intersect():e.inverted2?e.shape.union():e.shape.differenceRev(),inverted:!e.inverted1&&e.inverted2}}selectXor(e){return{shape:e.shape.xor(),inverted:e.inverted1!==e.inverted2}}polygon(e){const t=[],n={beginPath:()=>{},moveTo:()=>{t.push([])},lineTo:(e,n)=>{t[t.length-1].push([e,n])},bezierCurveTo:(e,n,s,i,a,o)=>{t[t.length-1].push([e,n,s,i,a,o])},closePath:()=>{}};return e.shape.output(n),{regions:t,inverted:e.inverted}}union(e,t){const n=this.segments(e),s=this.segments(t),i=this.combine(n,s),a=this.selectUnion(i);return this.polygon(a)}intersect(e,t){const n=this.segments(e),s=this.segments(t),i=this.combine(n,s),a=this.selectIntersect(i);return this.polygon(a)}difference(e,t){const n=this.segments(e),s=this.segments(t),i=this.combine(n,s),a=this.selectDifference(i);return this.polygon(a)}differenceRev(e,t){const n=this.segments(e),s=this.segments(t),i=this.combine(n,s),a=this.selectDifferenceRev(i);return this.polygon(a)}xor(e,t){const n=this.segments(e),s=this.segments(t),i=this.combine(n,s),a=this.selectXor(i);return this.polygon(a)}}new D;const S=new class extends s{atan2Deg(e,t){return Math.abs(e)<this.epsilon?t>0||Math.abs(t)<this.epsilon?0:180:Math.abs(t)<this.epsilon?e<0?270:90:Math.abs(t-e)<this.epsilon?t<0?225:45:Math.abs(t+e)<this.epsilon?t<0?135:315:(180*Math.atan2(e,t)/Math.PI+360)%360}sinDeg(e){const t=(e%360+360)%360;switch(t){case 0:case 180:return 0;case 30:case 150:return.5;case 45:case 135:return Math.SQRT1_2;case 60:case 120:return Math.sqrt(3)/2;case 90:return 1;case 210:case 330:return-.5;case 225:case 315:return-Math.SQRT1_2;case 240:case 300:return-Math.sqrt(3)/2;case 270:return-1;default:return Math.sin(t*Math.PI/180)}}cosDeg(e){const t=(e%360+360)%360;switch(t){case 0:return 1;case 30:case 330:return Math.sqrt(3)/2;case 45:case 315:return Math.SQRT1_2;case 60:case 300:return.5;case 90:case 270:return 0;case 120:case 240:return-.5;case 135:case 225:return-Math.SQRT1_2;case 150:case 210:return-Math.sqrt(3)/2;case 180:return-1;default:return Math.cos(t*Math.PI/180)}}linesIntersect(e,t,n,s,i,a,o,r){const l=n-e,h=s-t,c=o-i,u=r-a,d=l*u-h*c;if(0===this.snap0(d))return null;const p=e-i,f=t-a,g=this.snap01((c*f-u*p)/d);return{p:[e+g*l,t+g*h],alongA:g,alongB:this.snap01((l*f-h*p)/d)}}},E=new D(S);function C(e,t){if(0===S.snap0(t))return e;const n=[];e.output({beginPath:()=>{},moveTo:(e,t)=>{n.push({path:[],closed:!1})},lineTo:(e,t)=>{n[n.length-1].path.push([e,t])},bezierCurveTo:(e,t,s,i,a,o)=>{n[n.length-1].path.push([e,t,s,i,a,o])},closePath:()=>{n[n.length-1].closed=!0}});const s=Math.abs(t)/2,i=90*Math.sign(t),a=E.shape().beginPath();for(const{path:e,closed:t}of n){let n=e;if(t){n=[];const t=(t,n)=>{const s=e[t],i=e[(t+e.length-1)%e.length],a=i[i.length-2],o=i[i.length-1];return 2===s.length||n?S.atan2Deg(o-s[1],a-s[0]):S.atan2Deg(s[3]-s[5],s[2]-s[4])},a=(e,t,n)=>[e[0]+n*S.cosDeg(t),e[1]+n*S.sinDeg(t)],o=(e,t,n)=>a(e,t-i,n),r=[];for(let i=0;i<e.length;i++){const l=(i+e.length-1)%e.length,h=e[i],c=t(l,!1),u=t(i,!0),d=t(i,!1),p=Math.min(Math.abs(c-u),Math.abs(c+360-u),Math.abs(c-(u+360)));if(S.snap0(p)>0){const t=4*s*Math.tan(p/4*Math.PI/180)/3,i=e[l],h=[i[i.length-2],i[i.length-1]];r.push(n.length);const d=a(o(h,c,s),c,-t),f=a(o(h,u,s),u,t),g=o(h,u,s);n.push([d[0],d[1],f[0],f[1],g[0],g[1]])}if(2===h.length)n.push(o(h,d,s));else{const e=o([h[0],h[1]],u,s),t=o([h[2],h[3]],d,s),i=o([h[4],h[5]],d,s);n.push([e[0],e[1],t[0],t[1],i[0],i[1]])}}for(const e of r){const t=(e+n.length-1)%n.length,s=(e+n.length-2)%n.length,i=(e+1)%n.length,a=n[s],o=n[t],r=n[e],l=n[i];if(6===r.length){const e=S.linesIntersect(2===o.length?a[a.length-2]:o[2],2===o.length?a[a.length-1]:o[3],o[o.length-2],o[o.length-1],r[r.length-2],r[r.length-1],l[0],l[1]);e&&e.alongA>0&&e.alongA<1&&e.alongB>0&&e.alongB<1&&(r[0]=o[o.length-2],r[1]=o[o.length-1],r[2]=r[4],r[3]=r[5],o[o.length-2]=e.p[0],o[o.length-1]=e.p[1],r[4]=e.p[0],r[5]=e.p[1])}}}if(n.length>0){const e=n[n.length-1];a.moveTo(e[e.length-2],e[e.length-1]);for(const e of n)2===e.length?a.lineTo(e[0],e[1]):a.bezierCurveTo(e[0],e[1],e[2],e[3],e[4],e[5])}}return a}class B{constructor(e,t,n=E.shape(),s=E.shape(),i=E.shape()){this.home={origin:[0,0],angle:0},this.thickness=e,this.kerf=t,this.border=n,this.cuts=s,this.scores=i}replace(e){var t,n,s,i,a;const o=new B(null!==(t=e.thickness)&&void 0!==t?t:this.thickness,null!==(n=e.kerf)&&void 0!==n?n:this.kerf,null!==(s=e.border)&&void 0!==s?s:this.border,null!==(i=e.cuts)&&void 0!==i?i:this.cuts,null!==(a=e.scores)&&void 0!==a?a:this.scores);return o.setHome(this.home.origin,this.home.angle),o}copy(){return this.replace({})}static combine(e,t,n){const s=t.cuts.combine(n.cuts).union().combine(e).intersect(),i=t.scores.combine(n.scores).union().combine(e).intersect();return t.replace({border:e,cuts:s,scores:i})}static union(e,t){return B.combine(e.border.combine(t.border).union(),e,t)}static intersect(e,t){return B.combine(e.border.combine(t.border).intersect(),e,t)}static subtract(e,t){return B.combine(e.border.combine(t.border).difference(),e,t)}static xor(e,t){return B.combine(e.border.combine(t.border).xor(),e,t)}unionBorder(e){return B.union(this,this.replace({border:e,cuts:E.shape(),scores:E.shape()}))}subtractBorder(e){return B.subtract(this,this.replace({border:e,cuts:E.shape(),scores:E.shape()}))}setHome(e,t){return this.home={origin:e,angle:t},this}newShape(){return E.shape().translate(this.home.origin[0],this.home.origin[1]).rotateDeg(this.home.angle)}boundingBox(){const e=[1/0,1/0],t=[-1/0,-1/0];let n=!0;const s=s=>{for(const i of s.segments())for(const s of i){const i=s.boundingBox();e[0]=Math.min(e[0],i[0][0]),e[1]=Math.min(e[1],i[0][1]),t[0]=Math.max(t[0],i[1][0]),t[1]=Math.max(t[1],i[1][1]),n=!1}};return s(this.border),s(this.cuts),s(this.scores),n&&(e[0]=e[1]=t[0]=t[1]=0),[e,t]}applyKerf(){return 0===S.snap0(this.kerf)?this:this.replace({kerf:0,border:C(this.border,this.kerf)})}}class I{constructor(e){}}function V(e,t=0){switch(typeof e){case"string":return JSON.stringify(e).replace(/--/g,"\\u002d-");case"boolean":case"number":return JSON.stringify(e);case"object":if(null===e)return"null";if(Array.isArray(e)){if(e.every((e=>"object"==typeof e&&null!==e))){const n=[];for(let s=0;s<e.length;s++){const i=V(e[s],t);i&&n.push(i)}return`[${n.join(", ")}]`}{let n=[];for(let t=0;t<e.length;t++){const s=V(e[t]);s&&n.push(s)}const s=`[${n.join(",")}]`;if(s.length<60&&!s.includes("\n"))return s;n=[];for(let s=0;s<e.length;s++){const i=V(e[s],t+1);i&&n.push(i)}return`[\n${"  ".repeat(t+1)}${n.join(",\n")}\n${"  ".repeat(t)}]`}}{const n=[];for(const[s,i]of Object.entries(e)){const e=V(s),a=V(i,t+1);a&&n.push(`${"  ".repeat(t+1)}${e}: ${a}`)}return`{\n${n.join(",\n")}\n${"  ".repeat(t)}}`}}return""}class F extends I{constructor(e){super(e),this.surfaces=[],this.comments=[],this.settings=e}addSurface(e,t,n,s){this.surfaces.push({offset:e,surface:t.applyKerf(),cutColor:n,scoreColor:s})}addComment(e){this.comments.push(e)}toFile(){const e=e=>""+Math.round(1e3*e)/1e3,t=[];let n=0,s=0,i=100,a=100;if(this.surfaces.length>0){const o=[[1/0,1/0],[-1/0,-1/0]];for(const{offset:e,surface:t}of this.surfaces){const n=t.boundingBox();o[0][0]=Math.min(o[0][0],e[0]+n[0][0]-10),o[0][1]=Math.min(o[0][1],e[1]+n[0][1]-10),o[1][0]=Math.max(o[1][0],e[0]+n[1][0]+10),o[1][1]=Math.max(o[1][1],e[1]+n[1][1]+10)}n=o[0][0],s=o[0][1],i=o[1][0]-o[0][0],a=o[1][1]-o[0][1];let r=0;const l=()=>{t.push(`<g id="p-${r++}" style="fill:none;stroke-linecap:round;stroke-linejoin:round;">`)},h=()=>{t.push("</g>")},c=(n,s,i)=>{const a=[];s.output({beginPath:()=>{},moveTo:(t,n)=>{a.push(`M${e(t)} ${e(n)}`)},lineTo:(t,n)=>{a.push(`L${e(t)} ${e(n)}`)},bezierCurveTo:(t,n,s,i,o,r)=>{a.push(`C${e(t)} ${e(n)} ${e(s)} ${e(i)} ${e(o)} ${e(r)}`)},closePath:()=>{a.push("Z")}},[1,0,0,1,n[0],n[1]]),t.push(`<path stroke="${i}" stroke-width="1" d="${a.join("")}" />`)};for(const{offset:e,surface:t,cutColor:n,scoreColor:s}of this.surfaces)l(),l(),c(e,t.scores,s),h(),l(),c(e,t.border,n),c(e,t.cuts,n),h(),h()}const{units:o}=this.settings;return{mimeType:"image/svg+xml",extension:".svg",data:(new TextEncoder).encode(`<?xml version='1.0' encoding='utf-8'?>\n<svg\n  width="${e(i)}${o}"\n  height="${e(a)}${o}"\n  viewBox="${e(n)} ${e(s)} ${e(i)} ${e(a)}"\n  xmlns="http://www.w3.org/2000/svg">\n\x3c!--\nGenerated by boxburner\nby Sean Connelly (@velipso), https://sean.fun\nProject Home: https://github.com/velipso/boxburner\nSPDX-License-Identifier: 0BSD\n\nExported on: ${(new Date).toString()}\n--\x3e\n${this.comments.map((e=>`\x3c!--\n${V(e)}\n--\x3e`)).join("\n")}\n${t.join("\n")}\n</svg>`)}}}function H(e){const{fileFormat:t}=e;if("svg"===t)return new F(e);throw new Error(`Unknown export file format: ${t}`)}class q{}class W{}class N extends W{thickness(e,t){return this.jointThickness(!1,e,t)}draw(e,t,n,s){return this.jointDraw(e,t,!1,n,s)}}class R extends N{name(){return"ButtJoint"}schema(){return{properties:{invert:{type:"boolean",metadata:{default:!1,title:"Invert",description:"Swap settings for receiving side"}},length1:{type:"float64",metadata:{default:0,title:"Length 1",description:"Length of butt 1 (multiples of material thickness)"}},length2:{type:"float64",metadata:{default:1,title:"Length 2",description:"Length of butt 2 (multiples of material thickness)"}}},metadata:{order:["invert","length1","length2"]}}}jointThickness(e,t,{length1:n,length2:s,invert:i}){return(e!==i?s:n)*t}jointDraw(e,t,n,s,i){return e}}function L({length:e,width1:t,width2:n,cornerDistance1:s,cornerDistance2:i,centerDistance:a},o){let r=0;const l=(e,t)=>{o(r,e,t),r+=e},h=e=>{if(e>1e4)throw new Error("Too many fingers");l(t,!0);for(let s=0;s<e;s++)l(n,!1),l(t,!0)},c=e-s-i;if(a>0){const e=(c-a)/2,o=Math.floor((e-t)/(t+n)),r=t+o*(t+n);l(s+(e-r)/2,!1),h(o),l(a+e-r,!1),h(o),l(i+(e-r)/2,!1)}else{const e=Math.floor((c-t)/(t+n)),a=t+e*(t+n);l(s+(c-a)/2,!1),h(e),l(i+(c-a)/2,!1)}}class $ extends N{name(){return"BoxJoint"}schema(){return{properties:{invert:{type:"boolean",metadata:{default:!1,title:"Invert",description:"Swap settings for receiving side"}},width1:{type:"float64",metadata:{default:6,title:"Width 1",description:"Width of finger 1 (units)"}},length1:{type:"float64",metadata:{default:1,title:"Length 1",description:"Length of finger 1 (multiples of material thickness)"}},width2:{type:"float64",metadata:{default:6,title:"Width 2",description:"Width of finger 2 (units)"}},length2:{type:"float64",metadata:{default:1,title:"Length 2",description:"Length of finger 2 (multiples of material thickness)"}},play:{type:"float64",metadata:{default:0,title:"Play",description:"Extra space around fingers (units)"}},cornerDistance:{type:"float64",metadata:{default:12,title:"Corner Distance",description:"Reserved space near corners to exclude fingers (units)"}},cornerDistance1Delta:{type:"float64",nullable:!0,metadata:{default:null,defaultNotNull:0,title:"Corner Distance 1 Delta",description:"Additional corner distance"}},cornerDistance2Delta:{type:"float64",nullable:!0,metadata:{default:null,defaultNotNull:0,title:"Corner Distance 2 Delta",description:"Additional corner distance"}},centerDistance:{type:"float64",metadata:{default:0,title:"Center Distance",description:"Reserved space near center to exclude fingers (units)"}}},metadata:{order:["invert","width1","length1","width2","length2","play","cornerDistance","centerDistance"]}}}jointThickness(e,t,{length1:n,length2:s,invert:i}){return(e!==i?s:n)*t}jointDraw(e,t,n,s,{invert:i,width1:a,length1:o,width2:r,length2:l,play:h,cornerDistance:c,cornerDistance1Delta:u,cornerDistance2Delta:d,centerDistance:p}){const f=n!==i,g=(f?l:o)*s;return L({length:t,width1:a,width2:r,cornerDistance1:c+(null!=u?u:0),cornerDistance2:c+(null!=d?d:0),centerDistance:p},((t,n,s)=>{s===f&&(e=e.subtractBorder(e.newShape().beginPath().rect(t-h/2,0,n+h,g).closePath()))})),e}}class _ extends W{name(){return"LegEdge"}schema(){return{properties:{flatWidth:{type:"float64",metadata:{default:.1,title:"Flat Width",description:"Flat part of leg (fraction of overall length)"}},curveWidth:{type:"float64",metadata:{default:.15,title:"Curve Width",description:"Curve part of leg (fraction of overall length)"}},curveAmount:{type:"float64",metadata:{default:.05,title:"Curve Amount",description:"How extreme to curve (fraction of overall length)"}},height:{type:"float64",metadata:{default:10,title:"Height (units)"}}},metadata:{order:["flatWidth","curveWidth","curveAmount","height"]}}}thickness(e,{height:t}){return Math.max(0,t)}draw(e,t,n,{flatWidth:s,curveWidth:i,curveAmount:a,height:o}){return o<=0?e:e.subtractBorder(e.newShape().beginPath().moveTo(s*t,0).bezierCurveTo((s+a)*t,0,(s+i-a)*t,o,(s+i)*t,o).lineTo((1-s-i)*t,o).bezierCurveTo((1-s-i+a)*t,o,(1-s-a)*t,0,(1-s)*t,0).closePath())}}function J(e,t={},n){return{discriminator:"kind",mapping:e.map((e=>({[e.name()]:{properties:{kind:{type:"string",metadata:{default:e.name(),title:e.name()}},params:e.schema()},metadata:{order:["params"],untabParams:!0}}}))).reduce(((e,t)=>({...e,...t})),{}),nullable:n,metadata:{default:e[0].name(),order:e.map((e=>e.name())),...t}}}const z=[new $,new R,new _];class A extends N{name(){return"MortiseAndTenonJoint"}schema(){return{properties:{invert:{type:"boolean",metadata:{default:!1,title:"Invert",description:"Swap settings for receiving side"}},width1:{type:"float64",metadata:{default:6,title:"Width 1",description:"Width of tenon (units)"}},tenonLength:{type:"float64",metadata:{default:1,title:"Tenon Length",description:"Length of tenon (multiples of material thickness)"}},width2:{type:"float64",metadata:{default:6,title:"Width 2",description:"Width between tenons (units)"}},holeDistance:{type:"float64",metadata:{default:3,title:"Hole Distance",description:"Distance of mortises from edge (units)"}},play:{type:"float64",metadata:{default:0,title:"Play",description:"Extra space between mortise and tenons (units)"}},thicknessPlay:{type:"float64",metadata:{default:0,title:"Thickness Play",description:"Extra thickness added to mortise holes (units)"}},cornerDistance:{type:"float64",metadata:{default:12,title:"Corner Distance",description:"Reserved space near corners to exclude joints (units)"}},cornerDistance1Delta:{type:"float64",nullable:!0,metadata:{default:null,defaultNotNull:0,title:"Corner Distance 1 Delta",description:"Additional corner distance"}},cornerDistance2Delta:{type:"float64",nullable:!0,metadata:{default:null,defaultNotNull:0,title:"Corner Distance 2 Delta",description:"Additional corner distance"}},centerDistance:{type:"float64",metadata:{default:0,title:"Center Distance",description:"Reserved space near center to exclude joints (units)"}},mortiseEdge:J(z,{default:null,defaultNotNull:"LegEdge",title:"Mortise Edge"},!0)},metadata:{order:["invert","width1","tenonLength","width2","holeDistance","play","thicknessPlay","cornerDistance","centerDistance","mortiseEdge"]}}}jointThickness(e,t,{tenonLength:n,invert:s,mortiseEdge:i}){if(e!==s){if(i){const e=z.find((e=>e.name()===i.kind));if(!e)throw new Error("Invalid mortise edge");return e.thickness(t,i.params)}return 0}return n*t}jointDraw(e,t,n,s,{invert:i,width1:a,tenonLength:o,width2:r,holeDistance:l,play:h,thicknessPlay:c,cornerDistance:u,cornerDistance1Delta:d,cornerDistance2Delta:p,centerDistance:f,mortiseEdge:g}){const m=n!==i;let v=0;if(m&&g){const n=z.find((e=>e.name()===g.kind));if(!n)throw new Error("Invalid mortise edge");v=n.thickness(s,g.params),e=n.draw(e,t,s,g.params)}return L({length:t,width1:a,width2:r,cornerDistance1:u+(null!=d?d:0),cornerDistance2:u+(null!=p?p:0),centerDistance:f},((t,n,i)=>{if(m&&i){const i=s,a=l+v;e=e.subtractBorder(e.newShape().beginPath().rect(t-h/2,a-c,n+h,i+2*c).closePath())}else if(!m&&!i){const i=o*s;e=e.subtractBorder(e.newShape().beginPath().rect(t-h/2,0,n+h,i).closePath())}})),e}}const j=[new R,new $,new _,new A],O=[new R,new $,new A];function U(e={},t){return J(j,e,t)}const K={" ":0,"!":74240,'"':516,"#":43580,$:43707,"%":61081,"&":37745,"'":512,"(":5120,")":16640,"*":65280,"+":43520,",":16384,"-":34816,".":65536,"/":17408,0:17663,1:1036,2:34935,3:2111,4:34956,5:35003,6:35067,7:15,8:35071,9:35007,":":8704,";":16896,"<":37888,"=":34864,">":18688,"?":75783,"@":2807,A:35023,B:10815,C:243,D:8767,E:33011,F:32963,G:2299,H:35020,I:8755,J:124,K:38080,L:240,M:1484,N:4556,O:255,P:35015,Q:4351,R:39111,S:35003,T:8707,U:252,V:17600,W:20684,X:21760,Y:35004,Z:17459,"[":8722,"\\":4352,"]":8737,"^":20480,_:48,"`":256,"{":41490,"|":8704,"}":10785,"~":52224},Q=(e,t,n,s,i)=>{var a;const o=null!==(a=K[i.toUpperCase()])&&void 0!==a?a:K["?"],r=(i,a,o,r)=>{e.moveTo(t[0]+i*n,t[1]+a*s).lineTo(t[0]+o*n,t[1]+r*s)},l=.025;1&o&&r(l,0,.475,0),2&o&&r(.525,0,.975,0),4&o&&r(1,l,1,.475),8&o&&r(1,.525,1,.975),16&o&&r(.975,1,.525,1),32&o&&r(.475,1,l,1),64&o&&r(0,.975,0,.525),128&o&&r(0,.475,0,l),256&o&&r(l,l,.475,.475),512&o&&r(.5,l,.5,.475),1024&o&&r(.975,l,.525,.475),2048&o&&r(.525,.5,.975,.5),4096&o&&r(.525,.525,.975,.975),8192&o&&r(.5,.525,.5,65536&o?.775:.975),16384&o&&r(.475,.525,l,.975),32768&o&&r(.475,.5,l,.5),65536&o&&r(.5,.8+l,.5,.975)};class X extends q{name(){return"Rectangle"}schema(){return{properties:{label:{type:"string",nullable:!0,metadata:{default:null,defaultNotNull:"",nullHint:"none",title:"Label"}},labelFontSize:{type:"float64",nullable:!0,metadata:{default:null,defaultNotNull:10,nullHint:"auto",title:"Label Font Size (units)"}},thickness:{type:"float64",nullable:!0,metadata:{default:null,defaultNotNull:3,nullHint:"default",title:"Material Thickness (units)"}},kerf:{type:"float64",nullable:!0,metadata:{default:null,defaultNotNull:.1,nullHint:"default",title:"Kerf (units)",description:"Thickness of material removed by cutting tool"}},width:{type:"float64",metadata:{default:100,title:"Inner Width (units)"}},height:{type:"float64",metadata:{default:100,title:"Inner Height (units)"}},edge1:U({title:"Top"}),edge2:U({title:"Right"}),edge3:U({title:"Bottom"}),edge4:U({title:"Left"})},metadata:{order:["label","labelFontSize","thickness","kerf","width","height","edge1","edge2","edge3","edge4"]}}}generate(e,{label:t,labelFontSize:n,thickness:s,kerf:i,width:a,height:o,edge1:r,edge2:l,edge3:h,edge4:c}){const u="number"==typeof s?s:e.defaultThickness,d="number"==typeof i?i:e.defaultKerf,p=j.find((e=>e.name()===r.kind));if(!p)throw new Error("Bad top edge");const f=j.find((e=>e.name()===l.kind));if(!f)throw new Error("Bad right edge");const g=j.find((e=>e.name()===h.kind));if(!g)throw new Error("Bad bottom edge");const m=j.find((e=>e.name()===c.kind));if(!m)throw new Error("Bad left edge");const v=p.thickness(u,r.params),b=f.thickness(u,l.params),w=g.thickness(u,h.params),T=m.thickness(u,c.params),y=a+b+T,k=o+v+w,P=E.shape().beginPath().moveTo(0,0).lineTo(y,0).lineTo(y,k).lineTo(0,k).closePath(),M=E.shape(),x=t?function(e,t,n,s,i,a){const o=e.split("\n"),r=o.reduce(((e,t)=>Math.max(e,t.length)),0),l="number"==typeof a?a:Math.min((s-5)/r*2,(i-5)/o.length),h=l/2,c=t+(s-h*r)/2,u=n+(i-l*o.length)/2,d=E.shape();for(let e=0;e<o.length;e++){const t=o[e];for(let n=0;n<t.length;n++)Q(d,[c+h*n+.15*h,u+l*e+.15*l],.7*h,.7*l,t.charAt(n))}return d}(t,T,v,a,o,n):E.shape();let D=new B(u,d,P,M,x);return D=p.draw(D.setHome([0,0],0),y,u,{...r.params,cornerDistance1Delta:T,cornerDistance2Delta:b}),D=f.draw(D.setHome([y,0],90),k,u,{...l.params,cornerDistance1Delta:v,cornerDistance2Delta:w}),D=g.draw(D.setHome([y,k],180),y,u,{...h.params,cornerDistance1Delta:b,cornerDistance2Delta:T}),D=m.draw(D.setHome([0,k],270),k,u,{...c.params,cornerDistance1Delta:w,cornerDistance2Delta:v}),[D]}}class Y extends q{name(){return"BoxPlain"}schema(){return{properties:{labels:{type:"boolean",metadata:{default:!1,title:"Labels"}},width:{type:"float64",metadata:{default:100,title:"Inner Width (units)"}},depth:{type:"float64",metadata:{default:100,title:"Inner Depth (units)"}},height:{type:"float64",metadata:{default:100,title:"Inner Height (units)"}},holeDistance:{type:"float64",metadata:{default:3,title:"Hole Distance",description:"Distance of mortises from edge (units)"}},play:{type:"float64",metadata:{default:0,title:"Play",description:"Extra space between fingers (units)"}},thicknessPlay:{type:"float64",metadata:{default:0,title:"Thickness Play",description:"Extra thickness added to mortise holes (units)"}}},metadata:{order:["labels","width","depth","height","holeDistance","play","thicknessPlay"]}}}generate(e,{labels:t,width:n,depth:s,height:i,holeDistance:a,play:o,thicknessPlay:r}){const{defaultThickness:l}=e,h=new X,c=e=>({kind:"MortiseAndTenonJoint",params:{invert:e,width1:2*l,tenonLength:1,width2:2*l,holeDistance:a,play:o,thicknessPlay:r,cornerDistance:2*l,centerDistance:0}}),u=e=>({kind:"BoxJoint",params:{invert:e,width1:2*l,length1:1,width2:2*l,length2:1,play:o,cornerDistance:2*l,centerDistance:0}});return[...h.generate(e,{width:n,height:s,edge1:c(!1),edge2:c(!1),edge3:c(!1),edge4:c(!1),...t?{label:"Bottom"}:{}}),...h.generate(e,{width:s,height:i,edge1:{kind:"ButtJoint",params:{invert:!1,length1:0,length2:1}},edge2:u(!1),edge3:c(!0),edge4:u(!1),...t?{label:"Left"}:{}}),...h.generate(e,{width:s,height:i,edge1:{kind:"ButtJoint",params:{invert:!1,length1:0,length2:1}},edge2:u(!1),edge3:c(!0),edge4:u(!1),...t?{label:"Right"}:{}}),...h.generate(e,{width:n,height:i,edge1:{kind:"ButtJoint",params:{invert:!1,length1:0,length2:1}},edge2:u(!0),edge3:c(!0),edge4:u(!0),...t?{label:"Front"}:{}}),...h.generate(e,{width:n,height:i,edge1:{kind:"ButtJoint",params:{invert:!1,length1:0,length2:1}},edge2:u(!0),edge3:c(!0),edge4:u(!0),...t?{label:"Back"}:{}})]}}class Z extends q{name(){return"BoxNested"}schema(){return{properties:{labels:{type:"boolean",metadata:{default:!1,title:"Labels"}},width:{type:"float64",metadata:{default:100,title:"Inner Width (units)"}},depth:{type:"float64",metadata:{default:100,title:"Inner Depth (units)"}},height:{type:"float64",metadata:{default:100,title:"Inner Height (units)"}},holeDistance:{type:"float64",metadata:{default:3,title:"Hole Distance",description:"Distance of mortises from edge (units)"}},play:{type:"float64",metadata:{default:0,title:"Play",description:"Extra space between fingers (units)"}},thicknessPlay:{type:"float64",metadata:{default:0,title:"Thickness Play",description:"Extra thickness added to mortise holes (units)"}}},metadata:{order:["labels","width","depth","height","holeDistance","play","thicknessPlay"]}}}generate(e,{labels:t,width:n,depth:s,height:i,holeDistance:a,play:o,thicknessPlay:r}){const{defaultThickness:l}=e,h=new X,c=(e,t,n)=>({kind:"MortiseAndTenonJoint",params:{invert:e,width1:2*l,tenonLength:t,width2:2*l,holeDistance:a,play:o,thicknessPlay:r,cornerDistance:2*l,centerDistance:0,mortiseEdge:n}}),u=(e,t)=>({kind:"BoxJoint",params:{invert:e,width1:2*l,length1:t,width2:2*l,length2:t,play:o,cornerDistance:2*l,centerDistance:0}});return[...h.generate(e,{width:n,height:s,edge1:c(!1,2),edge2:c(!1,1),edge3:c(!1,2),edge4:c(!1,1),...t?{label:"Bottom"}:{}}),...h.generate(e,{width:s,height:i,edge1:{kind:"ButtJoint",params:{invert:!1,length1:0,length2:1}},edge2:u(!1,2),edge3:c(!0,1),edge4:u(!1,2),...t?{label:"Left"}:{}}),...h.generate(e,{width:s,height:i,edge1:{kind:"ButtJoint",params:{invert:!1,length1:0,length2:1}},edge2:u(!1,2),edge3:c(!0,1),edge4:u(!1,2),...t?{label:"Right"}:{}}),...h.generate(e,{width:n,height:i,edge1:{kind:"ButtJoint",params:{invert:!1,length1:0,length2:1}},edge2:u(!0,1),edge3:c(!0,1),edge4:u(!0,1),...t?{label:"Front"}:{}}),...h.generate(e,{width:n,height:i,edge1:{kind:"ButtJoint",params:{invert:!1,length1:0,length2:1}},edge2:u(!0,1),edge3:c(!0,1,{kind:"LegEdge",params:{flatWidth:.1,curveWidth:.15,curveAmount:.05,height:10}}),edge4:u(!0,1),...t?{label:"Inner Front"}:{}}),...h.generate(e,{width:n,height:i,edge1:{kind:"ButtJoint",params:{invert:!1,length1:0,length2:1}},edge2:u(!0,1),edge3:c(!0,1),edge4:u(!0,1),...t?{label:"Back"}:{}}),...h.generate(e,{width:n,height:i,edge1:{kind:"ButtJoint",params:{invert:!1,length1:0,length2:1}},edge2:u(!0,1),edge3:c(!0,1,{kind:"LegEdge",params:{flatWidth:.1,curveWidth:.15,curveAmount:.05,height:10}}),edge4:u(!0,1),...t?{label:"Inner Back"}:{}})]}}class G extends q{name(){return"BoxTuck"}schema(){return{properties:{thickness:{type:"float64",nullable:!0,metadata:{default:.3,nullHint:"default",title:"Material Thickness (units)"}},kerf:{type:"float64",nullable:!0,metadata:{default:null,defaultNotNull:.1,nullHint:"default",title:"Kerf (units)",description:"Thickness of material removed by cutting tool"}},width:{type:"float64",metadata:{default:100,title:"Inner Width (units)"}},depth:{type:"float64",metadata:{default:20,title:"Inner Depth (units)"}},height:{type:"float64",metadata:{default:100,title:"Inner Height (units)"}},scorePadding:{type:"float64",metadata:{default:1,title:"Score Padding (units)"}},notchWidth:{type:"float64",metadata:{default:7,title:"Notch Width (units)"}},notchHeight:{type:"float64",metadata:{default:2,title:"Notch Height (units)"}}},metadata:{order:["thickness","kerf","width","depth","height","scorePadding","notchWidth","notchHeight"]}}}generate(e,{thickness:t,kerf:n,width:s,depth:i,height:a,scorePadding:o,notchWidth:r,notchHeight:l}){const h="number"==typeof t?t:e.defaultThickness,c="number"==typeof n?n:e.defaultKerf;let u=new B(h,c);const d=s,p=a,f=0+d,g=i+h,m=a,v=f+g,b=s+h,w=a,T=v+b,y=i+h,k=a,P=i+h;u=u.unionBorder(E.shape().rect(0,0,d,p).rect(f,0,g,m).rect(v,0,b,w).rect(T,0,y,k).rect(0,0,d,-P).rect(0,0+p,d,P)),u=u.unionBorder(E.shape().moveTo(0,0).bezierCurveTo(.75*-i,0,.75*-i,0,.75*-i,.75*i).lineTo(.75*-i,a-.75*i).bezierCurveTo(.75*-i,a,.75*-i,a,0,a).closePath()),u=u.unionBorder(E.shape().moveTo(0,0-P).bezierCurveTo(0,0-P-.9*i,0,0-P-.9*i,0+.9*i,0-P-.9*i).lineTo(0+d-.9*i,0-P-.9*i).bezierCurveTo(0+d,0-P-.9*i,0+d,0-P-.9*i,0+d,0-P).closePath()),u=u.unionBorder(E.shape().moveTo(0,0+p+P).bezierCurveTo(0,0+p+P+.9*i,0,0+p+P+.9*i,0+.9*i,0+p+P+.9*i).lineTo(0+d-.9*i,0+p+P+.9*i).bezierCurveTo(0+d,0+p+P+.9*i,0+d,0+p+P+.9*i,0+d,0+p+P).closePath()),u=u.unionBorder(E.shape().rect(f,0,g-h,-i).combine(E.shape().moveTo(f,0).lineTo(f+.05*g,0-i).lineTo(f,0-i).closePath()).difference().combine(E.shape().moveTo(f+g-h,0).lineTo(f+g-h-.1*r,0-r).lineTo(f+g-h-.2*r,0-r).lineTo(f+g-h-.2*r-.1*(i-r),0-i).lineTo(f+g-h,0-i).closePath()).difference()),u=u.unionBorder(E.shape().rect(f,0+m,g-h,i).combine(E.shape().moveTo(f,0+m).lineTo(f+.05*i,0+m+i).lineTo(f,0+m+i).closePath()).difference().combine(E.shape().moveTo(f+g-h,0+m).lineTo(f+g-h-.1*r,0+m+r).lineTo(f+g-h-.2*r,0+m+r).lineTo(f+g-h-.2*r-.1*(i-r),0+m+i).lineTo(f+g-h,0+m+i).closePath()).difference()),u=u.unionBorder(E.shape().rect(T+h,0,y-h,-i).combine(E.shape().moveTo(T+h,0).lineTo(T+h+.1*r,0-r).lineTo(T+h+.2*r,0-r).lineTo(T+h+.2*r+.1*(i-r),0-i).lineTo(T+h,0-i).closePath()).difference().combine(E.shape().moveTo(T+y,0).lineTo(T+y-.05*i,0-i).lineTo(T+y,0-i).closePath()).difference()),u=u.unionBorder(E.shape().rect(T+h,0+k,y-h,i).combine(E.shape().moveTo(T+h,0+k).lineTo(T+h+.1*r,0+k+r).lineTo(T+h+.2*r,0+k+r).lineTo(T+h+.2*r+.1*(i-r),0+k+i).lineTo(T+h,0+k+i).closePath()).difference().combine(E.shape().moveTo(T+y,0+k).lineTo(T+y-.05*i,0+k+i).lineTo(T+y,0+k+i).closePath()).difference());{const e=o;u=u.replace({cuts:E.shape().moveTo(0,0-P).lineTo(0+r-1,0-P).bezierCurveTo(0+r,0-P,0+r,0-P,0+r,0-P+1).lineTo(0+r,0-P+l).moveTo(0+d,0-P).lineTo(0+d-r+1,0-P).bezierCurveTo(0+d-r,0-P,0+d-r,0-P,0+d-r,0-P+1).lineTo(0+d-r,0-P+l).moveTo(0,0+p+P).lineTo(0+r-1,0+p+P).bezierCurveTo(0+r,0+p+P,0+r,0+p+P,0+r,0+p+P-1).lineTo(0+r,0+p+P-l).moveTo(0+d,0+p+P).lineTo(0+d-r+1,0+p+P).bezierCurveTo(0+d-r,0+p+P,0+d-r,0+p+P,0+d-r,0+p+P-1).lineTo(0+d-r,0+p+P-l),scores:E.shape().moveTo(0+e,0-h).lineTo(0+d-e,0-h).moveTo(0+d,0+e).lineTo(0+d,0+p-e).moveTo(0,0+e).lineTo(0,0+p-e).moveTo(0+e,0+p+h).lineTo(0+d-e,0+p+h).moveTo(0+e+r,0-P).lineTo(0+d-e-r,0-P).moveTo(0+e+r,0+p+P).lineTo(0+d-e-r,0+p+P).moveTo(f+e,0).lineTo(f+g-h-e,0).moveTo(f+e,0+m).lineTo(f+g-h-e,0+m).moveTo(f+g,0+e).lineTo(f+g,0+m-e).moveTo(T+h+e,0).lineTo(T+y-e,0).moveTo(T+h+e,0+k).lineTo(T+y-e,0+k).moveTo(T,0+e).lineTo(T,0+k-e)})}return[B.union(u,u)]}}class ee extends q{name(){return"KerfTester"}schema(){return{properties:{labels:{type:"boolean",metadata:{default:!0,title:"Labels"}},width:{type:"float64",metadata:{default:30,title:"Outer Width (units)"}},height:{type:"float64",metadata:{default:15,title:"Outer Height (units)"}},play:{type:"float64",metadata:{default:0,title:"Play",description:"Extra space between fingers (units)"}},testCount:{type:"int32",metadata:{default:8,title:"Number of tests"}},kerfStart:{type:"float64",metadata:{default:.08,title:"Kerf start value (units)"}},kerfIncrement:{type:"float64",metadata:{default:.02,title:"Kerf increment value (per test)"}}},metadata:{order:["labels","width","height","play","testCount","kerfStart","kerfIncrement"]}}}generate(e,{labels:t,width:n,height:s,play:i,testCount:a,kerfStart:o,kerfIncrement:r}){const{defaultThickness:l}=e,h=new X,c=e=>({kind:"BoxJoint",params:{invert:e,width1:2*l,length1:1,width2:2*l,length2:1,play:i,cornerDistance:2*l,centerDistance:0}}),u=[];for(let i=0;i<a;i++){const a=o+i*r;u.push(...h.generate(e,{width:n,height:s,kerf:a,edge1:c(!1),edge2:{kind:"ButtJoint",params:{invert:!1,length1:0,length2:1}},edge3:{kind:"ButtJoint",params:{invert:!1,length1:0,length2:1}},edge4:{kind:"ButtJoint",params:{invert:!1,length1:0,length2:1}},...t?{label:a.toFixed(3)}:{}}),...h.generate(e,{width:n,height:s,kerf:a,edge1:{kind:"ButtJoint",params:{invert:!1,length1:0,length2:1}},edge2:{kind:"ButtJoint",params:{invert:!1,length1:0,length2:1}},edge3:c(!0),edge4:{kind:"ButtJoint",params:{invert:!1,length1:0,length2:1}},...t?{label:a.toFixed(3)}:{}}))}return u}}class te extends q{name(){return"TubeTab"}schema(){return{properties:{thickness:{type:"float64",nullable:!0,metadata:{default:.3,nullHint:"default",title:"Material Thickness (units)"}},kerf:{type:"float64",nullable:!0,metadata:{default:null,defaultNotNull:.1,nullHint:"default",title:"Kerf (units)",description:"Thickness of material removed by cutting tool"}},width:{type:"float64",metadata:{default:100,title:"Inner Width (units)"}},depth:{type:"float64",metadata:{default:20,title:"Inner Depth (units)"}},height:{type:"float64",metadata:{default:100,title:"Inner Height (units)"}},scorePadding:{type:"float64",metadata:{default:1,title:"Score Padding (units)"}},tabWidth:{type:"float64",metadata:{default:10,title:"Tab Width (units)"}},tabHeight:{type:"float64",metadata:{default:20,title:"Tab Height (units)"}},tabInnerCut:{type:"float64",metadata:{default:1,title:"Tab Inner Cut (units)"}},tabCount:{type:"float64",metadata:{default:2,title:"Tab Count"}},receiverWidth:{type:"float64",metadata:{default:10,title:"Receiver Width (units)"}}},metadata:{order:["thickness","kerf","width","depth","height","scorePadding","tabWidth","tabHeight","tabInnerCut","tabCount","receiverWidth"]}}}generate(e,{thickness:t,kerf:n,width:s,depth:i,height:a,scorePadding:o,tabWidth:r,tabHeight:l,tabInnerCut:h,tabCount:c,receiverWidth:u}){const d="number"==typeof t?t:e.defaultThickness,p="number"==typeof n?n:e.defaultKerf;let f=new B(d,p);const g=s,m=a,v=0+g,b=i+d,w=a,T=v+b,y=s+d,k=a,P=T+y,M=i+d,x=a,D=[];for(let e=0;e<c;e++){const t=a*e/c,n=a*(e+1)/c,s=Math.min(n-t,l),i=(t+n-s)/2;D.push({top:t,y:i,h:s,bottom:n})}f=f.unionBorder(E.shape().rect(0,0,g,m).rect(v,0,b,w).rect(T,0,y,k).rect(P,0,M,x)),f=f.unionBorder(E.shape().moveTo(0,0).bezierCurveTo(-u,0,-u,0,-u,u).lineTo(-u,a-u).bezierCurveTo(-u,a,-u,a,0,a).closePath());for(const{y:e,h:t}of D)f=f.unionBorder(E.shape().moveTo(P+M,e+h).lineTo(P+M+d,e+h).lineTo(P+M+d,e).lineTo(P+M+d+r,e).lineTo(P+M+d+r,e+t).lineTo(P+M+d,e+t).lineTo(P+M+d,e+t-h).lineTo(P+M,e+t-h).closePath().combine(E.shape().moveTo(P+M+d,e).lineTo(P+M+d+r,e+t/3).lineTo(P+M+d+r,e).closePath()).difference().combine(E.shape().moveTo(P+M+d,e+t).lineTo(P+M+d+r,e+2*t/3).lineTo(P+M+d+r,e+t).closePath()).difference());{const e=o,t=E.shape(),n=E.shape().moveTo(0+g,0+e).lineTo(0+g,0+m-e).moveTo(v+b,0+e).lineTo(v+b,0+w-e).moveTo(P,0+e).lineTo(P,0+x-e);for(const{top:s,y:i,h:o,bottom:r}of D)n.moveTo(0,0===s?e:s).lineTo(0,i-e).moveTo(0,i+o+e).lineTo(0,r===a?r-e:r).moveTo(P+M,i+h+e).lineTo(P+M,i+o-h-e),t.moveTo(0,i).bezierCurveTo(0-d,i,0-d,i,0-d,i+d).lineTo(0-d,i+o-d).bezierCurveTo(0-d,i+o,0-d,i+o,0,i+o);f=f.replace({cuts:t,scores:n})}return[B.union(f,f)]}}const ne=[new Z,new Y,new G,new ee,new X,new te],se={properties:{defaultThickness:{type:"float64",metadata:{default:3,title:"Default Material Thickness (units)"}},defaultKerf:{type:"float64",metadata:{default:.1,title:"Default Kerf (units)",description:"Thickness of material removed by cutting tool"}},units:{enum:["mm","in"],metadata:{default:"mm",title:"Units"}},fileFormat:{enum:["svg"],metadata:{default:"svg",title:"File Format"}},debug:{type:"boolean",metadata:{default:!1,title:"Debug"}}},metadata:{title:"Settings",order:["defaultThickness","defaultKerf","units","fileFormat","debug"],startHidden:!0}};export{C as ApplyKerf,$ as BoxJoint,Z as BoxNested,Y as BoxPlain,G as BoxTuck,R as ButtJoint,I as DocumentBase,F as DocumentSVG,W as EdgeBase,q as GeneratorBase,N as JointBase,ee as KerfTester,_ as LegEdge,A as MortiseAndTenonJoint,X as Rectangle,se as SettingsTypeDef,P as Shape,B as Surface,te as TubeTab,j as allEdges,U as allEdgesTypeDef,ne as allGenerators,O as allJoints,L as boxJointFingerSpacer,J as edgeListTypeDef,H as exportDocument,S as geo,E as polybool};
