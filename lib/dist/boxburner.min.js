function t(t,e,n){return t+(e-t)*n}function e(e,n,s){return[t(e[0],n[0],s),t(e[1],n[1],s)]}class n{}class s extends n{constructor(t=1e-10){super(),this.epsilon=t}snap0(t){return Math.abs(t)<this.epsilon?0:t}snap01(t){return Math.abs(t)<this.epsilon?0:Math.abs(1-t)<this.epsilon?1:t}isCollinear(t,e,n){const s=t[0]-e[0],i=t[1]-e[1],a=e[0]-n[0],r=e[1]-n[1];return Math.abs(s*r-a*i)<this.epsilon}solveCubicNormalized(t,e,n){const s=t/3,i=e/3,a=s*s-i,r=s*(s*s-e/2)+n/2;if(Math.abs(r)<this.epsilon&&Math.abs(a)<this.epsilon)return[-s];const o=s*(s*(4*s*n-i*e)-2*e*n)+4*i*i*i+n*n;if(Math.abs(o)<this.epsilon){const e=Math.sqrt(a);return r>0?[-2*e-t/3,e-t/3]:[-e-t/3,2*e-t/3]}const l=a*a*a,h=r*r;if(h<l){const t=(r<0?-1:1)*Math.sqrt(h/l),e=Math.acos(t),n=-2*Math.sqrt(a);return[n*Math.cos(e/3)-s,n*Math.cos((e+2*Math.PI)/3)-s,n*Math.cos((e-2*Math.PI)/3)-s].sort(((t,e)=>t-e))}{const t=(r<0?1:-1)*Math.pow(Math.abs(r)+Math.sqrt(h-l),1/3);return[t+(Math.abs(t)>=this.epsilon?a/t:0)-s]}}solveCubic(t,e,n,s){if(Math.abs(t)<this.epsilon){if(Math.abs(e)<this.epsilon)return Math.abs(n)<this.epsilon?Math.abs(s)<this.epsilon?[0]:[]:[-s/n];const t=2*e;let i=n*n-4*e*s;return Math.abs(i)<this.epsilon?[-n/t]:i>0?(i=Math.sqrt(i),[(-n+i)/t,(-n-i)/t].sort(((t,e)=>t-e))):[]}return this.solveCubicNormalized(e/t,n/t,s/t)}isEqualVec2(t,e){return Math.abs(t[0]-e[0])<this.epsilon&&Math.abs(t[1]-e[1])<this.epsilon}compareVec2(t,e){return Math.abs(e[0]-t[0])<this.epsilon?Math.abs(e[1]-t[1])<this.epsilon?0:t[1]<e[1]?-1:1:t[0]<e[0]?-1:1}}class i{constructor(t){this.tValues=[],this.geo=t}addArray(t){for(const e of t)this.tValues.push(e);return this}add(t){if((t=this.geo.snap01(t))<0||t>1)return this;for(const e of this.tValues)if(0===this.geo.snap0(t-e))return this;return this.tValues.push(t),this}list(){return this.tValues.sort(((t,e)=>t-e)),this.tValues}}class a{constructor(t,e){this.tValuePairs=[],this.allowOutOfRange=t,this.geo=e}add(t,e){if(t=this.geo.snap01(t),e=this.geo.snap01(e),!this.allowOutOfRange&&(t<0||t>1||e<0||e>1))return this;for(const n of this.tValuePairs)if(0===this.geo.snap0(t-n[0])||0===this.geo.snap0(e-n[1]))return this;return this.tValuePairs.push([t,e]),this}list(){return this.tValuePairs.sort(((t,e)=>t[0]-e[0])),this.tValuePairs}done(){return this.tValuePairs.length<=0?null:{kind:"tValuePairs",tValuePairs:this.list()}}}class r{}class o extends r{constructor(t,e,n){super(),this.p0=t,this.p1=e,this.geo=n}copy(){return new o(this.p0,this.p1,this.geo)}isEqual(t){return this.geo.isEqualVec2(this.p0,t.p0)&&this.geo.isEqualVec2(this.p1,t.p1)}start(){return this.p0}start2(){return this.p1}end2(){return this.p0}end(){return this.p1}setStart(t){this.p0=t}setEnd(t){this.p1=t}point(t){const e=this.p0,n=this.p1;return 0===t?e:1===t?n:[e[0]+(n[0]-e[0])*t,e[1]+(n[1]-e[1])*t]}split(t){if(t.length<=0)return[this];const e=t.map((t=>this.point(t)));e.push(this.p1);const n=[];let s=this.p0;for(const t of e)n.push(new o(s,t,this.geo)),s=t;return n}reverse(){return new o(this.p1,this.p0,this.geo)}boundingBox(){const t=this.p0,e=this.p1;return[[Math.min(t[0],e[0]),Math.min(t[1],e[1])],[Math.max(t[0],e[0]),Math.max(t[1],e[1])]]}pointOn(t){return this.geo.isCollinear(t,this.p0,this.p1)}draw(t){const e=this.p0,n=this.p1;return t.moveTo(e[0],e[1]),t.lineTo(n[0],n[1]),t}}class l extends r{constructor(t,e,n,s,i){super(),this.p0=t,this.p1=e,this.p2=n,this.p3=s,this.geo=i}copy(){return new l(this.p0,this.p1,this.p2,this.p3,this.geo)}isEqual(t){return this.geo.isEqualVec2(this.p0,t.p0)&&this.geo.isEqualVec2(this.p1,t.p1)&&this.geo.isEqualVec2(this.p2,t.p2)&&this.geo.isEqualVec2(this.p3,t.p3)}start(){return this.p0}start2(){return this.p1}end2(){return this.p2}end(){return this.p3}setStart(t){this.p0=t}setEnd(t){this.p3=t}point(t){const e=this.p0,n=this.p1,s=this.p2,i=this.p3;if(0===t)return e;if(1===t)return i;const a=(1-t)*(1-t),r=t*t,o=a*(1-t),l=3*a*t,h=3*r*(1-t),c=r*t;return[e[0]*o+n[0]*l+s[0]*h+i[0]*c,e[1]*o+n[1]*l+s[1]*h+i[1]*c]}split(t){if(t.length<=0)return[this];const n=[],s=(t,s)=>{const[i,a,r,o]=t,h=e(i,a,s),c=e(a,r,s),u=e(r,o,s),d=e(h,c,s),p=e(c,u,s),g=e(d,p,s);return n.push(new l(i,h,d,g,this.geo)),[g,p,u,o]};let i=[this.p0,this.p1,this.p2,this.p3],a=0;for(const e of t)i=s(i,(e-a)/(1-a)),a=e;return n.push(new l(i[0],i[1],i[2],i[3],this.geo)),n}reverse(){return new l(this.p3,this.p2,this.p1,this.p0,this.geo)}getCubicCoefficients(t){const e=this.p0[t],n=this.p1[t],s=this.p2[t];return[this.p3[t]-3*s+3*n-e,3*s-6*n+3*e,3*n-3*e,e]}boundingTValues(){const t=new i(this.geo),e=(e,n,s,i)=>{const a=3*i-9*s+9*n-3*e,r=6*e-12*n+6*s,o=3*n-3*e;if(0===this.geo.snap0(a))t.add(-o/r);else{const e=r*r-4*a*o;if(e>=0){const n=Math.sqrt(e);t.add((-r+n)/(2*a)),t.add((-r-n)/(2*a))}}return t},n=this.p0,s=this.p1,a=this.p2,r=this.p3;return e(n[0],s[0],a[0],r[0]),e(n[1],s[1],a[1],r[1]),t.list()}inflectionTValues(){const t=new i(this.geo);t.addArray(this.boundingTValues());const e=this.p0,n=this.p1,s=this.p2,a=this.p3,r=3*(n[0]-e[0]),o=3*(n[1]-e[1]),l=6*(s[0]-n[0]),h=6*(s[1]-n[1]),c=3*(a[0]-s[0]),u=3*(a[1]-s[1]),d=6*(s[0]-2*n[0]+e[0]),p=6*(s[1]-2*n[1]+e[1]),g=r-l+c,f=o-h+u,m=l-2*r,v=h-2*o,w=6*(a[0]-2*s[0]+n[0])-d,b=6*(a[1]-2*s[1]+n[1])-p,y=g*b-f*w,k=g*p+m*b-f*d-v*w,P=m*p+r*b-v*d-o*w,M=r*p-o*d;for(const e of this.geo.solveCubic(y,k,P,M))t.add(e);return t.list()}boundingBox(){const t=this.p0,e=this.p3,n=[Math.min(t[0],e[0]),Math.min(t[1],e[1])],s=[Math.max(t[0],e[0]),Math.max(t[1],e[1])];for(const t of this.boundingTValues()){const e=this.point(t);n[0]=Math.min(n[0],e[0]),n[1]=Math.min(n[1],e[1]),s[0]=Math.max(s[0],e[0]),s[1]=Math.max(s[1],e[1])}return[n,s]}mapXtoT(t,e=!1){if(0===this.geo.snap0(this.p0[0]-t))return 0;if(0===this.geo.snap0(this.p3[0]-t))return 1;const n=this.p0[0]-t,s=this.p1[0]-t,i=this.p2[0]-t,a=[this.p3[0]-t-3*i+3*s-n,3*i-6*s+3*n,3*s-3*n,n];for(const t of this.geo.solveCubic(a[0],a[1],a[2],a[3])){const e=this.geo.snap01(t);if(e>=0&&e<=1)return t}if(e||t>=Math.min(this.p0[0],this.p3[0])&&t<=Math.max(this.p0[0],this.p3[0]))for(let t=0;t<4;t++){let t=-1;for(let e=0;e<4;e++)0!==a[e]&&(t<0||Math.abs(a[e])<Math.abs(a[t]))&&(t=e);if(t<0)return 0;a[t]=0;for(const t of this.geo.solveCubic(a[0],a[1],a[2],a[3])){const e=this.geo.snap01(t);if(e>=0&&e<=1)return t}}return!1}mapXtoY(t,e=!1){const n=this.mapXtoT(t,e);return!1!==n&&this.point(n)[1]}pointOn(t){if(this.geo.isEqualVec2(this.p0,t)||this.geo.isEqualVec2(this.p3,t))return!0;const e=this.mapXtoY(t[0]);return!1!==e&&0===this.geo.snap0(e-t[1])}toLine(){const t=this.p0,e=this.p1,n=this.p2,s=this.p3;return 0===this.geo.snap0(t[0]-e[0])&&0===this.geo.snap0(t[0]-n[0])&&0===this.geo.snap0(t[0]-s[0])||0===this.geo.snap0(t[1]-e[1])&&0===this.geo.snap0(t[1]-n[1])&&0===this.geo.snap0(t[1]-s[1])?new o(t,s,this.geo):null}draw(t){const e=this.p0,n=this.p1,s=this.p2,i=this.p3;return t.moveTo(e[0],e[1]),t.bezierCurveTo(n[0],n[1],s[0],s[1],i[0],i[1]),t}}function h(t,e){const n=e.p1[0]-e.p0[0],s=e.p1[1]-e.p0[1];return((t[0]-e.p0[0])*n+(t[1]-e.p0[1])*s)/(n*n+s*s)}function c(t,e,n,s){const i=t.geo,r=t.p0,o=t.p1,l=o[1]-r[1],h=r[0]-o[0];if(0===i.snap0(h)){const t=e.mapXtoT(r[0],!1);if(!1===t)return null;const o=(e.point(t)[1]-r[1])/l,h=new a(n,i);return s?h.add(t,o):h.add(o,t),h.done()}const c=l*r[0]+h*r[1],u=e.getCubicCoefficients(0),d=e.getCubicCoefficients(1),p=l*u[0]+h*d[0],g=l*u[1]+h*d[1],f=l*u[2]+h*d[2],m=l*u[3]+h*d[3]-c,v=i.solveCubic(p,g,f,m),w=new a(n,i);if(0===i.snap0(l))for(const t of v){const e=u[0]*t*t*t+u[1]*t*t+u[2]*t+u[3],n=(r[0]-e)/h;s?w.add(t,n):w.add(n,t)}else for(const t of v){const e=(d[0]*t*t*t+d[1]*t*t+d[2]*t+d[3]-r[1])/l;s?w.add(t,e):w.add(e,t)}return w.done()}function u(t,e,n){if(t instanceof o){if(e instanceof o)return function(t,e,n){const s=t.geo,i=t.p0,r=t.p1,o=e.p0,l=e.p1,c=r[0]-i[0],u=r[1]-i[1],d=l[0]-o[0],p=l[1]-o[1],g=c*p-u*d;if(0===s.snap0(g)){if(!s.isCollinear(i,r,o))return null;const n=h(e.p0,t),a=h(e.p1,t),l=s.snap01(Math.min(n,a)),c=s.snap01(Math.max(n,a));if(c<0||l>1)return null;const u=h(t.p0,e),d=h(t.p1,e),p=s.snap01(Math.min(u,d)),g=s.snap01(Math.max(u,d));return g<0||p>1?null:{kind:"tRangePairs",tStart:[Math.max(0,l),Math.max(0,p)],tEnd:[Math.min(1,c),Math.min(1,g)]}}const f=i[0]-o[0],m=i[1]-o[1];return new a(n,s).add((d*m-p*f)/g,(c*m-u*f)/g).done()}(t,e,n);if(e instanceof l)return c(t,e,n,!1)}else if(t instanceof l){if(e instanceof o)return c(e,t,n,!0);if(e instanceof l)return function(t,e,n){const s=t.geo;if(s.isEqualVec2(t.p0,e.p0))return s.isEqualVec2(t.p3,e.p3)?s.isEqualVec2(t.p1,e.p1)&&s.isEqualVec2(t.p2,e.p2)?{kind:"tRangePairs",tStart:[0,0],tEnd:[1,1]}:{kind:"tValuePairs",tValuePairs:[[0,0],[1,1]]}:{kind:"tValuePairs",tValuePairs:[[0,0]]};if(s.isEqualVec2(t.p0,e.p3))return{kind:"tValuePairs",tValuePairs:[[0,1]]};if(s.isEqualVec2(t.p3,e.p0))return{kind:"tValuePairs",tValuePairs:[[1,0]]};if(s.isEqualVec2(t.p3,e.p3))return{kind:"tValuePairs",tValuePairs:[[1,1]]};const i=new a(n,s),r=(t,e,n,a,o,l)=>{if(!function(t,e){const[n,s]=t,[i,a]=e;return!(n[0]>a[0]||s[0]<i[0]||n[1]>a[1]||s[1]<i[1])}(t.boundingBox(),a.boundingBox()))return;const h=(e+n)/2,c=(o+l)/2;if(0===s.snap0(n-e)&&0===s.snap0(l-o))return void i.add(h,c);const[u,d]=t.split([.5]),[p,g]=a.split([.5]);r(u,e,h,p,o,c),r(d,h,n,p,o,c),r(u,e,h,g,c,l),r(d,h,n,g,c,l)};return r(t,0,1,e,0,1),i.done()}(t,e,n)}throw new Error("PolyBool: Unknown segment instance in segmentsIntersect")}class d{constructor(t,e=null,n=!1,s=null){var i,a,r;this.otherFill=null,this.id=null!==(i=null==s?void 0:s.segmentId())&&void 0!==i?i:-1,this.data=t,this.myFill={above:null!==(a=null==e?void 0:e.above)&&void 0!==a?a:null,below:null!==(r=null==e?void 0:e.below)&&void 0!==r?r:null},this.closed=n}}class p extends d{}class g extends d{}function f(t,e){if(t instanceof p)return new p(t.data,t.myFill,t.closed,e);if(t instanceof g)return new g(t.data,t.myFill,t.closed,e);throw new Error("PolyBool: Unknown SegmentBool in copySegmentBool")}class m{constructor(t,e,n,s){this.status=null,this.isStart=t,this.p=e,this.seg=n,this.primary=s}}class v{constructor(){this.nodes=[]}remove(t){const e=this.nodes.indexOf(t);e>=0&&this.nodes.splice(e,1)}getIndex(t){return this.nodes.indexOf(t)}isEmpty(){return this.nodes.length<=0}getHead(){return this.nodes[0]}removeHead(){this.nodes.shift()}insertBefore(t,e){this.findTransition(t,e).insert(t)}findTransition(t,e){var n,s;let i=0,a=this.nodes.length;for(;i<a;){const n=i+a>>1;r=this.nodes[n],e(t)-e(r)>0?a=n:i=n+1}var r;return{before:i<=0?null:null!==(n=this.nodes[i-1])&&void 0!==n?n:null,after:null!==(s=this.nodes[i])&&void 0!==s?s:null,insert:t=>(this.nodes.splice(i,0,t),t)}}}class w{constructor(t,e,n=null){this.events=new v,this.status=new v,this.currentPath=[],this.selfIntersection=t,this.geo=e,this.log=n}compareEvents(t,e,n,s,i,a,r,l){const h=this.geo.compareVec2(e,a);return 0!==h?h:s instanceof o&&l instanceof o&&this.geo.isEqualVec2(n,r)?0:t!==i?t?1:-1:this.compareSegments(l,s)}addEvent(t){this.events.insertBefore(t,(e=>e===t?0:this.compareEvents(t.isStart,t.p,t.other.p,t.seg.data,e.isStart,e.p,e.other.p,e.seg.data)))}divideEvent(t,e,n){var s,i;null===(s=this.log)||void 0===s||s.segmentDivide(t.seg,n);const[a,r]=t.seg.data.split([e]);a.setEnd(n),r.setStart(n);const h=r instanceof o?new p(r,t.seg.myFill,t.seg.closed,this.log):r instanceof l?new g(r,t.seg.myFill,t.seg.closed,this.log):null;if(!h)throw new Error("PolyBool: Unknown segment data in divideEvent");return this.events.remove(t.other),t.seg.data=a,null===(i=this.log)||void 0===i||i.segmentChop(t.seg),t.other.p=n,this.addEvent(t.other),this.addSegment(h,t.primary)}beginPath(){this.currentPath=[]}closePath(){for(const t of this.currentPath)t.closed=!0}addSegment(t,e){const n=new m(!0,t.data.start(),t,e),s=new m(!1,t.data.end(),t,e);return n.other=s,s.other=n,this.addEvent(n),this.addEvent(s),n}addLine(t,e,n=!0){const s=this.geo.compareVec2(t,e);if(0===s)return;const i=new p(new o(s<0?t:e,s<0?e:t,this.geo),null,!1,this.log);this.currentPath.push(i),this.addSegment(i,n)}addCurve(t,e,n,s,i=!0){const a=new l(t,e,n,s,this.geo),r=a.split(a.inflectionTValues());for(const t of r){const e=this.geo.compareVec2(t.start(),t.end());if(0===e)continue;const n=t.toLine();if(n)this.addLine(n.p0,n.p1,i);else{const n=new g(e<0?t:t.reverse(),null,!1,this.log);this.currentPath.push(n),this.addSegment(n,i)}}}compareSegments(t,e){let n=t.start(),s=e.start2();const i=e.start();if(e.pointOn(n)){if(n=t.start2(),e.pointOn(n)){if(t instanceof o){if(e instanceof o)return 0;e instanceof l&&(n=t.point(.5))}t instanceof l&&(n=t.end())}if(e instanceof l&&0===this.geo.snap0(n[0]-i[0])&&0===this.geo.snap0(s[0]-i[0]))return Math.sign(i[1]-n[1])}else{if(e instanceof l){const t=e.mapXtoY(n[0],!0);if(!1!==t)return Math.sign(t-n[1])}if(t instanceof l){const n=u(t,e,!0);if(n&&"tValuePairs"===n.kind)for(const e of n.tValuePairs){const n=this.geo.snap01(e[0]);if(n>0&&n<1){s=t.point(n);break}}}}const[a,r]=n,[h,c]=s,[d,p]=i;return Math.sign((h-a)*(p-r)-(c-r)*(d-a))}statusFindSurrounding(t){return this.status.findTransition(t,(e=>{if(t===e)return 0;const n=this.compareSegments(t.seg.data,e.seg.data);return 0===n?-1:n}))}checkIntersection(t,e){var n;const s=t.seg,i=e.seg;null===(n=this.log)||void 0===n||n.checkIntersection(s,i);const a=u(s.data,i.data,!1);if(null===a)return null;if("tRangePairs"===a.kind){const{tStart:[n,r],tEnd:[o,l]}=a;if(1===n&&1===o&&0===r&&0===l||0===n&&0===o&&1===r&&1===l)return null;if(0===n&&1===o&&0===r&&1===l)return e;const h=s.data.start(),c=s.data.end(),u=i.data.end();return 0===n&&0===r?(1===o?this.divideEvent(e,l,c):this.divideEvent(t,o,u),e):(r>0&&r<1&&(1===o&&1===l||(1===o?this.divideEvent(e,l,c):this.divideEvent(t,o,u)),this.divideEvent(e,r,h)),null)}if("tValuePairs"===a.kind){if(a.tValuePairs.length<=0)return null;let n=a.tValuePairs[0];for(let t=1;t<a.tValuePairs.length&&(0===n[0]&&0===n[1]||0===n[0]&&1===n[1]||1===n[0]&&0===n[1]||1===n[0]&&1===n[1]);t++)n=a.tValuePairs[t];const[r,o]=n,l=0===o?i.data.start():1===o?i.data.end():0===r?s.data.start():1===r?s.data.end():s.data.point(r);return r>0&&r<1&&this.divideEvent(t,r,l),o>0&&o<1&&this.divideEvent(e,o,l),null}throw new Error("PolyBool: Unknown intersection type")}calculate(){var t,e,n,s,i,a,r,o;const l=[];for(;!this.events.isEmpty();){const o=this.events.getHead();if(null===(t=this.log)||void 0===t||t.vert(o.p[0]),o.isStart){null===(e=this.log)||void 0===e||e.segmentNew(o.seg,o.primary);const t=this.statusFindSurrounding(o),r=t.before,l=t.after;null===(n=this.log)||void 0===n||n.tempStatus(o.seg,!!r&&r.seg,!!l&&l.seg);const h=()=>{if(r){const t=this.checkIntersection(o,r);if(t)return t}return l?this.checkIntersection(o,l):null},c=h();if(c){if(this.selfIntersection){let t;t=null===o.seg.myFill.below?o.seg.closed:o.seg.myFill.above!==o.seg.myFill.below,t&&(c.seg.myFill.above=!c.seg.myFill.above)}else c.seg.otherFill=o.seg.myFill;null===(s=this.log)||void 0===s||s.segmentUpdate(c.seg),this.events.remove(o.other),this.events.remove(o)}if(this.events.getHead()!==o){null===(i=this.log)||void 0===i||i.rewind(o.seg);continue}if(this.selfIntersection){let t;t=null===o.seg.myFill.below?o.seg.closed:o.seg.myFill.above!==o.seg.myFill.below,o.seg.myFill.below=!!l&&l.seg.myFill.above,o.seg.myFill.above=t?!o.seg.myFill.below:o.seg.myFill.below}else if(null===o.seg.otherFill){let t;if(l)if(o.primary===l.primary){if(null===l.seg.otherFill)throw new Error("PolyBool: Unexpected state of otherFill (null)");t=l.seg.otherFill.above}else t=l.seg.myFill.above;else t=!1;o.seg.otherFill={above:t,below:t}}null===(a=this.log)||void 0===a||a.status(o.seg,!!r&&r.seg,!!l&&l.seg),o.other.status=t.insert(o)}else{const t=o.status;if(null===t)throw new Error("PolyBool: Zero-length segment detected; your epsilon is probably too small or too large");const e=this.status.getIndex(t);if(e>0&&e<this.status.nodes.length-1){const t=this.status.nodes[e-1],n=this.status.nodes[e+1];this.checkIntersection(t,n)}if(null===(r=this.log)||void 0===r||r.statusRemove(t.seg),this.status.remove(t),!o.primary){if(!o.seg.otherFill)throw new Error("PolyBool: Unexpected state of otherFill (null)");const t=o.seg.myFill;o.seg.myFill=o.seg.otherFill,o.seg.otherFill=t}l.push(o.seg)}this.events.removeHead()}return null===(o=this.log)||void 0===o||o.done(),l}}function b(t,e,n){const s=[];for(const i of t){const t=e[(i.myFill.above?8:0)+(i.myFill.below?4:0)+(i.otherFill&&i.otherFill.above?2:0)+(i.otherFill&&i.otherFill.below?1:0)],a=!!(1&t),r=!!(2&t);if(!i.closed&&0!==t||i.closed&&a!==r){const t={above:a,below:r};if(i instanceof p)s.push(new p(i.data,t,i.closed,n));else{if(!(i instanceof g))throw new Error("PolyBool: Unknown SegmentBool type in SegmentSelector");s.push(new g(i.data,t,i.closed,n))}}}return null==n||n.selected(s),s}class y{static union(t,e){return b(t,[4,2,1,0,2,2,0,0,1,0,1,0,0,0,0,0],e)}static intersect(t,e){return b(t,[0,0,0,4,0,2,0,2,0,0,1,1,4,2,1,0],e)}static difference(t,e){return b(t,[4,0,0,0,2,0,2,0,1,1,0,0,0,1,2,0],e)}static differenceRev(t,e){return b(t,[4,2,1,0,0,0,1,1,0,2,0,2,0,0,0,0],e)}static xor(t,e){return b(t,[4,2,1,0,2,0,0,1,1,0,0,2,0,1,2,0],e)}}function k(t,e,n){return t!==e&&(t instanceof o&&e instanceof o?function(t,e,n){return!!n.isCollinear(t.p0,t.p1,e.p1)&&new o(t.p0,e.p1,n)}(t,e,n):t instanceof l&&e instanceof l&&function(t,e,n){if(n.isCollinear(t.p2,t.p3,e.p1)){const s=e.p1[0]-t.p2[0],i=e.p1[1]-t.p2[1],a=Math.abs(s)>Math.abs(i)?(t.p3[0]-t.p2[0])/s:(t.p3[1]-t.p2[1])/i,r=n.snap01(a);if(0!==r&&1!==r){const s=new l(t.p0,[t.p0[0]+(t.p1[0]-t.p0[0])/a,t.p0[1]+(t.p1[1]-t.p0[1])/a],[e.p2[0]-a*(e.p3[0]-e.p2[0])/(1-a),e.p2[1]-a*(e.p3[1]-e.p2[1])/(1-a)],e.p3,n),[i,r]=s.split([a]);if(i.isEqual(t)&&r.isEqual(e))return s}}return!1}(t,e,n))}function P(t,e,n){const s=[],i=[],a=[];for(const r of t){let l=r.data;const h=r.closed,c=h?s:i,u=l.start(),d=l.end(),p=t=>{null==n||n.chainReverse(t,h);const e=[];for(const n of c[t].segs)e.unshift(n.reverse());return c[t]={segs:e,fill:!c[t].fill},e};if(l instanceof o&&e.isEqualVec2(u,d)){console.warn("PolyBool: Warning: Zero-length segment detected; your epsilon is probably too small or too large");continue}null==n||n.chainStart({seg:l,fill:!!r.myFill.above},h);const g={index:0,matchesHead:!1,matchesPt1:!1},f={index:0,matchesHead:!1,matchesPt1:!1};let m=g;function v(t,e,n){return m&&(m.index=t,m.matchesHead=e,m.matchesPt1=n),m===g?(m=f,!1):(m=null,!0)}for(let w=0;w<c.length;w++){const b=c[w].segs,y=b[0].start(),P=b[b.length-1].end();if(e.isEqualVec2(y,u)){if(v(w,!0,!0))break}else if(e.isEqualVec2(y,d)){if(v(w,!0,!1))break}else if(e.isEqualVec2(P,u)){if(v(w,!1,!0))break}else if(e.isEqualVec2(P,d)&&v(w,!1,!1))break}if(m===g){const M=!!r.myFill.above;c.push({segs:[l],fill:M}),null==n||n.chainNew({seg:l,fill:M},h)}else if(m===f){const x=g.index;null==n||n.chainMatch(x,h);const{segs:D,fill:S}=c[x];if(g.matchesHead?g.matchesPt1?(l=l.reverse(),null==n||n.chainAddHead(x,{seg:l,fill:S},h),D.unshift(l)):(null==n||n.chainAddHead(x,{seg:l,fill:S},h),D.unshift(l)):g.matchesPt1?(null==n||n.chainAddTail(x,{seg:l,fill:S},h),D.push(l)):(l=l.reverse(),null==n||n.chainAddTail(x,{seg:l,fill:S},h),D.push(l)),g.matchesHead){const T=D[1],E=k(l,T,e);E&&(D.shift(),D[0]=E,null==n||n.chainSimplifyHead(x,{seg:E,fill:S},h))}else{const B=k(D[D.length-2],l,e);B&&(D.pop(),D[D.length-1]=B,null==n||n.chainSimplifyTail(x,{seg:B,fill:S},h))}if(h){let C=D,V=C[0],F=C[C.length-1];if(C.length>0&&e.isEqualVec2(V.start(),F.end())){let I=0,q=C[0].start();for(const L of C){const R=L.end();I+=R[1]*q[0]-R[0]*q[1],q=R}I<0===S&&(C=p(x),V=C[0],F=C[C.length-1]);const H=k(F,V,e);H&&(C.pop(),C[0]=H,null==n||n.chainSimplifyClose(x,{seg:H,fill:S},h)),null==n||n.chainClose(x,h),c.splice(x,1),a.push(C)}}}else{const $=(t,s)=>{const{segs:i,fill:a}=c[t],{segs:r}=c[s];null==n||n.chainAddTail(t,{seg:l,fill:a},h),i.push(l);const o=k(i[i.length-2],l,e);o&&(i.pop(),i[i.length-1]=o,null==n||n.chainSimplifyTail(t,{seg:o,fill:a},h));const u=k(i[i.length-1],r[0],e);u&&(r.shift(),i[i.length-1]=u,null==n||n.chainSimplifyJoin(t,s,{seg:u,fill:a},h)),null==n||n.chainJoin(t,s,h),c[t].segs=i.concat(r),c.splice(s,1)},_=g.index,J=f.index;null==n||n.chainConnect(_,J,h);const N=c[_].segs.length<c[J].segs.length;g.matchesHead?f.matchesHead?N?(g.matchesPt1||(l=l.reverse()),p(_),$(_,J)):(g.matchesPt1&&(l=l.reverse()),p(J),$(J,_)):(g.matchesPt1&&(l=l.reverse()),$(J,_)):f.matchesHead?(g.matchesPt1||(l=l.reverse()),$(_,J)):N?(g.matchesPt1&&(l=l.reverse()),p(_),$(J,_)):(g.matchesPt1||(l=l.reverse()),p(J),$(_,J))}}for(const{segs:A}of i)a.push(A);return a}class M{constructor(t,e=null,n=null){this.pathState={kind:"beginPath"},this.saveStack=[],this.matrix=[1,0,0,1,0,0],this.geo=t,this.log=n,this.resultState=e?{state:"seg",segments:e}:{state:"new",selfIntersect:new w(!0,this.geo,this.log)}}setTransform(t,e,n,s,i,a){if("new"!==this.resultState.state)throw new Error("PolyBool: Cannot change shape after using it in an operation");return this.matrix=[t,e,n,s,i,a],this}resetTransform(){return this.matrix=[1,0,0,1,0,0],this}getTransform(){if("new"!==this.resultState.state)throw new Error("PolyBool: Cannot change shape after using it in an operation");const[t,e,n,s,i,a]=this.matrix;return{a:t,b:e,c:n,d:s,e:i,f:a}}transform(t,e,n,s,i,a){const[r,o,l,h,c,u]=this.matrix;return this.matrix=[r*t+l*e,o*t+h*e,r*n+l*s,o*n+h*s,r*i+l*a+c,o*i+h*a+u],this}rotate(t){const e=Math.cos(t),n=Math.sin(t),[s,i,a,r,o,l]=this.matrix;return this.matrix=[s*e+a*n,i*e+r*n,a*e-s*n,r*e-i*n,o,l],this}rotateDeg(t){const e=(t%360+360)%360;if(0===e)return this;let n=0,s=0;if(90===e)s=1;else if(180===e)n=-1;else if(270===e)s=-1;else if(45===e)n=s=Math.SQRT1_2;else if(135===e)s=Math.SQRT1_2,n=-Math.SQRT1_2;else if(225===e)n=s=-Math.SQRT1_2;else if(315===e)n=Math.SQRT1_2,s=-Math.SQRT1_2;else if(30===e)n=Math.sqrt(3)/2,s=.5;else if(60===e)n=.5,s=Math.sqrt(3)/2;else if(120===e)n=-.5,s=Math.sqrt(3)/2;else if(150===e)n=-Math.sqrt(3)/2,s=.5;else if(210===e)n=-Math.sqrt(3)/2,s=-.5;else if(240===e)n=-.5,s=-Math.sqrt(3)/2;else if(300===e)n=.5,s=-Math.sqrt(3)/2;else if(330===e)n=Math.sqrt(3)/2,s=-.5;else{const t=Math.PI*e/180;n=Math.cos(t),s=Math.sin(t)}const[i,a,r,o,l,h]=this.matrix;return this.matrix=[i*n+r*s,a*n+o*s,r*n-i*s,o*n-a*s,l,h],this}scale(t,e){const[n,s,i,a,r,o]=this.matrix;return this.matrix=[n*t,s*t,i*e,a*e,r,o],this}translate(t,e){const[n,s,i,a,r,o]=this.matrix;return this.matrix=[n,s,i,a,n*t+i*e+r,s*t+a*e+o],this}save(){if("new"!==this.resultState.state)throw new Error("PolyBool: Cannot change shape after using it in an operation");return this.saveStack.push({matrix:this.matrix}),this}restore(){if("new"!==this.resultState.state)throw new Error("PolyBool: Cannot change shape after using it in an operation");const t=this.saveStack.pop();return t&&(this.matrix=t.matrix),this}transformPoint(t,e){const[n,s,i,a,r,o]=this.matrix;return[n*t+i*e+r,s*t+a*e+o]}beginPath(){if("new"!==this.resultState.state)throw new Error("PolyBool: Cannot change shape after using it in an operation");return this.resultState.selfIntersect.beginPath(),this.endPath()}moveTo(t,e){if("new"!==this.resultState.state)throw new Error("PolyBool: Cannot change shape after using it in an operation");"beginPath"!==this.pathState.kind&&this.beginPath();const n=this.transformPoint(t,e);return this.pathState={kind:"moveTo",start:n,current:n},this}lineTo(t,e){if("new"!==this.resultState.state)throw new Error("PolyBool: Cannot change shape after using it in an operation");if("moveTo"!==this.pathState.kind)throw new Error("PolyBool: Must call moveTo prior to calling lineTo");const n=this.transformPoint(t,e);return this.resultState.selfIntersect.addLine(this.pathState.current,n),this.pathState.current=n,this}rect(t,e,n,s){return this.moveTo(t,e).lineTo(t+n,e).lineTo(t+n,e+s).lineTo(t,e+s).closePath().moveTo(t,e)}bezierCurveTo(t,e,n,s,i,a){if("new"!==this.resultState.state)throw new Error("PolyBool: Cannot change shape after using it in an operation");if("moveTo"!==this.pathState.kind)throw new Error("PolyBool: Must call moveTo prior to calling bezierCurveTo");const r=this.transformPoint(i,a);return this.resultState.selfIntersect.addCurve(this.pathState.current,this.transformPoint(t,e),this.transformPoint(n,s),r),this.pathState.current=r,this}closePath(){if("new"!==this.resultState.state)throw new Error("PolyBool: Cannot change shape after using it in an operation");return"moveTo"!==this.pathState.kind||this.geo.isEqualVec2(this.pathState.start,this.pathState.current)||(this.resultState.selfIntersect.addLine(this.pathState.current,this.pathState.start),this.pathState.current=this.pathState.start),this.resultState.selfIntersect.closePath(),this.endPath()}endPath(){if("new"!==this.resultState.state)throw new Error("PolyBool: Cannot change shape after using it in an operation");return this.pathState={kind:"beginPath"},this}selfIntersect(){return"new"===this.resultState.state&&(this.resultState={state:"seg",segments:this.resultState.selfIntersect.calculate()}),this.resultState.segments}segments(){if("reg"!==this.resultState.state){const t=this.selfIntersect();this.resultState={state:"reg",segments:t,regions:P(t,this.geo,this.log)}}return this.resultState.regions}output(t,e=[1,0,0,1,0,0]){return function(t,e,n,s){const[i,a,r,h,c,u]=s;n.beginPath();for(const s of t){if(s.length<=0)continue;for(let t=0;t<s.length;t++){const e=s[t];if(0===t){const[t,s]=e.start();n.moveTo(i*t+r*s+c,a*t+h*s+u)}if(e instanceof o){const[t,s]=e.p1;n.lineTo(i*t+r*s+c,a*t+h*s+u)}else{if(!(e instanceof l))throw new Error("PolyBool: Unknown segment instance");{const[t,s]=e.p1,[o,l]=e.p2,[d,p]=e.p3;n.bezierCurveTo(i*t+r*s+c,a*t+h*s+u,i*o+r*l+c,a*o+h*l+u,i*d+r*p+c,a*d+h*p+u)}}}const t=s[0],d=s[s.length-1];e.isEqualVec2(t.start(),d.end())&&n.closePath()}return n}(this.segments(),this.geo,t,e)}combine(t){const e=new w(!1,this.geo,this.log);for(const t of this.selfIntersect())e.addSegment(f(t,this.log),!0);for(const n of t.selfIntersect())e.addSegment(f(n,this.log),!1);return new x(e.calculate(),this.geo,this.log)}}class x{constructor(t,e,n=null){this.geo=e,this.segments=t,this.log=n}union(){return new M(this.geo,y.union(this.segments,this.log),this.log)}intersect(){return new M(this.geo,y.intersect(this.segments,this.log),this.log)}difference(){return new M(this.geo,y.difference(this.segments,this.log),this.log)}differenceRev(){return new M(this.geo,y.differenceRev(this.segments,this.log),this.log)}xor(){return new M(this.geo,y.xor(this.segments,this.log),this.log)}}class D{constructor(){this.list=[],this.nextSegmentId=0,this.curVert=NaN}push(t,e){this.list.push({type:t,data:JSON.parse(JSON.stringify(e))})}info(t,e){this.push("info",{msg:t,data:e})}segmentId(){return this.nextSegmentId++}checkIntersection(t,e){this.push("check",{seg1:t,seg2:e})}segmentDivide(t,e){this.push("div_seg",{seg:t,p:e})}segmentChop(t){this.push("chop",{seg:t})}statusRemove(t){this.push("pop_seg",{seg:t})}segmentUpdate(t){this.push("seg_update",{seg:t})}segmentNew(t,e){this.push("new_seg",{seg:t,primary:e})}tempStatus(t,e,n){this.push("temp_status",{seg:t,above:e,below:n})}rewind(t){this.push("rewind",{seg:t})}status(t,e,n){this.push("status",{seg:t,above:e,below:n})}vert(t){t!==this.curVert&&(this.push("vert",{x:t}),this.curVert=t)}selected(t){this.push("selected",{segs:t})}chainStart(t,e){this.push("chain_start",{sf:t,closed:e})}chainNew(t,e){this.push("chain_new",{sf:t,closed:e})}chainMatch(t,e){this.push("chain_match",{index:t,closed:e})}chainClose(t,e){this.push("chain_close",{index:t,closed:e})}chainAddHead(t,e,n){this.push("chain_add_head",{index:t,sf:e,closed:n})}chainAddTail(t,e,n){this.push("chain_add_tail",{index:t,sf:e,closed:n})}chainSimplifyHead(t,e,n){this.push("chain_simp_head",{index:t,sf:e,closed:n})}chainSimplifyTail(t,e,n){this.push("chain_simp_tail",{index:t,sf:e,closed:n})}chainSimplifyClose(t,e,n){this.push("chain_simp_close",{index:t,sf:e,closed:n})}chainSimplifyJoin(t,e,n,s){this.push("chain_simp_join",{index1:t,index2:e,sf:n,closed:s})}chainConnect(t,e,n){this.push("chain_con",{index1:t,index2:e,closed:n})}chainReverse(t,e){this.push("chain_rev",{index:t,closed:e})}chainJoin(t,e,n){this.push("chain_join",{index1:t,index2:e,closed:n})}done(){this.push("done",null)}}class S{constructor(t=new s,e=null){this.geo=t,this.log=e}shape(){return new M(this.geo,null,this.log)}buildLog(t){var e;return this.log=t?new D:null,null===(e=this.log)||void 0===e?void 0:e.list}segments(t){const e=this.shape();e.beginPath();for(const n of t.regions){const t=n[n.length-1];e.moveTo(t[t.length-2],t[t.length-1]);for(const t of n)if(2===t.length)e.lineTo(t[0],t[1]);else{if(6!==t.length)throw new Error("PolyBool: Invalid point in region");e.bezierCurveTo(t[0],t[1],t[2],t[3],t[4],t[5])}e.closePath()}return{shape:e,inverted:t.inverted}}combine(t,e){return{shape:t.shape.combine(e.shape),inverted1:t.inverted,inverted2:e.inverted}}selectUnion(t){return{shape:t.inverted1?t.inverted2?t.shape.intersect():t.shape.difference():t.inverted2?t.shape.differenceRev():t.shape.union(),inverted:t.inverted1||t.inverted2}}selectIntersect(t){return{shape:t.inverted1?t.inverted2?t.shape.union():t.shape.differenceRev():t.inverted2?t.shape.difference():t.shape.intersect(),inverted:t.inverted1&&t.inverted2}}selectDifference(t){return{shape:t.inverted1?t.inverted2?t.shape.differenceRev():t.shape.union():t.inverted2?t.shape.intersect():t.shape.difference(),inverted:t.inverted1&&!t.inverted2}}selectDifferenceRev(t){return{shape:t.inverted1?t.inverted2?t.shape.difference():t.shape.intersect():t.inverted2?t.shape.union():t.shape.differenceRev(),inverted:!t.inverted1&&t.inverted2}}selectXor(t){return{shape:t.shape.xor(),inverted:t.inverted1!==t.inverted2}}polygon(t){const e=[],n={beginPath:()=>{},moveTo:()=>{e.push([])},lineTo:(t,n)=>{e[e.length-1].push([t,n])},bezierCurveTo:(t,n,s,i,a,r)=>{e[e.length-1].push([t,n,s,i,a,r])},closePath:()=>{}};return t.shape.output(n),{regions:e,inverted:t.inverted}}union(t,e){const n=this.segments(t),s=this.segments(e),i=this.combine(n,s),a=this.selectUnion(i);return this.polygon(a)}intersect(t,e){const n=this.segments(t),s=this.segments(e),i=this.combine(n,s),a=this.selectIntersect(i);return this.polygon(a)}difference(t,e){const n=this.segments(t),s=this.segments(e),i=this.combine(n,s),a=this.selectDifference(i);return this.polygon(a)}differenceRev(t,e){const n=this.segments(t),s=this.segments(e),i=this.combine(n,s),a=this.selectDifferenceRev(i);return this.polygon(a)}xor(t,e){const n=this.segments(t),s=this.segments(e),i=this.combine(n,s),a=this.selectXor(i);return this.polygon(a)}}new S;const T=new class extends s{atan2Deg(t,e){return Math.abs(t)<this.epsilon?e>0||Math.abs(e)<this.epsilon?0:180:Math.abs(e)<this.epsilon?t<0?270:90:Math.abs(e-t)<this.epsilon?e<0?225:45:Math.abs(e+t)<this.epsilon?e<0?135:315:(180*Math.atan2(t,e)/Math.PI+360)%360}sinDeg(t){const e=(t%360+360)%360;switch(e){case 0:case 180:return 0;case 30:case 150:return.5;case 45:case 135:return Math.SQRT1_2;case 60:case 120:return Math.sqrt(3)/2;case 90:return 1;case 210:case 330:return-.5;case 225:case 315:return-Math.SQRT1_2;case 240:case 300:return-Math.sqrt(3)/2;case 270:return-1;default:return Math.sin(e*Math.PI/180)}}cosDeg(t){const e=(t%360+360)%360;switch(e){case 0:return 1;case 30:case 330:return Math.sqrt(3)/2;case 45:case 315:return Math.SQRT1_2;case 60:case 300:return.5;case 90:case 270:return 0;case 120:case 240:return-.5;case 135:case 225:return-Math.SQRT1_2;case 150:case 210:return-Math.sqrt(3)/2;case 180:return-1;default:return Math.cos(e*Math.PI/180)}}linesIntersect(t,e,n,s,i,a,r,o){const l=n-t,h=s-e,c=r-i,u=o-a,d=l*u-h*c;if(0===this.snap0(d))return null;const p=t-i,g=e-a,f=this.snap01((c*g-u*p)/d);return{p:[t+f*l,e+f*h],alongA:f,alongB:this.snap01((l*g-h*p)/d)}}},E=new S(T);function B(t,e){if(0===T.snap0(e))return t;const n=[];t.output({beginPath:()=>{},moveTo:(t,e)=>{n.push({path:[],closed:!1})},lineTo:(t,e)=>{n[n.length-1].path.push([t,e])},bezierCurveTo:(t,e,s,i,a,r)=>{n[n.length-1].path.push([t,e,s,i,a,r])},closePath:()=>{n[n.length-1].closed=!0}});const s=Math.abs(e)/2,i=90*Math.sign(e),a=E.shape().beginPath();for(const{path:t,closed:e}of n){let n=t;if(e){n=[];const e=(e,n)=>{const s=t[e],i=t[(e+t.length-1)%t.length],a=i[i.length-2],r=i[i.length-1];return 2===s.length||n?T.atan2Deg(r-s[1],a-s[0]):T.atan2Deg(s[3]-s[5],s[2]-s[4])},a=(t,e,n)=>[t[0]+n*T.cosDeg(e),t[1]+n*T.sinDeg(e)],r=(t,e,n)=>a(t,e-i,n),o=[];for(let i=0;i<t.length;i++){const l=(i+t.length-1)%t.length,h=t[i],c=e(l,!1),u=e(i,!0),d=e(i,!1),p=Math.min(Math.abs(c-u),Math.abs(c+360-u),Math.abs(c-(u+360)));if(T.snap0(p)>0){const e=4*s*Math.tan(p/4*Math.PI/180)/3,i=t[l],h=[i[i.length-2],i[i.length-1]];o.push(n.length);const d=a(r(h,c,s),c,-e),g=a(r(h,u,s),u,e),f=r(h,u,s);n.push([d[0],d[1],g[0],g[1],f[0],f[1]])}if(2===h.length)n.push(r(h,d,s));else{const t=r([h[0],h[1]],u,s),e=r([h[2],h[3]],d,s),i=r([h[4],h[5]],d,s);n.push([t[0],t[1],e[0],e[1],i[0],i[1]])}}for(const t of o){const e=(t+n.length-1)%n.length,s=(t+n.length-2)%n.length,i=(t+1)%n.length,a=n[s],r=n[e],o=n[t],l=n[i];if(6===o.length){const t=T.linesIntersect(2===r.length?a[a.length-2]:r[2],2===r.length?a[a.length-1]:r[3],r[r.length-2],r[r.length-1],o[o.length-2],o[o.length-1],l[0],l[1]);t&&t.alongA>0&&t.alongA<1&&t.alongB>0&&t.alongB<1&&(o[0]=r[r.length-2],o[1]=r[r.length-1],o[2]=o[4],o[3]=o[5],r[r.length-2]=t.p[0],r[r.length-1]=t.p[1],o[4]=t.p[0],o[5]=t.p[1])}}}if(n.length>0){const t=n[n.length-1];a.moveTo(t[t.length-2],t[t.length-1]);for(const t of n)2===t.length?a.lineTo(t[0],t[1]):a.bezierCurveTo(t[0],t[1],t[2],t[3],t[4],t[5])}}return a}class C{constructor(t,e,n,s,i){this.home={origin:[0,0],angle:0},this.thickness=t,this.kerf=e,this.border=n,this.cuts=s,this.scores=i}replace(t){var e,n,s,i,a;const r=new C(null!==(e=t.thickness)&&void 0!==e?e:this.thickness,null!==(n=t.kerf)&&void 0!==n?n:this.kerf,null!==(s=t.border)&&void 0!==s?s:this.border,null!==(i=t.cuts)&&void 0!==i?i:this.cuts,null!==(a=t.scores)&&void 0!==a?a:this.scores);return r.setHome(this.home.origin,this.home.angle),r}copy(){return this.replace({})}static combine(t,e,n){const s=e.cuts.combine(n.cuts).union().combine(t).intersect(),i=e.scores.combine(n.scores).union().combine(t).intersect();return e.replace({border:t,cuts:s,scores:i})}static union(t,e){return C.combine(t.border.combine(e.border).union(),t,e)}static intersect(t,e){return C.combine(t.border.combine(e.border).intersect(),t,e)}static subtract(t,e){return C.combine(t.border.combine(e.border).difference(),t,e)}static xor(t,e){return C.combine(t.border.combine(e.border).xor(),t,e)}unionBorder(t){return C.union(this,this.replace({border:t,cuts:E.shape(),scores:E.shape()}))}subtractBorder(t){return C.subtract(this,this.replace({border:t,cuts:E.shape(),scores:E.shape()}))}setHome(t,e){return this.home={origin:t,angle:e},this}newShape(){return E.shape().translate(this.home.origin[0],this.home.origin[1]).rotateDeg(this.home.angle)}boundingBox(){const t=[1/0,1/0],e=[-1/0,-1/0];let n=!0;const s=s=>{for(const i of s.segments())for(const s of i){const i=s.boundingBox();t[0]=Math.min(t[0],i[0][0]),t[1]=Math.min(t[1],i[0][1]),e[0]=Math.max(e[0],i[1][0]),e[1]=Math.max(e[1],i[1][1]),n=!1}};return s(this.border),s(this.cuts),s(this.scores),n&&(t[0]=t[1]=e[0]=e[1]=0),[t,e]}applyKerf(){return 0===T.snap0(this.kerf)?this:this.replace({kerf:0,border:B(this.border,this.kerf)})}}class V{constructor(t){}}function F(t,e=0){switch(typeof t){case"string":return JSON.stringify(t).replace(/--/g,"\\u002d-");case"boolean":case"number":return JSON.stringify(t);case"object":if(null===t)return"null";if(Array.isArray(t)){if(t.every((t=>"object"==typeof t&&null!==t))){const n=[];for(let s=0;s<t.length;s++){const i=F(t[s],e);i&&n.push(i)}return`[${n.join(", ")}]`}{let n=[];for(let e=0;e<t.length;e++){const s=F(t[e]);s&&n.push(s)}const s=`[${n.join(",")}]`;if(s.length<60&&!s.includes("\n"))return s;n=[];for(let s=0;s<t.length;s++){const i=F(t[s],e+1);i&&n.push(i)}return`[\n${"  ".repeat(e+1)}${n.join(",\n")}\n${"  ".repeat(e)}]`}}{const n=[];for(const[s,i]of Object.entries(t)){const t=F(s),a=F(i,e+1);a&&n.push(`${"  ".repeat(e+1)}${t}: ${a}`)}return`{\n${n.join(",\n")}\n${"  ".repeat(e)}}`}}return""}class I extends V{constructor(t){super(t),this.surfaces=[],this.comments=[],this.settings=t}addSurface(t,e,n,s){this.surfaces.push({offset:t,surface:e.applyKerf(),cutColor:n,scoreColor:s})}addComment(t){this.comments.push(t)}toFile(){const t=t=>""+Math.round(1e3*t)/1e3,e=[];let n=0,s=0,i=100,a=100;if(this.surfaces.length>0){const r=[[1/0,1/0],[-1/0,-1/0]];for(const{offset:t,surface:e}of this.surfaces){const n=e.boundingBox();r[0][0]=Math.min(r[0][0],t[0]+n[0][0]-10),r[0][1]=Math.min(r[0][1],t[1]+n[0][1]-10),r[1][0]=Math.max(r[1][0],t[0]+n[1][0]+10),r[1][1]=Math.max(r[1][1],t[1]+n[1][1]+10)}n=r[0][0],s=r[0][1],i=r[1][0]-r[0][0],a=r[1][1]-r[0][1];let o=0;const l=()=>{e.push(`<g id="p-${o++}" style="fill:none;stroke-linecap:round;stroke-linejoin:round;">`)},h=()=>{e.push("</g>")},c=(n,s,i)=>{const a=[];s.output({beginPath:()=>{},moveTo:(e,n)=>{a.push(`M${t(e)} ${t(n)}`)},lineTo:(e,n)=>{a.push(`L${t(e)} ${t(n)}`)},bezierCurveTo:(e,n,s,i,r,o)=>{a.push(`C${t(e)} ${t(n)} ${t(s)} ${t(i)} ${t(r)} ${t(o)}`)},closePath:()=>{a.push("Z")}},[1,0,0,1,n[0],n[1]]),e.push(`<path stroke="${i}" stroke-width="1" d="${a.join("")}" />`)};for(const{offset:t,surface:e,cutColor:n,scoreColor:s}of this.surfaces)l(),l(),c(t,e.scores,s),h(),l(),c(t,e.border,n),c(t,e.cuts,n),h(),h()}const{units:r}=this.settings;return{mimeType:"image/svg+xml",extension:".svg",data:(new TextEncoder).encode(`<?xml version='1.0' encoding='utf-8'?>\n<svg\n  width="${t(i)}${r}"\n  height="${t(a)}${r}"\n  viewBox="${t(n)} ${t(s)} ${t(i)} ${t(a)}"\n  xmlns="http://www.w3.org/2000/svg">\n\x3c!--\nGenerated by boxburner\nby Sean Connelly (@velipso), https://sean.fun\nProject Home: https://github.com/velipso/boxburner\nSPDX-License-Identifier: 0BSD\n\nExported on: ${(new Date).toString()}\n--\x3e\n${this.comments.map((t=>`\x3c!--\n${F(t)}\n--\x3e`)).join("\n")}\n${e.join("\n")}\n</svg>`)}}}function q(t){const{fileFormat:e}=t;if("svg"===e)return new I(t);throw new Error(`Unknown export file format: ${e}`)}class H{}class L{}class R extends L{thickness(t,e){return this.jointThickness(!1,t,e)}draw(t,e,n,s){return this.jointDraw(t,e,!1,n,s)}}class $ extends R{name(){return"ButtJoint"}schema(){return{properties:{invert:{type:"boolean",metadata:{default:!1,title:"Invert",description:"Swap settings for receiving side"}},length1:{type:"float64",metadata:{default:0,title:"Length 1",description:"Length of butt 1 (multiples of material thickness)"}},length2:{type:"float64",metadata:{default:1,title:"Length 2",description:"Length of butt 2 (multiples of material thickness)"}}},metadata:{order:["invert","length1","length2"]}}}jointThickness(t,e,{length1:n,length2:s,invert:i}){return(t!==i?s:n)*e}jointDraw(t,e,n,s,i){return t}}function _({length:t,width1:e,width2:n,cornerDistance1:s,cornerDistance2:i,centerDistance:a},r){let o=0;const l=(t,e)=>{r(o,t,e),o+=t},h=t=>{if(t>1e4)throw new Error("Too many fingers");l(e,!0);for(let s=0;s<t;s++)l(n,!1),l(e,!0)},c=t-s-i;if(a>0){const t=(c-a)/2,r=Math.floor((t-e)/(e+n)),o=e+r*(e+n);l(s+(t-o)/2,!1),h(r),l(a+t-o,!1),h(r),l(i+(t-o)/2,!1)}else{const t=Math.floor((c-e)/(e+n)),a=e+t*(e+n);l(s+(c-a)/2,!1),h(t),l(i+(c-a)/2,!1)}}class J extends R{name(){return"BoxJoint"}schema(){return{properties:{invert:{type:"boolean",metadata:{default:!1,title:"Invert",description:"Swap settings for receiving side"}},width1:{type:"float64",metadata:{default:6,title:"Width 1",description:"Width of finger 1 (units)"}},length1:{type:"float64",metadata:{default:1,title:"Length 1",description:"Length of finger 1 (multiples of material thickness)"}},width2:{type:"float64",metadata:{default:6,title:"Width 2",description:"Width of finger 2 (units)"}},length2:{type:"float64",metadata:{default:1,title:"Length 2",description:"Length of finger 2 (multiples of material thickness)"}},play:{type:"float64",metadata:{default:0,title:"Play",description:"Extra space around fingers (units)"}},cornerDistance:{type:"float64",metadata:{default:12,title:"Corner Distance",description:"Reserved space near corners to exclude fingers (units)"}},cornerDistance1Delta:{type:"float64",nullable:!0,metadata:{default:null,defaultNotNull:0,title:"Corner Distance 1 Delta",description:"Additional corner distance"}},cornerDistance2Delta:{type:"float64",nullable:!0,metadata:{default:null,defaultNotNull:0,title:"Corner Distance 2 Delta",description:"Additional corner distance"}},centerDistance:{type:"float64",metadata:{default:0,title:"Center Distance",description:"Reserved space near center to exclude fingers (units)"}}},metadata:{order:["invert","width1","length1","width2","length2","play","cornerDistance","centerDistance"]}}}jointThickness(t,e,{length1:n,length2:s,invert:i}){return(t!==i?s:n)*e}jointDraw(t,e,n,s,{invert:i,width1:a,length1:r,width2:o,length2:l,play:h,cornerDistance:c,cornerDistance1Delta:u,cornerDistance2Delta:d,centerDistance:p}){const g=n!==i,f=(g?l:r)*s;return _({length:e,width1:a,width2:o,cornerDistance1:c+(null!=u?u:0),cornerDistance2:c+(null!=d?d:0),centerDistance:p},((e,n,s)=>{s===g&&(t=t.subtractBorder(t.newShape().beginPath().rect(e-h/2,0,n+h,f).closePath()))})),t}}class N extends L{name(){return"LegEdge"}schema(){return{properties:{flatWidth:{type:"float64",metadata:{default:.1,title:"Flat Width",description:"Flat part of leg (fraction of overall length)"}},curveWidth:{type:"float64",metadata:{default:.15,title:"Curve Width",description:"Curve part of leg (fraction of overall length)"}},curveAmount:{type:"float64",metadata:{default:.05,title:"Curve Amount",description:"How extreme to curve (fraction of overall length)"}},height:{type:"float64",metadata:{default:10,title:"Height (units)"}}},metadata:{order:["flatWidth","curveWidth","curveAmount","height"]}}}thickness(t,{height:e}){return Math.max(0,e)}draw(t,e,n,{flatWidth:s,curveWidth:i,curveAmount:a,height:r}){return r<=0?t:t.subtractBorder(t.newShape().beginPath().moveTo(s*e,0).bezierCurveTo((s+a)*e,0,(s+i-a)*e,r,(s+i)*e,r).lineTo((1-s-i)*e,r).bezierCurveTo((1-s-i+a)*e,r,(1-s-a)*e,0,(1-s)*e,0).closePath())}}function A(t,e={},n){return{discriminator:"kind",mapping:t.map((t=>({[t.name()]:{properties:{kind:{type:"string",metadata:{default:t.name(),title:t.name()}},params:t.schema()},metadata:{order:["params"],untabParams:!0}}}))).reduce(((t,e)=>({...t,...e})),{}),nullable:n,metadata:{default:t[0].name(),order:t.map((t=>t.name())),...e}}}const W=[new J,new $,new N];class j extends R{name(){return"MortiseAndTenonJoint"}schema(){return{properties:{invert:{type:"boolean",metadata:{default:!1,title:"Invert",description:"Swap settings for receiving side"}},width1:{type:"float64",metadata:{default:6,title:"Width 1",description:"Width of tenon (units)"}},tenonLength:{type:"float64",metadata:{default:1,title:"Tenon Length",description:"Length of tenon (multiples of material thickness)"}},width2:{type:"float64",metadata:{default:6,title:"Width 2",description:"Width between tenons (units)"}},holeDistance:{type:"float64",metadata:{default:3,title:"Hole Distance",description:"Distance of mortises from edge (units)"}},play:{type:"float64",metadata:{default:0,title:"Play",description:"Extra space between mortise and tenons (units)"}},thicknessPlay:{type:"float64",metadata:{default:0,title:"Thickness Play",description:"Extra thickness added to mortise holes (units)"}},cornerDistance:{type:"float64",metadata:{default:12,title:"Corner Distance",description:"Reserved space near corners to exclude joints (units)"}},cornerDistance1Delta:{type:"float64",nullable:!0,metadata:{default:null,defaultNotNull:0,title:"Corner Distance 1 Delta",description:"Additional corner distance"}},cornerDistance2Delta:{type:"float64",nullable:!0,metadata:{default:null,defaultNotNull:0,title:"Corner Distance 2 Delta",description:"Additional corner distance"}},centerDistance:{type:"float64",metadata:{default:0,title:"Center Distance",description:"Reserved space near center to exclude joints (units)"}},mortiseEdge:A(W,{default:null,defaultNotNull:"LegEdge",title:"Mortise Edge"},!0)},metadata:{order:["invert","width1","tenonLength","width2","holeDistance","play","thicknessPlay","cornerDistance","centerDistance","mortiseEdge"]}}}jointThickness(t,e,{tenonLength:n,invert:s,mortiseEdge:i}){if(t!==s){if(i){const t=W.find((t=>t.name()===i.kind));if(!t)throw new Error("Invalid mortise edge");return t.thickness(e,i.params)}return 0}return n*e}jointDraw(t,e,n,s,{invert:i,width1:a,tenonLength:r,width2:o,holeDistance:l,play:h,thicknessPlay:c,cornerDistance:u,cornerDistance1Delta:d,cornerDistance2Delta:p,centerDistance:g,mortiseEdge:f}){const m=n!==i;let v=0;if(m&&f){const n=W.find((t=>t.name()===f.kind));if(!n)throw new Error("Invalid mortise edge");v=n.thickness(s,f.params),t=n.draw(t,e,s,f.params)}return _({length:e,width1:a,width2:o,cornerDistance1:u+(null!=d?d:0),cornerDistance2:u+(null!=p?p:0),centerDistance:g},((e,n,i)=>{if(m&&i){const i=s,a=l+v;t=t.subtractBorder(t.newShape().beginPath().rect(e-h/2,a-c,n+h,i+2*c).closePath())}else if(!m&&!i){const i=r*s;t=t.subtractBorder(t.newShape().beginPath().rect(e-h/2,0,n+h,i).closePath())}})),t}}const O=[new $,new J,new N,new j],z=[new $,new J,new j];function U(t={},e){return A(O,t,e)}const K={" ":0,"!":74240,'"':516,"#":43580,$:43707,"%":61081,"&":37745,"'":512,"(":5120,")":16640,"*":65280,"+":43520,",":16384,"-":34816,".":65536,"/":17408,0:17663,1:1036,2:34935,3:2111,4:34956,5:35003,6:35067,7:15,8:35071,9:35007,":":8704,";":16896,"<":37888,"=":34864,">":18688,"?":75783,"@":2807,A:35023,B:10815,C:243,D:8767,E:33011,F:32963,G:2299,H:35020,I:8755,J:124,K:38080,L:240,M:1484,N:4556,O:255,P:35015,Q:4351,R:39111,S:35003,T:8707,U:252,V:17600,W:20684,X:21760,Y:35004,Z:17459,"[":8722,"\\":4352,"]":8737,"^":20480,_:48,"`":256,"{":41490,"|":8704,"}":10785,"~":52224},Q=(t,e,n,s,i)=>{var a;const r=null!==(a=K[i.toUpperCase()])&&void 0!==a?a:K["?"],o=(i,a,r,o)=>{t.moveTo(e[0]+i*n,e[1]+a*s).lineTo(e[0]+r*n,e[1]+o*s)},l=.025;1&r&&o(l,0,.475,0),2&r&&o(.525,0,.975,0),4&r&&o(1,l,1,.475),8&r&&o(1,.525,1,.975),16&r&&o(.975,1,.525,1),32&r&&o(.475,1,l,1),64&r&&o(0,.975,0,.525),128&r&&o(0,.475,0,l),256&r&&o(l,l,.475,.475),512&r&&o(.5,l,.5,.475),1024&r&&o(.975,l,.525,.475),2048&r&&o(.525,.5,.975,.5),4096&r&&o(.525,.525,.975,.975),8192&r&&o(.5,.525,.5,65536&r?.775:.975),16384&r&&o(.475,.525,l,.975),32768&r&&o(.475,.5,l,.5),65536&r&&o(.5,.8+l,.5,.975)};class X extends H{name(){return"Rectangle"}schema(){return{properties:{label:{type:"string",nullable:!0,metadata:{default:null,defaultNotNull:"",nullHint:"none",title:"Label"}},labelFontSize:{type:"float64",nullable:!0,metadata:{default:null,defaultNotNull:10,nullHint:"auto",title:"Label Font Size (units)"}},thickness:{type:"float64",nullable:!0,metadata:{default:null,defaultNotNull:3,nullHint:"default",title:"Material Thickness (units)"}},kerf:{type:"float64",nullable:!0,metadata:{default:null,defaultNotNull:.1,nullHint:"default",title:"Kerf (units)",description:"Thickness of material removed by cutting tool"}},width:{type:"float64",metadata:{default:100,title:"Inner Width (units)"}},height:{type:"float64",metadata:{default:100,title:"Inner Height (units)"}},edge1:U({title:"Top"}),edge2:U({title:"Right"}),edge3:U({title:"Bottom"}),edge4:U({title:"Left"})},metadata:{order:["label","labelFontSize","thickness","kerf","width","height","edge1","edge2","edge3","edge4"]}}}generate(t,{label:e,labelFontSize:n,thickness:s,kerf:i,width:a,height:r,edge1:o,edge2:l,edge3:h,edge4:c}){const u="number"==typeof s?s:t.defaultThickness,d="number"==typeof i?i:t.defaultKerf,p=O.find((t=>t.name()===o.kind));if(!p)throw new Error("Bad top edge");const g=O.find((t=>t.name()===l.kind));if(!g)throw new Error("Bad right edge");const f=O.find((t=>t.name()===h.kind));if(!f)throw new Error("Bad bottom edge");const m=O.find((t=>t.name()===c.kind));if(!m)throw new Error("Bad left edge");const v=p.thickness(u,o.params),w=g.thickness(u,l.params),b=f.thickness(u,h.params),y=m.thickness(u,c.params),k=a+w+y,P=r+v+b,M=E.shape().beginPath().moveTo(0,0).lineTo(k,0).lineTo(k,P).lineTo(0,P).closePath(),x=E.shape(),D=e?function(t,e,n,s,i,a){const r=t.split("\n"),o=r.reduce(((t,e)=>Math.max(t,e.length)),0),l="number"==typeof a?a:Math.min((s-5)/o*2,(i-5)/r.length),h=l/2,c=e+(s-h*o)/2,u=n+(i-l*r.length)/2,d=E.shape();for(let t=0;t<r.length;t++){const e=r[t];for(let n=0;n<e.length;n++)Q(d,[c+h*n+.15*h,u+l*t+.15*l],.7*h,.7*l,e.charAt(n))}return d}(e,y,v,a,r,n):E.shape();let S=new C(u,d,M,x,D);return S=p.draw(S.setHome([0,0],0),k,u,{...o.params,cornerDistance1Delta:y,cornerDistance2Delta:w}),S=g.draw(S.setHome([k,0],90),P,u,{...l.params,cornerDistance1Delta:v,cornerDistance2Delta:b}),S=f.draw(S.setHome([k,P],180),k,u,{...h.params,cornerDistance1Delta:w,cornerDistance2Delta:y}),S=m.draw(S.setHome([0,P],270),P,u,{...c.params,cornerDistance1Delta:b,cornerDistance2Delta:v}),[S]}}class Y extends H{name(){return"BoxPlain"}schema(){return{properties:{labels:{type:"boolean",metadata:{default:!1,title:"Labels"}},width:{type:"float64",metadata:{default:100,title:"Inner Width (units)"}},depth:{type:"float64",metadata:{default:100,title:"Inner Depth (units)"}},height:{type:"float64",metadata:{default:100,title:"Inner Height (units)"}},holeDistance:{type:"float64",metadata:{default:3,title:"Hole Distance",description:"Distance of mortises from edge (units)"}},play:{type:"float64",metadata:{default:0,title:"Play",description:"Extra space between fingers (units)"}},thicknessPlay:{type:"float64",metadata:{default:0,title:"Thickness Play",description:"Extra thickness added to mortise holes (units)"}}},metadata:{order:["labels","width","depth","height","holeDistance","play","thicknessPlay"]}}}generate(t,{labels:e,width:n,depth:s,height:i,holeDistance:a,play:r,thicknessPlay:o}){const{defaultThickness:l}=t,h=new X,c=t=>({kind:"MortiseAndTenonJoint",params:{invert:t,width1:2*l,tenonLength:1,width2:2*l,holeDistance:a,play:r,thicknessPlay:o,cornerDistance:2*l,centerDistance:0}}),u=t=>({kind:"BoxJoint",params:{invert:t,width1:2*l,length1:1,width2:2*l,length2:1,play:r,cornerDistance:2*l,centerDistance:0}});return[...h.generate(t,{width:n,height:s,edge1:c(!1),edge2:c(!1),edge3:c(!1),edge4:c(!1),...e?{label:"Bottom"}:{}}),...h.generate(t,{width:s,height:i,edge1:{kind:"ButtJoint",params:{invert:!1,length1:0,length2:1}},edge2:u(!1),edge3:c(!0),edge4:u(!1),...e?{label:"Left"}:{}}),...h.generate(t,{width:s,height:i,edge1:{kind:"ButtJoint",params:{invert:!1,length1:0,length2:1}},edge2:u(!1),edge3:c(!0),edge4:u(!1),...e?{label:"Right"}:{}}),...h.generate(t,{width:n,height:i,edge1:{kind:"ButtJoint",params:{invert:!1,length1:0,length2:1}},edge2:u(!0),edge3:c(!0),edge4:u(!0),...e?{label:"Front"}:{}}),...h.generate(t,{width:n,height:i,edge1:{kind:"ButtJoint",params:{invert:!1,length1:0,length2:1}},edge2:u(!0),edge3:c(!0),edge4:u(!0),...e?{label:"Back"}:{}})]}}class Z extends H{name(){return"BoxNested"}schema(){return{properties:{labels:{type:"boolean",metadata:{default:!1,title:"Labels"}},width:{type:"float64",metadata:{default:100,title:"Inner Width (units)"}},depth:{type:"float64",metadata:{default:100,title:"Inner Depth (units)"}},height:{type:"float64",metadata:{default:100,title:"Inner Height (units)"}},holeDistance:{type:"float64",metadata:{default:3,title:"Hole Distance",description:"Distance of mortises from edge (units)"}},play:{type:"float64",metadata:{default:0,title:"Play",description:"Extra space between fingers (units)"}},thicknessPlay:{type:"float64",metadata:{default:0,title:"Thickness Play",description:"Extra thickness added to mortise holes (units)"}}},metadata:{order:["labels","width","depth","height","holeDistance","play","thicknessPlay"]}}}generate(t,{labels:e,width:n,depth:s,height:i,holeDistance:a,play:r,thicknessPlay:o}){const{defaultThickness:l}=t,h=new X,c=(t,e,n)=>({kind:"MortiseAndTenonJoint",params:{invert:t,width1:2*l,tenonLength:e,width2:2*l,holeDistance:a,play:r,thicknessPlay:o,cornerDistance:2*l,centerDistance:0,mortiseEdge:n}}),u=(t,e)=>({kind:"BoxJoint",params:{invert:t,width1:2*l,length1:e,width2:2*l,length2:e,play:r,cornerDistance:2*l,centerDistance:0}});return[...h.generate(t,{width:n,height:s,edge1:c(!1,2),edge2:c(!1,1),edge3:c(!1,2),edge4:c(!1,1),...e?{label:"Bottom"}:{}}),...h.generate(t,{width:s,height:i,edge1:{kind:"ButtJoint",params:{invert:!1,length1:0,length2:1}},edge2:u(!1,2),edge3:c(!0,1),edge4:u(!1,2),...e?{label:"Left"}:{}}),...h.generate(t,{width:s,height:i,edge1:{kind:"ButtJoint",params:{invert:!1,length1:0,length2:1}},edge2:u(!1,2),edge3:c(!0,1),edge4:u(!1,2),...e?{label:"Right"}:{}}),...h.generate(t,{width:n,height:i,edge1:{kind:"ButtJoint",params:{invert:!1,length1:0,length2:1}},edge2:u(!0,1),edge3:c(!0,1),edge4:u(!0,1),...e?{label:"Front"}:{}}),...h.generate(t,{width:n,height:i,edge1:{kind:"ButtJoint",params:{invert:!1,length1:0,length2:1}},edge2:u(!0,1),edge3:c(!0,1,{kind:"LegEdge",params:{flatWidth:.1,curveWidth:.15,curveAmount:.05,height:10}}),edge4:u(!0,1),...e?{label:"Inner Front"}:{}}),...h.generate(t,{width:n,height:i,edge1:{kind:"ButtJoint",params:{invert:!1,length1:0,length2:1}},edge2:u(!0,1),edge3:c(!0,1),edge4:u(!0,1),...e?{label:"Back"}:{}}),...h.generate(t,{width:n,height:i,edge1:{kind:"ButtJoint",params:{invert:!1,length1:0,length2:1}},edge2:u(!0,1),edge3:c(!0,1,{kind:"LegEdge",params:{flatWidth:.1,curveWidth:.15,curveAmount:.05,height:10}}),edge4:u(!0,1),...e?{label:"Inner Back"}:{}})]}}class G extends H{name(){return"KerfTester"}schema(){return{properties:{labels:{type:"boolean",metadata:{default:!0,title:"Labels"}},width:{type:"float64",metadata:{default:30,title:"Outer Width (units)"}},height:{type:"float64",metadata:{default:15,title:"Outer Height (units)"}},play:{type:"float64",metadata:{default:0,title:"Play",description:"Extra space between fingers (units)"}},testCount:{type:"int32",metadata:{default:8,title:"Number of tests"}},kerfStart:{type:"float64",metadata:{default:.08,title:"Kerf start value (units)"}},kerfIncrement:{type:"float64",metadata:{default:.02,title:"Kerf increment value (per test)"}}},metadata:{order:["labels","width","height","play","testCount","kerfStart","kerfIncrement"]}}}generate(t,{labels:e,width:n,height:s,play:i,testCount:a,kerfStart:r,kerfIncrement:o}){const{defaultThickness:l}=t,h=new X,c=t=>({kind:"BoxJoint",params:{invert:t,width1:2*l,length1:1,width2:2*l,length2:1,play:i,cornerDistance:2*l,centerDistance:0}}),u=[];for(let i=0;i<a;i++){const a=r+i*o;u.push(...h.generate(t,{width:n,height:s,kerf:a,edge1:c(!1),edge2:{kind:"ButtJoint",params:{invert:!1,length1:0,length2:1}},edge3:{kind:"ButtJoint",params:{invert:!1,length1:0,length2:1}},edge4:{kind:"ButtJoint",params:{invert:!1,length1:0,length2:1}},...e?{label:a.toFixed(3)}:{}}),...h.generate(t,{width:n,height:s,kerf:a,edge1:{kind:"ButtJoint",params:{invert:!1,length1:0,length2:1}},edge2:{kind:"ButtJoint",params:{invert:!1,length1:0,length2:1}},edge3:c(!0),edge4:{kind:"ButtJoint",params:{invert:!1,length1:0,length2:1}},...e?{label:a.toFixed(3)}:{}}))}return u}}const tt=[new Z,new Y,new G,new X],et={properties:{defaultThickness:{type:"float64",metadata:{default:3,title:"Default Material Thickness (units)"}},defaultKerf:{type:"float64",metadata:{default:.1,title:"Default Kerf (units)",description:"Thickness of material removed by cutting tool"}},units:{enum:["mm","in"],metadata:{default:"mm",title:"Units"}},fileFormat:{enum:["svg"],metadata:{default:"svg",title:"File Format"}},debug:{type:"boolean",metadata:{default:!1,title:"Debug"}}},metadata:{title:"Settings",order:["defaultThickness","defaultKerf","units","fileFormat","debug"],startHidden:!0}};export{B as ApplyKerf,J as BoxJoint,Z as BoxNested,Y as BoxPlain,$ as ButtJoint,V as DocumentBase,I as DocumentSVG,L as EdgeBase,H as GeneratorBase,R as JointBase,G as KerfTester,N as LegEdge,j as MortiseAndTenonJoint,X as Rectangle,et as SettingsTypeDef,M as Shape,C as Surface,O as allEdges,U as allEdgesTypeDef,tt as allGenerators,z as allJoints,_ as boxJointFingerSpacer,A as edgeListTypeDef,q as exportDocument,T as geo,E as polybool};
