class t{}function e(t,e){if(e.length<=0)throw new Error(`${t}: Cannot have empty list of commands for closed path`);const o=e[e.length-1].to;if(0!==o[0]||0!==o[1])throw new Error(`${t}: Closed path must end on [0, 0]`)}function o(t){let e=0;for(let o=0;o<t.length;o++){const s=t[o].to,r=t[(o+1)%t.length].to;e+=(r[0]-s[0])*(r[1]+s[1])}return e<0}class s{constructor(t,s,r=[],n=[],h=[]){if(e("Surface border",s),!o(s))throw new Error("Surface border: Points must be in counter-clockwise order for border");for(let t=0;t<r.length;t++){const s=`Surface hole ${t}`;if(e(s,r[t]),o(r[t]))throw new Error(`${s}: Points must be in clockwise order for holes`)}this.thickness=t,this.border=s,this.holes=r,this.cuts=n,this.text=h}}class r{constructor(){this.commands=[]}cursor(){return this.commands.length<=0?[0,0]:this.commands[this.commands.length-1].to}lineTo(t){return this.commands.push({kind:"L",to:t}),this}quadCurveTo(t,e){const o=this.cursor();return this.curveTo([o[0]+2*(t[0]-o[0])/3,o[1]+2*(t[1]-o[1])/3],[e[0]+2*(t[0]-e[0])/3,e[1]+2*(t[1]-e[1])/3],e)}curveTo(t,e,o){return this.commands.push({kind:"C",c1:t,c2:e,to:o}),this}build(){return this.commands}}class n extends t{name(){return"PlainBox"}defaultParams(){return{thickness:3,width:100,height:100}}schema(){return{properties:{thickness:{type:"float64"},width:{type:"float64"},height:{type:"float64"}},metadata:{keyOrder:["thickness","width","height"],titles:{thickness:"Material Thickness (mm)",width:"Outer Width (mm)",height:"Outer Height (mm)"}}}}generate({thickness:t,width:e,height:o}){return new s(t,(new r).lineTo([e,0]).lineTo([e,o]).lineTo([0,o]).lineTo([0,0]).build())}}function h(){const t=new n;console.log(t.schema()),console.log(t.generate({thickness:3,width:50,height:30}))}export{r as DrawBuilder,t as GeneratorBase,n as PlainBox,s as Surface,h as test};
