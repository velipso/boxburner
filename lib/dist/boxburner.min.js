class t{}function e(t,e){if(e.length<=0)throw new Error(`${t}: Cannot have empty list of commands for closed path`);const n=e[e.length-1].to;if(0!==n[0]||0!==n[1])throw new Error(`${t}: Closed path must end on [0, 0]`)}function n(t){let e=0;for(let n=0;n<t.length;n++){const o=t[n].to,r=t[(n+1)%t.length].to;e+=(r[0]-o[0])*(r[1]+o[1])}return e<0}function o(t,e,n,o){const r=(r,a)=>t[r]*(1-a)*(1-a)*(1-a)+3*e[r]*a*(1-a)*(1-a)+3*n[r]*a*a*(1-a)+o[r]*a*a*a,a=a=>{const s=3*o[a]-9*n[a]+9*e[a]-3*t[a],i=6*t[a]-12*e[a]+6*n[a],d=3*e[a]-3*t[a];let c=Math.min(t[a],o[a]),h=Math.max(t[a],o[a]);if(Math.abs(s)<=1e-8){const t=-d/i;if(t>0&&t<1){const e=r(a,t);c=Math.min(c,e),h=Math.max(h,e)}}else{const t=i*i-4*s*d;if(t>=0){const e=Math.sqrt(t),n=(-i+e)/(2*s);if(n>0&&n<1){const t=r(a,n);c=Math.min(c,t),h=Math.max(h,t)}const o=(-i-e)/(2*s);if(o>0&&o<1){const t=r(a,o);c=Math.min(c,t),h=Math.max(h,t)}}}return[c,h]},s=a(0),i=a(1);return[[s[0],i[0]],[s[1],i[1]]]}class r{constructor(t,o,r=[],a=[],s=[],i=[]){if(e("Surface border",o),!n(o))throw new Error("Surface border: Points must be in counter-clockwise order for border");for(let t=0;t<r.length;t++){const o=`Surface hole ${t}`;if(e(o,r[t].commands),n(r[t].commands))throw new Error(`${o}: Points must be in clockwise order for holes`)}this.thickness=t,this.border=o,this.holes=r,this.cuts=a,this.scores=s,this.text=i}borderBoundingBox(){return function(t){const e=[0,0],n=[0,0];let r=[0,0];for(const a of t){switch(a.kind){case"L":e[0]=Math.min(e[0],a.to[0]),e[1]=Math.min(e[1],a.to[1]),n[0]=Math.max(n[0],a.to[0]),n[1]=Math.max(n[1],a.to[1]);break;case"C":{const t=o(r,a.c1,a.c2,a.to);e[0]=Math.min(e[0],t[0][0]),e[1]=Math.min(e[1],t[0][1]),n[0]=Math.max(n[0],t[1][0]),n[1]=Math.max(n[1],t[1][1]);break}}r=a.to}return[e,n]}(this.border)}}const a={properties:{thickness:{type:"float64",metadata:{default:3,title:"Material Thickness (units)"}},kerf:{type:"float64",metadata:{default:.1,title:"Kerf",description:"Thickness of material removed by cutting tool (units)"}},units:{enum:["mm","in"],metadata:{default:"mm",title:"Units"}},fileFormat:{enum:["svg"],metadata:{default:"svg",title:"File Format"}},debug:{type:"boolean",metadata:{default:!1,title:"Debug"}}},metadata:{title:"Settings",order:["thickness","kerf","units","fileFormat","debug"],startHidden:!0}};var s;!function(t){t[t.BeforeStart=0]="BeforeStart",t[t.EqualStart=1]="EqualStart",t[t.BetweenStartAndEnd=2]="BetweenStartAndEnd",t[t.EqualEnd=3]="EqualEnd",t[t.AfterEnd=4]="AfterEnd"}(s||(s={}));const i=1e-7;function d(t){return[t[0],t[1]]}function c(t,e,n){return e=(e%360+360)%360,0!==n&&(0===e?t[0]+=n:90===e?t[1]+=n:180===e?t[0]-=n:270===e?t[1]-=n:(t[0]+=n*Math.cos(e*Math.PI/180),t[1]+=n*Math.sin(e*Math.PI/180))),t}function h(t,e,n,o){const r=e[0]-t[0],a=e[1]-t[1],d=o[0]-n[0],c=o[1]-n[1],h=r*c-a*d;if(Math.abs(h)<i)return null;const l=t[0]-n[0],f=t[1]-n[1],u=(d*f-c*l)/h,m=(r*f-a*l)/h,g=t=>t<=-i?s.BeforeStart:t<i?s.EqualStart:t-1<=-i?s.BetweenStartAndEnd:t-1<i?s.EqualEnd:s.AfterEnd,p=[t[0]+u*r,t[1]+u*a];return{alongA:g(u),alongB:g(m),p:p}}function l(t,e,n){if(n<=0)return{offset:t,commands:e};const o=n/2,r=d(t),a=[],i=t=>{const n=e[t],r=e[0===t?e.length-1:t-1],a=Math.atan2(r.to[1]-n.to[1],r.to[0]-n.to[0]),s=a+Math.PI/2;return{angle:a,offset:[o*Math.cos(s),o*Math.sin(s)]}},c=[];for(let t=0;t<e.length;t++){const n=e[t],r=e[(t+e.length-1)%e.length],{angle:s,offset:[d,h]}=i(t);switch(n.kind){case"L":{const{angle:l,offset:[f,u]}=i((t+e.length-1)%e.length),m=Math.min(Math.abs(s-l),Math.abs(s+2*Math.PI-l),Math.abs(s-(l+2*Math.PI))),g=4*o*Math.tan(m/4)/3;c.push(a.length),a.push({kind:"C",c1:[r.to[0]+f-g*Math.cos(l),r.to[1]+u-g*Math.sin(l)],c2:[r.to[0]+d+g*Math.cos(s),r.to[1]+h+g*Math.sin(s)],to:[r.to[0]+d,r.to[1]+h]}),a.push({kind:"L",to:[n.to[0]+d,n.to[1]+h]});break}case"C":a.push({kind:"C",c1:[n.c1[0]+d,n.c1[1]+h],c2:[n.c2[0]+d,n.c2[1]+h],to:[n.to[0]+d,n.to[1]+h]})}}for(const t of c){const e=a[(t+a.length-2)%a.length],n=a[(t+a.length-1)%a.length],o=a[t],r=a[(t+1)%a.length];if("L"===n.kind&&"C"===o.kind&&"L"===r.kind){const t=h(e.to,n.to,o.to,r.to);t&&t.alongA===s.BetweenStartAndEnd&&t.alongB===s.BetweenStartAndEnd&&(o.c1=n.to,o.c2=o.to,n.to=d(t.p),o.to=d(t.p))}}const[l,f]=a[a.length-1].to;r[0]+=l,r[1]+=f;for(const t of a)switch(t.kind){case"L":t.to[0]-=l,t.to[1]-=f;break;case"C":t.c1[0]-=l,t.c1[1]-=f,t.c2[0]-=l,t.c2[1]-=f,t.to[0]-=l,t.to[1]-=f}return{offset:r,commands:a}}class f{constructor(){this.commands=[],this.angle=0}cursor(){return this.commands.length<=0?[0,0]:this.commands[this.commands.length-1].to}lineTo(t){var e,n;const o=this.commands[this.commands.length-1];if(o&&"L"===o.kind){const r=null!==(n=null===(e=this.commands[this.commands.length-2])||void 0===e?void 0:e.to)&&void 0!==n?n:[0,0],a=o.to,s=t;if(Math.abs(r[0]-s[0])<i&&Math.abs(r[1]-s[1])<i)return this.commands.pop(),this;const d=r[0]-a[0],c=r[1]-a[1],h=a[0]-s[0],l=a[1]-s[1];if(Math.abs(d*l-h*c)<i)return o.to=t,this}return this.commands.push({kind:"L",to:t}),this}lineToRelative(t){const e=this.cursor();return this.lineTo([e[0]+t[0],e[1]+t[1]])}quadCurveTo(t,e){const n=this.cursor();return this.curveTo([n[0]+2*(t[0]-n[0])/3,n[1]+2*(t[1]-n[1])/3],[e[0]+2*(t[0]-e[0])/3,e[1]+2*(t[1]-e[1])/3],e)}curveTo(t,e,n){return this.commands.push({kind:"C",c1:t,c2:e,to:n}),this}turn(t){return this.angle=((this.angle+t)%360+360)%360,this}forward(t){return 0!==t&&this.lineToRelative(c([0,0],this.angle,t)),this}close(){var t,e;this.lineTo([0,0]);const n=this.commands[0],o=this.commands[this.commands.length-1];if("L"===(null==o?void 0:o.kind)&&"L"===(null==n?void 0:n.kind)){const r=null!==(e=null===(t=this.commands[this.commands.length-2])||void 0===t?void 0:t.to)&&void 0!==e?e:[0,0],a=o.to,s=n.to,d=r[0]-a[0],c=r[1]-a[1],h=a[0]-s[0],l=a[1]-s[1];if(Math.abs(r[0]-s[0])<i&&Math.abs(r[1]-s[1])<i)this.commands.shift();else if(Math.abs(d*l-h*c)>=i)return this;this.commands.pop();for(const t of this.commands)t.to[0]-=r[0],t.to[1]-=r[1],"C"===t.kind&&(t.c1[0]-=r[0],t.c1[1]-=r[1],t.c2[0]-=r[0],t.c2[1]-=r[1])}return this}build(){return this.commands}}class u{constructor(){this.border=new f,this.holes=[],this.cuts=[],this.scores=[],this.text=[]}hole(t,e=0){const n=new f;return n.turn(e),this.holes.push({offset:t,db:n}),n}cut(t,e=0){const n=new f;return n.turn(e),this.cuts.push({offset:t,db:n}),n}score(t,e=0){const n=new f;return n.turn(e),this.scores.push({offset:t,db:n}),n}build(t){return new r(t,this.border.close().build(),this.holes.map((({offset:t,db:e})=>({offset:t,commands:e.close().build()}))),this.cuts.map((({offset:t,db:e})=>({offset:t,commands:e.close().build()}))),this.scores.map((({offset:t,db:e})=>({offset:t,commands:e.close().build()}))),this.text)}}class m{}class g extends m{name(){return"ButtJoint"}schema(){return{properties:{invert:{type:"boolean",metadata:{default:!1,title:"Invert",description:"Swap settings for receiving side"}},length1:{type:"float64",metadata:{default:0,title:"Length 1",description:"Length of butt 1 (multiples of material thickness)"}},length2:{type:"float64",metadata:{default:1,title:"Length 2",description:"Length of butt 2 (multiples of material thickness)"}}},metadata:{order:["invert","length1","length2"]}}}thickness(t,e,{thickness:n},{length1:o,length2:r,invert:a}){return(e!==a?-r:o)*n}draw(t,e,n,{thickness:o},{invert:r,length1:a,length2:s}){const i=n!==r,d=(i?s:a)*o,c=i?-90:90;t.border.turn(-c).forward(d).turn(c).forward(e).turn(c).forward(d).turn(-c)}}class p extends m{name(){return"BoxJoint"}schema(){return{properties:{invert:{type:"boolean",metadata:{default:!1,title:"Invert",description:"Swap settings for receiving side"}},width1:{type:"float64",metadata:{default:6,title:"Width 1",description:"Width of finger 1 (units)"}},length1:{type:"float64",metadata:{default:1,title:"Length 1",description:"Length of finger 1 (multiples of material thickness)"}},width2:{type:"float64",metadata:{default:6,title:"Width 2",description:"Width of finger 2 (units)"}},length2:{type:"float64",metadata:{default:1,title:"Length 2",description:"Length of finger 2 (multiples of material thickness)"}},play:{type:"float64",metadata:{default:0,title:"Play",description:"Extra space around fingers (units)"}},cornerDistance:{type:"float64",metadata:{default:12,title:"Corner Distance",description:"Reserved space near corners to exclude fingers (units)"}},centerDistance:{type:"float64",metadata:{default:0,title:"Center Distance",description:"Reserved space near center to exclude fingers (units)"}}},metadata:{order:["invert","width1","length1","width2","length2","play","cornerDistance","centerDistance"]}}}thickness(t,e,{thickness:n},{length1:o,length2:r,invert:a}){return(e!==a?-r:o)*n}draw(t,e,n,{thickness:o},{invert:r,width1:a,length1:s,width2:i,length2:d,play:c,cornerDistance:h,centerDistance:l}){const f=t.border,u=n!==r,m=(u?d:s)*o,g=u?-c:c,p=u?-90:90,w=()=>f.forward(g/2).turn(-p).forward(m).turn(p).forward(a-g).turn(p).forward(m).turn(-p).forward(g/2),b=t=>{w();for(let e=0;e<t;e++)f.forward(i),w()},k=e-2*h;if(l>0){const t=(k-l)/2,e=Math.floor((t-a)/(a+i)),n=a+e*(a+i);f.forward(h+(t-n)/2),b(e),f.forward(l+t-n),b(e),f.forward(h+(t-n)/2)}else{const t=Math.floor((k-a)/(a+i)),e=a+t*(a+i);f.forward(h+(k-e)/2),b(t),f.forward(h+(k-e)/2)}}}class w extends m{name(){return"MortiseAndTenonJoint"}schema(){return{properties:{invert:{type:"boolean",metadata:{default:!1,title:"Invert",description:"Swap settings for receiving side"}},width1:{type:"float64",metadata:{default:6,title:"Width 1",description:"Width of tenon (units)"}},tenonLength:{type:"float64",metadata:{default:1,title:"Tenon Length",description:"Length of tenon (multiples of material thickness)"}},width2:{type:"float64",metadata:{default:6,title:"Width 2",description:"Width between tenons (units)"}},holeDistance:{type:"float64",metadata:{default:3,title:"Hole Distance",description:"Distance of mortises from edge (units)"}},play:{type:"float64",metadata:{default:0,title:"Play",description:"Extra space between mortise and tenons (units)"}},thicknessPlay:{type:"float64",metadata:{default:0,title:"Thickness Play",description:"Extra thickness added to mortise holes (units)"}},cornerDistance:{type:"float64",metadata:{default:12,title:"Corner Distance",description:"Reserved space near corners to exclude joints (units)"}},centerDistance:{type:"float64",metadata:{default:0,title:"Center Distance",description:"Reserved space near center to exclude joints (units)"}}},metadata:{order:["invert","width1","tenonLength","width2","holeDistance","play","thicknessPlay","cornerDistance","centerDistance"]}}}thickness(t,e,{thickness:n},{tenonLength:o,invert:r}){return e!==r?0:o*n}draw(t,e,n,{thickness:o},{invert:r,width1:a,tenonLength:s,width2:i,holeDistance:h,play:l,thicknessPlay:f,cornerDistance:u,centerDistance:m}){const g=n!==r,p=g?-l:l;let w=t=>{},b=()=>{},k=()=>{};const y=t=>{b();for(let e=0;e<t;e++)k(),b()};if(g){const n=o+2*f,r=d(t.border.cursor()),s=t.border.angle;c(r,s+90,h+n-f),t.border.forward(e),w=t=>{c(r,s,t)},b=()=>{w(p/2),t.hole(d(r),s).forward(a-p).turn(-90).forward(n).turn(-90).forward(a-p).turn(-90).forward(n).turn(-90),w(-p/2),w(a)},k=()=>{w(i)}}else{const e=s*o,n=90;w=e=>t.border.forward(e),b=()=>t.border.forward(p/2).turn(-n).forward(e).turn(n).forward(a-p).turn(n).forward(e).turn(-n).forward(p/2),k=()=>t.border.forward(i)}const M=e-2*u;if(m>0){const t=(M-m)/2,e=Math.floor((t-a)/(a+i)),n=a+e*(a+i);w(u+(t-n)/2),y(e),w(m+t-n),y(e),w(u+(t-n)/2)}else{const t=Math.floor((M-a)/(a+i)),e=a+t*(a+i);w(u+(M-e)/2),y(t),w(u+(M-e)/2)}}}const b=[new g,new p,new w];function k(t={}){return{discriminator:"kind",mapping:b.map((t=>({[t.name()]:{properties:{kind:{type:"string",metadata:{default:t.name(),title:t.name()}},params:t.schema()},metadata:{order:["params"],untabParams:!0}}}))).reduce(((t,e)=>({...t,...e})),{}),metadata:{default:b[0].name(),order:b.map((t=>t.name())),...t}}}class y extends t{name(){return"Rectangle"}schema(){return{properties:{width:{type:"float64",metadata:{default:100,title:"Outer Width (units)"}},height:{type:"float64",metadata:{default:100,title:"Outer Height (units)"}},edge1:k({title:"Top"}),edge2:k({title:"Right"}),edge3:k({title:"Bottom"}),edge4:k({title:"Left"})},metadata:{order:["width","height","edge1","edge2","edge3","edge4"]}}}generate(t,{width:e,height:n,edge1:o,edge2:r,edge3:a,edge4:s}){const{thickness:i}=t,d=new u,c=b.find((t=>t.name()===o.kind));if(!c)throw new Error("Bad top edge");const h=b.find((t=>t.name()===r.kind));if(!h)throw new Error("Bad right edge");const l=b.find((t=>t.name()===a.kind));if(!l)throw new Error("Bad bottom edge");const f=b.find((t=>t.name()===s.kind));if(!f)throw new Error("Bad left edge");const m=c.thickness(e,!1,t,o.params),g=h.thickness(n,!1,t,r.params),p=l.thickness(e,!1,t,a.params),w=f.thickness(n,!1,t,s.params);return e-=Math.abs(g)+Math.abs(w),n-=Math.abs(m)+Math.abs(p),w<0&&d.border.forward(-w),c.draw(d,e,!1,t,o.params),g<0&&d.border.forward(-g),d.border.turn(90),m<0&&d.border.forward(-m),h.draw(d,n,!1,t,r.params),p<0&&d.border.forward(-p),d.border.turn(90),g<0&&d.border.forward(-g),l.draw(d,e,!1,t,a.params),w<0&&d.border.forward(-w),d.border.turn(90),p<0&&d.border.forward(-p),f.draw(d,n,!1,t,s.params),m<0&&d.border.forward(-m),d.border.turn(90),[d.build(i)]}}class M extends t{name(){return"PlainBox"}schema(){return{properties:{width:{type:"float64",metadata:{default:100,title:"Outer Width (units)"}},depth:{type:"float64",metadata:{default:100,title:"Outer Depth (units)"}},height:{type:"float64",metadata:{default:100,title:"Outer Height (units)"}},holeDistance:{type:"float64",metadata:{default:3,title:"Hole Distance",description:"Distance of mortises from edge (units)"}},play:{type:"float64",metadata:{default:0,title:"Play",description:"Extra space between fingers (units)"}},thicknessPlay:{type:"float64",metadata:{default:0,title:"Thickness Play",description:"Extra thickness added to mortise holes (units)"}}},metadata:{order:["width","depth","height","holeDistance","play","thicknessPlay"]}}}generate(t,{width:e,depth:n,height:o,holeDistance:r,play:a,thicknessPlay:s}){const{thickness:i}=t,d=new y,c=t=>({kind:"MortiseAndTenonJoint",params:{invert:t,width1:2*i,tenonLength:1,width2:2*i,holeDistance:r,play:a,thicknessPlay:s,cornerDistance:2*i,centerDistance:0}}),h=t=>({kind:"BoxJoint",params:{invert:t,width1:2*i,length1:1,width2:2*i,length2:1,play:a,cornerDistance:2*i,centerDistance:0}});return[...d.generate(t,{width:e,height:n,edge1:c(!1),edge2:c(!1),edge3:c(!1),edge4:c(!1)}),...d.generate(t,{width:n,height:o,edge1:{kind:"ButtJoint",params:{invert:!1,length1:0,length2:1}},edge2:h(!1),edge3:c(!0),edge4:h(!1)}),...d.generate(t,{width:n,height:o,edge1:{kind:"ButtJoint",params:{invert:!1,length1:0,length2:1}},edge2:h(!1),edge3:c(!0),edge4:h(!1)}),...d.generate(t,{width:e,height:o,edge1:{kind:"ButtJoint",params:{invert:!1,length1:0,length2:1}},edge2:h(!0),edge3:c(!0),edge4:h(!0)}),...d.generate(t,{width:e,height:o,edge1:{kind:"ButtJoint",params:{invert:!1,length1:0,length2:1}},edge2:h(!0),edge3:c(!0),edge4:h(!0)})]}}const v=[new y,new M];class x{constructor(t){}}class D extends x{constructor(t){super(t),this.surfaces=[],this.settings=t}addSurface(t,e,n,o,r){this.surfaces.push({offset:t,surface:e,cutColor:n,holeColor:o,scoreColor:r})}toFile(){const{kerf:t,units:e}=this.settings,n=[[0,0],[0,0]];for(const{offset:e,surface:o}of this.surfaces){const r=o.borderBoundingBox();n[0][0]=Math.min(n[0][0],e[0]+r[0][0]-t-10),n[0][1]=Math.min(n[0][1],e[1]+r[0][1]-t-10),n[1][0]=Math.max(n[1][0],e[0]+r[1][0]+t+10),n[1][1]=Math.max(n[1][1],e[1]+r[1][1]+t+10)}const o=[],r=t=>""+Math.round(1e3*t)/1e3;let a=0;const s=()=>{o.push(`<g id="p-${a++}" style="fill:none;stroke-linecap:round;stroke-linejoin:round;">`)},i=()=>{o.push("</g>")},d=(e,n,a,s)=>{a&&t>0&&({offset:e,commands:n}=l(e,n,t));const i=[`M${r(e[0])} ${r(e[1])}`];for(const t of n)switch(t.kind){case"L":i.push(`L${r(e[0]+t.to[0])} ${r(e[1]+t.to[1])}`);break;case"C":i.push(`C${r(e[0]+t.c1[0])} ${r(e[1]+t.c1[1])}`,` ${r(e[0]+t.c2[0])} ${r(e[1]+t.c2[1])}`,` ${r(e[0]+t.to[0])} ${r(e[1]+t.to[1])}`)}a&&i.push("Z"),o.push(`<path stroke="${s}" stroke-width="${t<=0?.1:t}" d="${i.join("")}" />`)};for(const{offset:t,surface:e,cutColor:n,holeColor:o,scoreColor:r}of this.surfaces){if((e.scores.length>0||e.holes.length>0)&&s(),e.scores.length>0){s();for(const n of e.scores)d([t[0]+n.offset[0],t[1]+n.offset[1]],n.commands,!1,r);i()}s(),d(t,e.border,!0,n);for(const o of e.cuts)d([t[0]+o.offset[0],t[1]+o.offset[1]],o.commands,!1,n);if(i(),e.holes.length>0){s();for(const n of e.holes)d([t[0]+n.offset[0],t[1]+n.offset[1]],n.commands,!0,o);i()}(e.scores.length>0||e.holes.length>0)&&i()}const c=n[1][0]-n[0][0],h=n[1][1]-n[0][1];return{mimeType:"image/svg+xml",extension:".svg",data:(new TextEncoder).encode(`<?xml version='1.0' encoding='utf-8'?>\n<svg\n  width="${r(c)}${e}"\n  height="${r(h)}${e}"\n  viewBox="${r(n[0][0])} ${r(n[0][1])} ${r(c)} ${r(h)}"\n  xmlns="http://www.w3.org/2000/svg">\n\x3c!--\nGenerated by boxburner\nby Sean Connelly (@velipso), https://sean.fun\nProject Home: https://github.com/velipso/boxburner\nSPDX-License-Identifier: 0BSD\n--\x3e\n${o.join("")}\n</svg>`)}}}function E(t){const{fileFormat:e}=t;if("svg"===e)return new D(t);throw new Error(`Unknown export file format: ${e}`)}export{s as AlongIntersection,p as BoxJoint,g as ButtJoint,x as DocumentBase,D as DocumentSVG,f as DrawBuilder,m as EdgeBase,t as GeneratorBase,w as MortiseAndTenonJoint,M as PlainBox,y as Rectangle,a as SettingsTypeDef,r as Surface,u as SurfaceBuilder,b as allEdges,k as allEdgesTypeDef,v as allGenerators,d as copyVec2,i as eps,l as expandPathByKerf,E as exportDocument,c as forwardVec2,h as linesIntersect};
